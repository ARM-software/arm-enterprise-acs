From 62907cede03a12b94d800b15707c1c1cdba126ed Mon Sep 17 00:00:00 2001
From: Sakar Arora <Sakar.Arora@arm.com>
Date: Tue, 25 Apr 2017 15:15:50 +0530
Subject: [PATCH] luvOS 4.10

---
 build_luvos.sh                                     |   113 +
 meta-luv/classes/luv-efi.bbclass                   |    79 +-
 meta-luv/conf/distro/luv.conf                      |     2 +-
 meta-luv/recipes-bsp/sbbr/sbbr/README.md           |     2 +
 meta-luv/recipes-bsp/sbbr/sbbr_v1.0.bb             |    97 +
 meta-luv/recipes-bsp/sbsa/files/compile.sh         |    16 +
 meta-luv/recipes-bsp/sbsa/sbsa.bb                  |   104 +
 meta-luv/recipes-core/efivarfs/efivarfs-test.bb    |     1 -
 meta-luv/recipes-core/fwts/fwts/sbbr.patch         | 11950 +++++++++++++++++++
 meta-luv/recipes-core/fwts/fwts_git.bb             |     4 +-
 .../images/core-image-efi-initramfs.bb             |     1 +
 meta-luv/recipes-core/images/luv-live-image.bb     |     8 +-
 meta-luv/recipes-core/images/luv-netboot-image.bb  |    10 +-
 .../kernel_efi_warnings/kernel-efi-warnings_0.1.bb |     2 -
 meta-luv/recipes-core/luv-test/luv-test.bb         |     6 +
 .../luv-test/luv-test/luv-collect-results          |   209 +
 .../recipes-core/luv-test/luv-test/luv-sbsa-test   |     5 +
 .../luv-test/luv-test/luv-test-manager             |     5 +
 .../linux/linux-yocto-efi-test_4.10.bb             |     3 +
 meta/conf/bitbake.conf                             |     2 +-
 sbsa_setup.sh                                      |    28 +
 21 files changed, 12629 insertions(+), 18 deletions(-)
 create mode 100755 build_luvos.sh
 create mode 100644 meta-luv/recipes-bsp/sbbr/sbbr/README.md
 create mode 100644 meta-luv/recipes-bsp/sbbr/sbbr_v1.0.bb
 create mode 100755 meta-luv/recipes-bsp/sbsa/files/compile.sh
 create mode 100644 meta-luv/recipes-bsp/sbsa/sbsa.bb
 create mode 100644 meta-luv/recipes-core/fwts/fwts/sbbr.patch
 create mode 100644 meta-luv/recipes-core/luv-test/luv-test/luv-collect-results
 create mode 100755 meta-luv/recipes-core/luv-test/luv-test/luv-sbsa-test
 create mode 100755 sbsa_setup.sh

diff --git a/build_luvos.sh b/build_luvos.sh
new file mode 100755
index 0000000..06cde48
--- /dev/null
+++ b/build_luvos.sh
@@ -0,0 +1,113 @@
+#!/bin/bash
+# The material contained herein is not a license, either
+# expressly or impliedly, to any intellectual property owned
+# or controlled by any of the authors or developers of this
+# material or to any contribution thereto. The material
+# contained herein is provided on an "AS IS" basis and, to the
+# maximum extent permitted by applicable law, this information
+# is provided AS IS AND WITH ALL FAULTS, and the authors and
+# developers of this material hereby disclaim all other
+# warranties and conditions, either express, implied or
+# statutory, including, but not limited to, any (if any)
+# implied warranties, duties or conditions of merchantability,
+# of fitness for a particular purpose, of accuracy or
+# completeness of responses, of results, of workmanlike
+# effort, of lack of viruses and of lack of negligence, all
+# with regard to this material and any contribution thereto.
+# Designers must not rely on the absence or characteristics of
+# any features or instructions marked "reserved" or
+# "undefined." The ARM, Inc. reserves any
+# features or instructions so marked for future definition and
+# shall have no responsibility whatsoever for conflicts or
+# incompatibilities arising from future changes to them. ALSO,
+# THERE IS NO WARRANTY OR CONDITION OF TITLE, QUIET ENJOYMENT,
+# QUIET POSSESSION, CORRESPONDENCE TO DESCRIPTION OR
+# NON-INFRINGEMENT WITH REGARD TO THE TEST SUITE AND ANY
+# CONTRIBUTION THERETO.
+#
+# IN NO EVENT WILL ANY AUTHOR OR DEVELOPER OF THIS MATERIAL OR
+# ANY CONTRIBUTION THERETO BE LIABLE TO ANY OTHER PARTY FOR
+# THE COST OF PROCURING SUBSTITUTE GOODS OR SERVICES, LOST
+# PROFITS, LOSS OF USE, LOSS OF DATA, OR ANY INCIDENTAL,
+# CONSEQUENTIAL, DIRECT, INDIRECT, OR SPECIAL DAMAGES WHETHER
+# UNDER CONTRACT, TORT, WARRANTY, OR OTHERWISE, ARISING IN ANY
+# WAY OUT OF THIS OR ANY OTHER AGREEMENT RELATING TO THIS
+# DOCUMENT, WHETHER OR NOT SUCH PARTY HAD ADVANCE NOTICE OF
+# THE POSSIBILITY OF SUCH DAMAGES.
+#
+# Copyright 2016 ARM, Inc. All
+# Rights Reserved, subject to all existing rights in all
+# matters included within this Test Suite, to which ARM, Inc.
+# makes no claim of right.
+#
+# Copyright (c) 2016 ARM Ltd. All rights reserved.<BR>
+#
+TOPDIR=`pwd`
+
+METALUV="$TOPDIR/meta-luv \\\\"
+METAOE="$TOPDIR/meta-oe \\\\"
+BB_CONF="conf/bblayers.conf"
+LOCAL_CONF="conf/local.conf"
+MACHINE="\"qemuarm64\""
+LUV="\"luv\""
+NUM_THREADS="BB_NUMBER_THREADS ?= \"16\""
+OUTPUT_FILE="$PWD/build/tmp/deploy/images/qemuarm64/luv-live-image-gpt.img"
+
+echo "Building LuvOS Image with SBBR and SBSA for AARCH4 ..."
+echo "UEFI-SCT source is available only to members of UEFI Forum."
+echo "To continue without building UEFI-SCT "
+read -p "Enter [yes(default)/no]: " SCTOPTIONAL
+SCTOPTIONAL=${SCTOPTIONAL:-yes}
+export SCTOPTIONAL
+if [ "$SCTOPTIONAL" = "no" ]
+then
+	echo -n User:
+	read SCTUSERNAME
+	echo -n Password:
+	read -s SCTPASSWORD
+	export SCTUSERNAME
+	export SCTPASSWORD
+else
+	echo "Continue without building UEFI-SCT..."
+fi
+echo ""
+echo "Default kernel command line parameters: 'systemd.log_target=null plymouth.ignore-serial-consoles debug ip=dhcp log_buf_len=1M efi=debug acpi=on crashkernel=256M earlycon uefi_debug'"
+echo -n "Append parameters (press Enter for default):"
+read ACS_CMDLINE_APPEND
+export ACS_CMDLINE_APPEND
+./sbsa_setup.sh
+rm -rf build
+source oe-init-build-env
+export BB_ENV_EXTRAWHITE="BB_ENV_EXTRAWHITE SCTOPTIONAL SCTUSERNAME SCTPASSWORD ACS_CMDLINE_APPEND"
+
+# include meta-luv  for building
+line=`grep -n "meta-yocto-bsp" $BB_CONF | cut -d : -f 1`
+sed -i "$line a $(echo "  $METALUV")" $BB_CONF
+sed -i "$line a $(echo "  $METAOE")" $BB_CONF
+
+# modify local.conf to edit Machine Type, Distro and Number of Threads
+sed -i -e "s/\(MACHINE ??= \).*/\1$MACHINE/" $LOCAL_CONF
+sed -i -e "s/\(DISTRO ?= \).*/\1$LUV/" $LOCAL_CONF
+sed -i -e "\$aEXTRA_IMAGE_FEATURES += \"dev-pkgs\"" $LOCAL_CONF
+echo >> $LOCAL_CONF
+echo "$NUM_THREADS" >> $LOCAL_CONF
+
+if [ "$SCTOPTIONAL" = "no" ]
+then
+	bitbake -c cleanall sbbr
+fi
+bitbake -c cleanall sbsa
+bitbake -c cleanall luv-live-image
+if [ "$SCTOPTIONAL" = "no" ]
+then
+	bitbake sbbr
+fi
+bitbake sbsa
+bitbake luv-live-image
+unset BB_ENV_EXTRAWHITE
+unset SCTOPTIONAL
+unset SCTPASSWORD
+unset SCTUSERNAME
+unset ACS_CMDLINE_APPEND
+echo "Built image can be found at $OUTPUT_FILE"
+exit
diff --git a/meta-luv/classes/luv-efi.bbclass b/meta-luv/classes/luv-efi.bbclass
index d23c33d..7c44a2a 100644
--- a/meta-luv/classes/luv-efi.bbclass
+++ b/meta-luv/classes/luv-efi.bbclass
@@ -16,6 +16,13 @@ def get_bits_depends(bb, d):
                  return ""
 _BITSDEPENDS = "${@get_bits_depends(bb, d)}"
 
+def get_sbbr_depends(bb, d):
+         import re
+         deps = bb.data.getVar('TARGET_PREFIX', d, True)
+         if re.search("aarch64",deps):
+                 return "sbbr:do_deploy"
+_SBBRDEPENDS = "${@get_sbbr_depends(bb, d)}"
+
 # The x86 build is depends on grub-efi and AArch64 build depends on grub_git
 def get_grub_depends(bb, d):
          import re
@@ -57,8 +64,15 @@ efi_populate() {
 
     # Install grub2 in EFI directory
     if [ "${TARGET_ARCH}" = "aarch64" ]; then
-		install -m 0644 ${DEPLOY_DIR_IMAGE}/bootaa64.efi ${DEST}${EFIDIR}
-                echo "bootaa64.efi" > ${DEST}${EFIDIR}/startup.nsh
+            if [ "${SCTOPTIONAL}" = "no" ]; then
+                echo "Including UEFI-SCT"
+                efi_populate_sbbr ${DEST}
+            else
+                efi_populate_startup ${DEST}
+            fi
+            echo "SCTOPTIONAL=${SCTOPTIONAL}"
+            efi_populate_sbsa ${DEST}
+            install -m 0644 ${DEPLOY_DIR_IMAGE}/bootaa64.efi ${DEST}${EFIDIR}
 
     # TODO: need conditional signing; e.g., if (DISTRO_FEATURES contains secure_boot)
     # shim bootloader does not seem to work with i386. Thus we don't use it for 32-bit
@@ -82,7 +96,7 @@ efi_populate() {
                 mv ${DEPLOY_DIR_IMAGE}/${EFI_LOADER_IMAGE} ${DEPLOY_DIR_IMAGE}/shim.efi
                 mv ${DEPLOY_DIR_IMAGE}/${EFI_LOADER_IMAGE}-unsigned ${DEPLOY_DIR_IMAGE}/${EFI_LOADER_IMAGE}
     else
-		install -m 0644 ${DEPLOY_DIR_IMAGE}/${EFI_LOADER_IMAGE} ${DEST}${EFIDIR}
+                install -m 0644 ${DEPLOY_DIR_IMAGE}/${EFI_LOADER_IMAGE} ${DEST}${EFIDIR}
     fi
 
     if echo "${TARGET_ARCH}" | grep -q "i.86" || [ "${TARGET_ARCH}" = "x86_64" ]; then
@@ -98,6 +112,55 @@ efi_populate() {
     install -m 0644 ${LUV_CFG} ${DEST}
 }
 
+efi_populate_sbbr() {
+    DEST=$1
+    cp -r ${DEPLOY_DIR_IMAGE}/sbbr ${DEST}${EFIDIR}/sbbr
+    echo "echo -off
+          for %i in 0 1 2 3 4 5 6 7 8 9 A B C D E F
+            if exist FS%i:\SCT\Overall\Summary.log then
+              bootaa64.efi
+              goto Done
+            endif
+          endfor
+          :Done" > ${DEST}${EFIDIR}/startup.nsh
+}
+
+efi_populate_sbsa() {
+    DEST=$1
+    cp -r ${DEPLOY_DIR_IMAGE}/sbsa ${DEST}${EFIDIR}/sbsa
+    cp ${DEST}${EFIDIR}/sbsa/Shell.efi ${DEST}${EFIDIR}/Shell.efi
+    echo "echo -off
+          if not exist sbsa_results then
+            mkdir sbsa_results
+          endif
+          cd sbsa_results
+          if not exist uefi then
+            mkdir uefi
+          endif
+          cd uefi
+          for %i in 0 1 2 3 4 5 6 7 8 9 A B C D E F then
+            if exist FS%i:\EFI\BOOT\sbsa\Sbsa.efi then
+              FS%i:\EFI\BOOT\sbsa\Sbsa.efi -f SbsaResults.log
+              goto Done
+            endif
+          endfor
+          :Done" > ${DEST}${EFIDIR}/sbsa/sbsa.nsh
+}
+
+efi_populate_startup() {
+    DEST=$1
+    echo "echo -off
+           for %i in 0 1 2 3 4 5 6 7 8 9 A B C D E F then
+            if exist FS%i:\EFI\BOOT\sbsa\Sbsa.efi then
+              FS%i:\EFI\BOOT\sbsa\Sbsa.efi
+              goto Done
+            endif
+          endfor
+          :Done
+          FS%i:
+          vmlinuz initrd=\initrd ${CMDLINE}" > ${DEST}${EFIDIR}/startup.nsh
+}
+
 efi_populate_bits() {
     DEST=$1
     # TODO: weird behavior here. When building luv-live-image,
@@ -177,6 +240,11 @@ python build_efi_cfg() {
        cfgfile.write('timeout=0\n')
        cfgfile.write('fallback=0\n')
 
+    if re.search("aarch64", target):
+       cfgfile.write('default=sbbr/sbsa\n')
+       cfgfile.write('timeout=10\n')
+       cfgfile.write('fallback=0\n')
+
     cfgfile.write('menuentry \'luv\' {\n')
     cfgfile.write('linux /vmlinuz ')
 
@@ -203,6 +271,11 @@ python build_efi_cfg() {
        cfgfile.write('chainloader /EFI/BOOT/bits/%s\n' % loader)
        cfgfile.write('}\n')
 
+    if re.search("aarch64", target):
+       cfgfile.write('menuentry \'sbbr/sbsa\' {\n')
+       cfgfile.write('chainloader /EFI/BOOT/Shell.efi\n')
+       cfgfile.write('}\n')
+
     cfgfile.close()
 }
 
diff --git a/meta-luv/conf/distro/luv.conf b/meta-luv/conf/distro/luv.conf
index 1676a0e..a36d97c 100644
--- a/meta-luv/conf/distro/luv.conf
+++ b/meta-luv/conf/distro/luv.conf
@@ -17,4 +17,4 @@ VIRTUAL-RUNTIME_init_manager = "systemd"
 VIRTUAL-RUNTIME_initscripts = ""
 DISTRO_FEATURES_BACKFILL_CONSIDERED += "sysvinit"
 
-INITRAMFS_MAXSIZE = "200000"
+INITRAMFS_MAXSIZE = "400000"
diff --git a/meta-luv/recipes-bsp/sbbr/sbbr/README.md b/meta-luv/recipes-bsp/sbbr/sbbr/README.md
new file mode 100644
index 0000000..06f0264
--- /dev/null
+++ b/meta-luv/recipes-bsp/sbbr/sbbr/README.md
@@ -0,0 +1,2 @@
+UEFI-SCT
+========
diff --git a/meta-luv/recipes-bsp/sbbr/sbbr_v1.0.bb b/meta-luv/recipes-bsp/sbbr/sbbr_v1.0.bb
new file mode 100644
index 0000000..675aa55
--- /dev/null
+++ b/meta-luv/recipes-bsp/sbbr/sbbr_v1.0.bb
@@ -0,0 +1,97 @@
+# Recipe created by recipetool
+# This is the basis of a recipe and may need further editing in order to be fully functional.
+# (Feel free to remove these comments when editing.)
+#
+# Unable to find any files that looked like license statements. Check the accompanying
+# documentation and source headers and set LICENSE and LIC_FILES_CHKSUM accordingly.
+#
+# NOTE: LICENSE is being set to "CLOSED" to allow you to at least start building - if
+# this is not accurate with respect to the licensing of the software being built (it
+# will not be in most cases) you must specify the correct value before using this
+# recipe for anything other than initial testing/development!
+SUMMARY = "SBBR is a test suite that runs Server Base Boot Requirements UEFI tests."
+
+DESCRIPTION = "This Server Base Boot Requirements (SBBR) test suite is intended \
+for SBSA[2]-compliant 64-bit ARMv8 servers. It defines the base firmware requirements \
+for out-of-box support of any ARM SBSA-compatible Operating System or hypervisor. \
+The tests are expected to be minimal yet complete for booting a multi-core \
+ARMv8 server platform, while leaving plenty of room \
+for OEM or ODM innovations and design details."
+
+# Home Page
+HOMEPAGE = "https://github.com/UEFI/UEFI-SCT"
+
+LICENSE = "CLOSED"
+LIC_FILES_CHKSUM = ""
+
+SBBRVERSION="v1.0"
+PV="${SBBRVERSION}+git${SRCPV}"
+
+S = "${WORKDIR}/git"
+
+inherit deploy
+
+# No information for SRC_URI yet (only an external source tree was specified)
+SRCREV  = "d38be6dae3e7f67bdf52595288906d6832e0d893"
+SRC_URI = "git://github.com/UEFI/UEFI-SCT.git;protocol=https;branch=sbbr;user="${SCTUSERNAME}":"${SCTPASSWORD}" \
+          "
+
+# NOTE: no Makefile found, unable to determine what needs to be done
+
+do_configure () {
+	# Specify any needed configure commands here
+	:
+	echo "do_configure()"
+	# Specify any needed configure commands here
+	rm -rf edk2
+	git clone https://github.com/tianocore/edk2
+	cd edk2
+	git checkout c0584d0bdd4463551db8f8c62a5e2936ec97b407
+	ln -s ../SctPkg SctPkg
+	chmod +x SctPkg/build_sbbr.sh
+	cd ..
+
+	mkdir -p "tools/gcc"
+	cd "tools/gcc"
+	wget -nv "https://releases.linaro.org/components/toolchain/binaries/4.9-2016.02/aarch64-linux-gnu/gcc-linaro-4.9-2016.02-x86_64_aarch64-linux-gnu.tar.xz"
+	#Untar the GCC Linaro files.
+	tar -xf gcc-linaro-4.9-2016.02-x86_64_aarch64-linux-gnu.tar.xz
+	cd ../..
+}
+
+do_compile () {
+	# Specify compilation commands here
+	:
+	echo "$PWD: do_compile()"
+	export PATH=$PATH:"$PWD/tools/gcc/gcc-linaro-4.9-2016.02-x86_64_aarch64-linux-gnu/bin"
+	export BB_ENV_EXTRAWHITE="$BB_ENV_EXTRAWHITE PATH"
+	echo "New PATH = $PATH"
+	export CROSS_COMPILE="$PWD/tools/gcc/gcc-linaro-4.9-2016.02-x86_64_aarch64-linux-gnu/bin/aarch64-linux-gnu-"
+	export BB_ENV_EXTRAWHITE="$BB_ENV_EXTRAWHITE CROSS_COMPILE"
+	echo "NEW CROSS_COMPILE: $CROSS_COMPILE"
+
+	cd edk2
+	./SctPkg/build_sbbr.sh AARCH64 GCC
+	cd ..
+}
+
+do_install () {
+	# Specify install commands here
+	:
+	echo "do_install()"
+	echo "Destination Directory: ${D}"
+	echo "Source Directory: ${B}"
+	cp -r ${B}/edk2/Build/SbbrSct/DEBUG_GCC49/SctPackageAARCH64 ${D}/sbbr
+}
+
+do_deploy () {
+	# Specify deploy commands here
+	:
+	echo "do_deploy()"
+	echo "Destination Directory: ${DEPLOYDIR}"
+	echo "Source Directory: ${D}"
+	install -d ${DEPLOYDIR}
+	cp -r ${D}/sbbr ${DEPLOYDIR}/sbbr
+}
+
+addtask deploy before do_build after do_install
diff --git a/meta-luv/recipes-bsp/sbsa/files/compile.sh b/meta-luv/recipes-bsp/sbsa/files/compile.sh
new file mode 100755
index 0000000..a47251a
--- /dev/null
+++ b/meta-luv/recipes-bsp/sbsa/files/compile.sh
@@ -0,0 +1,16 @@
+#!/usr/bin/env bash
+
+
+cd ${1}/edk2
+
+export GCC49_AARCH64_PREFIX=${1}/gcc-linaro-5.3.1-2016.05-x86_64_aarch64-linux-gnu/bin/aarch64-linux-gnu-
+
+echo "do_compile: Initializing EDK2 for building."
+set --
+source edksetup.sh
+
+echo "do_compile: Building BaseTools."
+make -C BaseTools/Source/C
+
+echo "do_compile: Building SBSA."
+source AppPkg/Applications/sbsa-acs/tools/scripts/avsbuild.sh
diff --git a/meta-luv/recipes-bsp/sbsa/sbsa.bb b/meta-luv/recipes-bsp/sbsa/sbsa.bb
new file mode 100644
index 0000000..ae3dc51
--- /dev/null
+++ b/meta-luv/recipes-bsp/sbsa/sbsa.bb
@@ -0,0 +1,104 @@
+# Recipe created by recipetool
+# This is the basis of a recipe and may need further editing in order to be fully functional.
+# (Feel free to remove these comments when editing.)
+#
+# Unable to find any files that looked like license statements. Check the accompanying
+# documentation and source headers and set LICENSE and LIC_FILES_CHKSUM accordingly.
+#
+# NOTE: LICENSE is being set to "CLOSED" to allow you to at least start building - if
+# this is not accurate with respect to the licensing of the software being built (it
+# will not be in most cases) you must specify the correct value before using this
+# recipe for anything other than initial testing/development!
+LICENSE = "CLOSED"
+LIC_FILES_CHKSUM = ""
+
+# SCT files placed in ${WORKDIR}/git
+# GCC files placed in ${WORKDIR}/gcc-linaro-5.3.1-2016.05-x86_64_aarch64-linux-gnu
+SRC_URI = "git://github.com/ARM-software/sbsa-acs.git;protocol=https; \
+           https://releases.linaro.org/components/toolchain/binaries/5.3-2016.05/aarch64-linux-gnu/gcc-linaro-5.3.1-2016.05-x86_64_aarch64-linux-gnu.tar.xz \
+           file://compile.sh"
+
+PV = "1.0+git${SRCPV}"
+SRCREV = "${AUTOREV}"
+
+# GCC checksum.
+SRC_URI[md5sum] = "24ac2e26f50f49f3043f281440b41bba"
+
+S = "${WORKDIR}/git"
+
+inherit deploy
+
+do_configure () {
+    # Downloading EDK2 into ${WORKDIR}/edk2.
+    echo "do_configure: Checking if EDK2 repository already exists."
+    cd ${WORKDIR}
+    if [ ! -d ${WORKDIR}/edk2 ]
+    then
+        echo "do_configure: Cloning EDK2 repository."
+        git clone https://github.com/tianocore/edk2.git
+    fi
+
+    # Linking SBSA and EDK2.
+    echo "do_configure: Linking SBSA to EDK2."
+    cd ${WORKDIR}/git/uefi_app
+    if [ -d val ]
+    then
+        echo "do_configure: Existing val found, deleted."
+        rm val
+    fi
+    if [ -d pal ]
+    then
+        echo "do_configure: Existing pal found, deleted."
+        rm pal
+    fi
+    if [ -d test_pool ]
+    then
+        echo "do_configure: Existing test_pool found, deleted."
+        rm test_pool
+    fi
+    cd ${WORKDIR}/edk2/AppPkg/Applications
+    if [ -d sbsa-acs ]
+    then
+        echo "do_configure: Existing sbsa-acs found, deleted."
+        rm sbsa-acs
+    fi
+    cd ${WORKDIR}/git
+    set -- "${WORKDIR}/git" "${WORKDIR}/edk2"
+    . ${WORKDIR}/git/tools/scripts/avssetup.sh
+    set --
+
+    # Modifying EDK2 to build SBSA.
+    echo "do_configure: Modifying edk2/ShellPkg/ShellPkg.dsc to build SBSA."
+    if ! grep -q SbsaPalLib "${WORKDIR}/edk2/ShellPkg/ShellPkg.dsc"
+    then
+        sed -i '/LibraryClasses.common/ a \ \ SbsaPalLib|AppPkg/Applications/sbsa-acs/platform/pal_uefi/SbsaPalLib.inf' ${WORKDIR}/edk2/ShellPkg/ShellPkg.dsc
+    fi
+    if ! grep -q SbsaValLib "${WORKDIR}/edk2/ShellPkg/ShellPkg.dsc"
+    then
+        sed -i '/LibraryClasses.common/ a \ \ SbsaValLib|AppPkg/Applications/sbsa-acs/val/SbsaValLib.inf' ${WORKDIR}/edk2/ShellPkg/ShellPkg.dsc
+    fi
+    if ! grep -q SbsaAvs "${WORKDIR}/edk2/ShellPkg/ShellPkg.dsc"
+    then
+        sed -i '/Components/ a \ \ AppPkg/Applications/sbsa-acs/uefi_app/SbsaAvs.inf' ${WORKDIR}/edk2/ShellPkg/ShellPkg.dsc
+    fi
+}
+
+do_compile () {
+    cd ${WORKDIR}
+    ./compile.sh ${WORKDIR}
+}
+
+do_install () {
+    echo "do_install: Copying SBSA files to destination ${D}"
+    mkdir ${D}/sbsa
+	cp ${WORKDIR}/edk2/Build/Shell/DEBUG_GCC49/AARCH64/Sbsa.efi ${D}/sbsa/Sbsa.efi
+	cp ${WORKDIR}/edk2/ShellBinPkg/UefiShell/AArch64/Shell.efi ${D}/sbsa/Shell.efi
+}
+
+do_deploy () {
+    echo "do_deploy: Deploying SBSA files to destionation ${DEPLOYDIR}"
+    install -d ${DEPLOYDIR}
+    cp -r ${D}/sbsa ${DEPLOYDIR}/sbsa
+}
+
+addtask deploy before do_build after do_install
diff --git a/meta-luv/recipes-core/efivarfs/efivarfs-test.bb b/meta-luv/recipes-core/efivarfs/efivarfs-test.bb
index 07760b2..c3eec9a 100644
--- a/meta-luv/recipes-core/efivarfs/efivarfs-test.bb
+++ b/meta-luv/recipes-core/efivarfs/efivarfs-test.bb
@@ -72,4 +72,3 @@ do_install() {
 }
 
 LUV_TEST_LOG_PARSER="luv-parser-efivarfs"
-LUV_TEST="efivarfs"
diff --git a/meta-luv/recipes-core/fwts/fwts/sbbr.patch b/meta-luv/recipes-core/fwts/fwts/sbbr.patch
new file mode 100644
index 0000000..07cb085
--- /dev/null
+++ b/meta-luv/recipes-core/fwts/fwts/sbbr.patch
@@ -0,0 +1,11950 @@
+diff --git a/src/Makefile.am b/src/Makefile.am
+index c1eb285..10b7544 100644
+--- a/src/Makefile.am
++++ b/src/Makefile.am
+@@ -150,6 +150,16 @@ fwts_SOURCES = main.c 				\
+ 	pci/aspm/aspm.c 			\
+ 	pci/crs/crs.c 				\
+ 	pci/maxreadreq/maxreadreq.c 		\
++	sbbr/acpitables/acpitables.c 		\
++	sbbr/dbg2/dbg2.c			\
++	sbbr/dmicheck/dmicheck.c 		\
++	sbbr/fadt/fadt.c 			\
++	sbbr/gtdt/gtdt.c 			\
++	sbbr/madt/madt.c 			\
++	sbbr/method/method.c 			\
++	sbbr/rsdp/rsdp.c 			\
++	sbbr/spcr/spcr.c 			\
++	sbbr/xsdt/xsdt.c 			\
+ 	uefi/csm/csm.c 				\
+ 	uefi/uefidump/uefidump.c 		\
+ 	uefi/uefirttime/uefirttime.c		\
+diff --git a/src/lib/include/fwts.h b/src/lib/include/fwts.h
+index a56ce24..37a6529 100644
+--- a/src/lib/include/fwts.h
++++ b/src/lib/include/fwts.h
+@@ -33,6 +33,7 @@
+ #define FWTS_ARCH_AARCH64	1
+ #define FWTS_HAS_ACPI	1
+ #define FWTS_HAS_UEFI	1
++#define FWTS_HAS_SBBR	1
+ #endif
+ 
+ #if defined(__s390x__)
+diff --git a/src/sbbr/acpitables/acpitables.c b/src/sbbr/acpitables/acpitables.c
+new file mode 100644
+index 0000000..cfa4c09
+--- /dev/null
++++ b/src/sbbr/acpitables/acpitables.c
+@@ -0,0 +1,328 @@
++/*
++ * Copyright (C) 2010-2017 Canonical
++ * Copyright (C) 2017      ARM Ltd
++ *
++ * This program is free software; you can redistribute it and/or
++ * modify it under the terms of the GNU General Public License
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
++ *
++ */
++#include "fwts.h"
++
++#if defined(FWTS_HAS_SBBR)
++#include "acpi.h"
++#include "accommon.h"
++#include "acnamesp.h"
++#include "actables.h"
++
++#include <stdio.h>
++#include <stdlib.h>
++#include <sys/types.h>
++#include <sys/stat.h>
++#include <fcntl.h>
++#include <dirent.h>
++#include <ctype.h>
++#include <unistd.h>
++#include <inttypes.h>
++
++#define TABLE_NAME_LEN (16)
++#define MIN_SIG        ( 4)
++#define OEM_ID         ( 6)
++#define OEM_TABLE_ID   ( 8)
++#define OEM_CREATOR_ID ( 4)
++
++static bool acpi_table_check_field(const char *field, const size_t len)
++{
++	size_t i;
++
++	for (i = 0; i < len; i++)
++		if (!isascii(field[i]))
++			return false;
++
++	return true;
++}
++
++static bool acpi_table_check_field_test(
++	fwts_framework *fw,
++	const char *table_name,
++	const char *field_name,
++	const char *field,
++	const size_t len)
++{
++	if (!acpi_table_check_field(field, len)) {
++		fwts_failed(fw, LOG_LEVEL_LOW, "ACPITableHdrInfo",
++			"ACPI Table %s has non-ASCII characters in "
++			"header field %s\n", table_name, field_name);
++		return false;
++	}
++	return true;
++}
++
++static int sbbr_acpi_table_check_test1(fwts_framework *fw)
++{
++	int i;
++	bool checked = false;
++
++	for (i = 0; ; i++) {
++		fwts_acpi_table_info *info;
++		fwts_acpi_table_header *hdr;
++		char name[50];
++		bool passed;
++
++		if (fwts_acpi_get_table(fw, i, &info) != FWTS_OK)
++			break;
++		if (info == NULL)
++			continue;
++
++		checked = true;
++		/* RSDP and FACS are special cases, skip these */
++		if (!strcmp(info->name, "RSDP") ||
++		    !strcmp(info->name, "FACS"))
++			continue;
++
++		hdr = (fwts_acpi_table_header *)info->data;
++		if (acpi_table_check_field(hdr->signature, 4)) {
++			snprintf(name, sizeof(name), "%4.4s", hdr->signature);
++		} else {
++			/* Table name not printable, so identify it by the address */
++			snprintf(name, sizeof(name), "at address 0x%" PRIx64, info->addr);
++		}
++
++		/*
++		 * Tables shouldn't be short, however, they do have at
++		 * least 4 bytes with their signature else they would not
++		 * have been loaded by this stage.
++		 */
++		if (hdr->length < sizeof(fwts_acpi_table_header)) {
++			fwts_failed(fw, LOG_LEVEL_HIGH, "ACPITableHdrShort",
++				"ACPI Table %s is too short, only %d bytes long. Further "
++				"header checks will be omitted.", name, hdr->length);
++			continue;
++		}
++		/* Warn about empty tables */
++		if (hdr->length == sizeof(fwts_acpi_table_header)) {
++			fwts_warning(fw,
++				"ACPI Table %s is empty and just contains a table header. Further "
++				"header checks will be omitted.", name);
++			continue;
++		}
++
++		passed = acpi_table_check_field_test(fw, name, "Signature", hdr->signature, MIN_SIG) &
++			 acpi_table_check_field_test(fw, name, "OEM ID", hdr->oem_id, OEM_ID) &
++			 acpi_table_check_field_test(fw, name, "OEM Table ID", hdr->oem_tbl_id, OEM_TABLE_ID) &
++			acpi_table_check_field_test(fw, name, "OEM Creator ID", hdr->creator_id, OEM_CREATOR_ID);
++		if (passed)
++			fwts_passed(fw, "Table %s has valid signature and ID strings.", name);
++
++	}
++	if (!checked)
++		fwts_aborted(fw, "Cannot find any ACPI tables.");
++
++	return FWTS_OK;
++}
++
++/* Callback function used when searching for processor devices in namespace. */
++static ACPI_STATUS processor_handler(ACPI_HANDLE ObjHandle, uint32_t level, void *context,
++                              void **returnvalue)
++{
++	ACPI_NAMESPACE_NODE *node = (ACPI_NAMESPACE_NODE *)ObjHandle;
++	ACPI_NAMESPACE_NODE *parent = node->Parent;
++	int error_count;
++
++	/* Unused parameters trigger errors. */
++	FWTS_UNUSED(level);
++	FWTS_UNUSED(context);
++
++	/* If the processor device is not located under _SB_, increment the error_count. */
++	if (strncmp(parent->Name.Ascii, "_SB_", sizeof(int32_t)) != 0) {
++		error_count = *((int *)returnvalue);
++		error_count++;
++		*((int *)returnvalue) = error_count;
++	}
++
++	/* Return 0 so namespace search continues. */
++	return 0;
++}
++
++/* Test function that makes sure processors are under the _SB_ namespace. */
++static int sbbr_acpi_namespace_check_test2(fwts_framework *fw)
++{
++	int error_count = 0;
++
++	/* Initializing ACPICA library so we can call AcpiWalkNamespace. */
++	if (fwts_acpica_init(fw) != FWTS_OK)
++		return FWTS_ERROR;
++
++	/* Searching for all processor devices in the namespace. */
++	AcpiWalkNamespace(ACPI_TYPE_PROCESSOR, ACPI_ROOT_OBJECT, ACPI_UINT32_MAX,
++	                  processor_handler, NULL, NULL, (void **)&error_count);
++
++	/* Deinitializing ACPICA, if we don't call this the terminal will break on exit. */
++	fwts_acpica_deinit();
++
++	/* error_count variable counts the number of processors outside of the _SB_ namespace. */
++	if (error_count > 0)
++		fwts_failed(fw, LOG_LEVEL_HIGH, "SbbrAcpiCpuWrongNamespace", "%d Processor devices "
++		            "were found outside of the _SB_ namespace.", error_count);
++	else
++		fwts_passed(fw, "All processor devices were located in the _SB_ namespace.");
++
++	return FWTS_OK;
++}
++
++static int sbbr_acpi_table_check_test3(fwts_framework *fw)
++{
++	int i;
++	bool checked = false;
++	bool dsdt_checked = false;
++	bool ssdt_checked = false;
++
++	for (i = 0; ; i++) {
++		fwts_acpi_table_info *info;
++		fwts_acpi_table_header *hdr;
++		char name[TABLE_NAME_LEN];
++		bool passed = false;
++
++		if (fwts_acpi_get_table(fw, i, &info) != FWTS_OK)
++			break;
++		if (info == NULL)
++			continue;
++
++		checked = true;
++		if (!strcmp(info->name, "DSDT") ||
++			!strcmp(info->name, "SSDT")) {
++			if (!strcmp(info->name, "DSDT")) {
++				dsdt_checked = true;
++			}
++			if (!strcmp(info->name, "SSDT")) {
++				ssdt_checked = true;
++			}
++			hdr = (fwts_acpi_table_header *)info->data;
++			if (acpi_table_check_field(hdr->signature, MIN_SIG)) {
++				snprintf(name, sizeof(name), "%4.4s", hdr->signature);
++			} else {
++				/* Table name not printable, so identify it by the address */
++				snprintf(name, sizeof(name), "at address 0x%" PRIx64, info->addr);
++			}
++
++			/*
++			 * Tables shouldn't be short, however, they do have at
++			 * least 4 bytes with their signature else they would not
++			 * have been loaded by this stage.
++			 */
++			if (hdr->length < sizeof(fwts_acpi_table_header)) {
++				fwts_failed(fw, LOG_LEVEL_HIGH, "ACPITableHdrShort",
++					"ACPI Table %s is too short, only %d bytes long. Further "
++					"header checks will be omitted.", name, hdr->length);
++				continue;
++			}
++			/* Warn about empty tables */
++			if (hdr->length == sizeof(fwts_acpi_table_header)) {
++				fwts_warning(fw,
++					"ACPI Table %s is empty and just contains a table header. Further "
++					"header checks will be omitted.", name);
++				continue;
++			}
++
++			passed = acpi_table_check_field_test(fw, name, "Signature", hdr->signature, MIN_SIG) &
++			    acpi_table_check_field_test(fw, name, "OEM ID", hdr->oem_id, OEM_ID) &
++			    acpi_table_check_field_test(fw, name, "OEM Table ID", hdr->oem_tbl_id, OEM_TABLE_ID) &
++			    acpi_table_check_field_test(fw, name, "OEM Creator ID", hdr->creator_id, OEM_CREATOR_ID);
++			if (passed)
++				fwts_passed(fw, "Table %s has valid signature and ID strings.", name);
++		}
++	}
++	if (!checked)
++		fwts_aborted(fw, "Cannot find any ACPI tables.");
++	if (!dsdt_checked) {
++		fwts_failed(fw, LOG_LEVEL_HIGH, "acpi_table_check_test4",
++				"Test DSDT table is NOT implemented.");
++	}
++	if (!ssdt_checked) {
++		fwts_failed(fw, LOG_LEVEL_HIGH, "acpi_table_check_test4",
++				"Test SSDT table is NOT implemented.");
++	}
++	if ((!dsdt_checked) || (!ssdt_checked))
++	  return FWTS_ERROR;
++
++	return FWTS_OK;
++}
++
++/* List of ACPI tables recommended by SBBR 4.2.2 */
++char *recommended_acpi_tables[] = {
++	"MCFG",
++	"IORT",
++	"BERT",
++	"EINJ",
++	"ERST",
++	"HEST",
++	"RASF",
++	"SPMI",
++	"SLIT",
++	"SRAT",
++	"CSRT",
++	"ECDT",
++	"MPST",
++	"PCCT",
++	NULL
++};
++
++/* Searches ACPI tables by signature. */
++fwts_acpi_table_info *sbbr_search_acpi_tables(fwts_framework *fw, char *signature)
++{
++	uint32_t i;
++	fwts_acpi_table_info *info;
++
++	i = 0;
++	while (fwts_acpi_get_table(fw, i, &info) == FWTS_OK) {
++		if (info != NULL && strncmp(info->name, signature, sizeof(uint32_t)) == 0) {
++			return info;
++		}
++		i++;
++	}
++
++	return NULL;
++}
++
++static int sbbr_acpi_table_check_test4(fwts_framework *fw)
++{
++	uint32_t i;
++	fwts_acpi_table_info *info;
++
++	for (i = 0; recommended_acpi_tables[i] != NULL; i++) {
++		info = sbbr_search_acpi_tables(fw, recommended_acpi_tables[i]);
++		if (info == NULL) {
++			fwts_failed(fw, LOG_LEVEL_HIGH, "SbbrAcpiRecommendedTableNotFound",
++			            "SBBR Recommended ACPI table \"%s\" not found.",
++			            recommended_acpi_tables[i]);
++		} else {
++			fwts_passed(fw, "SBBR Recommended ACPI table \"%s\" found.",
++			            recommended_acpi_tables[i]);
++		}
++	}
++	return FWTS_OK;
++}
++
++static fwts_framework_minor_test sbbr_acpi_table_check_tests[] = {
++	{ sbbr_acpi_table_check_test1, "Test ACPI headers." },
++	{ sbbr_acpi_namespace_check_test2, "Test that processors only exist in the _SB namespace." },
++	{ sbbr_acpi_table_check_test3, "Test DSDT and SSDT tables are implemented." },
++	{ sbbr_acpi_table_check_test4, "Check for recommended ACPI tables." },
++	{ NULL, NULL }
++};
++
++static fwts_framework_ops sbbr_acpi_table_check_ops = {
++	.description = "ACPI table headers sanity tests.",
++	.minor_tests = sbbr_acpi_table_check_tests
++};
++
++FWTS_REGISTER("sbbr_acpi", &sbbr_acpi_table_check_ops, FWTS_TEST_ANYTIME, FWTS_FLAG_TEST_SBBR)
++
++#endif
+diff --git a/src/sbbr/dbg2/dbg2.c b/src/sbbr/dbg2/dbg2.c
+new file mode 100644
+index 0000000..3056791
+--- /dev/null
++++ b/src/sbbr/dbg2/dbg2.c
+@@ -0,0 +1,388 @@
++/*
++ * Copyright (C) 2015-2017 Canonical
++ * Copyright (C) 2017 ARM Ltd
++ *
++ * Portions of this code original from the Linux-ready Firmware Developer Kit
++ *
++ * This program is free software; you can redistribute it and/or
++ * modify it under the terms of the GNU General Public License
++ * as published by the Free Software Foundation; either version 2
++ * of the License, or (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
++ *
++ */
++#include "fwts.h"
++
++#if defined(FWTS_HAS_SBBR)
++
++#include <stdlib.h>
++#include <stdio.h>
++#include <unistd.h>
++#include <inttypes.h>
++#include <string.h>
++
++#include "fwts_acpi_object_eval.h"
++
++static fwts_acpi_table_info *table;
++
++static int sbbr_dbg2_init(fwts_framework *fw)
++{
++	if (fwts_acpi_find_table(fw, "DBG2", 0, &table) != FWTS_OK) {
++		fwts_log_error(fw, "Cannot read ACPI tables.");
++		return FWTS_ERROR;
++	}
++	if (table == NULL || (table && table->length == 0)) {
++		fwts_log_error(fw, "ACPI DBG2 table does not exist");
++		return FWTS_ERROR;
++	}
++
++	return FWTS_OK;
++}
++
++static int sbbr_dbg2_sbsa_uart_test(fwts_framework *fw)
++{
++	uint32_t i;
++
++	fwts_acpi_table_dbg2 *dbg2 = (fwts_acpi_table_dbg2 *)table->data;
++	fwts_acpi_table_dbg2_info *info;
++
++	const int SBBR_DBG2_PORT_SERIAL = 0x8000;
++	const int SBBR_DBG2_ARM_SBSA_UART = 0x000E;
++
++	info = (fwts_acpi_table_dbg2_info *)(table->data + dbg2->info_offset);
++
++	for (i = 0; i < dbg2->info_count; i++) {
++		if( (info->port_type    == SBBR_DBG2_PORT_SERIAL  ) &&
++			(info->port_subtype == SBBR_DBG2_ARM_SBSA_UART)    )
++		{
++			fwts_passed(fw, "DBG2 provides a standard serial debug port and describes ARM SBSA Generic UART");
++			return FWTS_OK;
++		}
++
++		/* ..and onto the next info structure .. */
++		info = (fwts_acpi_table_dbg2_info *)((uint8_t *)info + info->length);
++	}
++
++	fwts_failed(fw, LOG_LEVEL_CRITICAL, "dbg2_sbsa_uart:", "DBG2 provides a non standard debug port");
++	return FWTS_OK;
++}
++
++
++/*
++ *  dbg2_check_offset()
++ *	check if offset does not fall off end of table
++ */
++static void dbg2_check_offset(
++	fwts_framework *fw,
++	const size_t table_length,
++	const size_t offset,
++	const char *msg,
++	bool *passed)
++{
++	if (table_length < offset) {
++		fwts_failed(fw, LOG_LEVEL_HIGH,
++			"DBG2TooShort",
++			"DBG2 table too short, expecting %zu bytes, "
++			"instead got %zu bytes for a DBG2 table and %s",
++			offset, table->length, msg);
++		*passed = false;
++	}
++}
++
++/*
++ *  dbg2_check_namespace_string()
++ *	check namespace string is '\0' termimated
++ */
++static void dbg2_check_namespace_string(
++	fwts_framework *fw,
++	const char *str,
++	size_t length,
++	bool *passed)
++{
++	size_t i;
++
++	for (i = 0; i < length; i++) {
++		if (*(str + i) == '\0')
++			return;
++	}
++	fwts_failed(fw, LOG_LEVEL_HIGH,
++		"DBG2NameSpaceStringNull",
++		"DBG2 Name Space String was not null terminated");
++	*passed = false;
++}
++
++
++/*
++ *  DBG2 Table
++ *   see https://msdn.microsoft.com/en-us/library/windows/hardware/dn639131%28v=vs.85%29.aspx
++ */
++static int sbbr_dbg2_generic_test(fwts_framework *fw)
++{
++	bool passed = true;
++	fwts_acpi_table_dbg2 *dbg2 = (fwts_acpi_table_dbg2 *)table->data;
++	fwts_acpi_table_dbg2_info *info;
++	uint32_t i;
++	size_t total_size;
++
++	/* Enough length for the initial dbg2 header? */
++	if (table->length < sizeof(fwts_acpi_table_dbg2)) {
++		passed = false;
++		fwts_failed(fw, LOG_LEVEL_HIGH,
++			"DBG2TooShort",
++			"DBG2 table too short, expecting %zu bytes, "
++			"instead got %zu bytes",
++			sizeof(fwts_acpi_table_dbg2), table->length);
++		goto done;
++	}
++
++	fwts_log_info_verbatim(fw, "DBG2 Table:");
++	fwts_log_info_verbatim(fw, "  Info Offset:              0x%8.8" PRIx32, dbg2->info_offset);
++	fwts_log_info_verbatim(fw, "  Info Count:               0x%8.8" PRIx32, dbg2->info_count);
++	fwts_log_nl(fw);
++
++	total_size = dbg2->info_offset +
++		(dbg2->info_count * sizeof(fwts_acpi_table_dbg2_info));
++	if (table->length < total_size) {
++		passed = false;
++		fwts_failed(fw, LOG_LEVEL_HIGH,
++			"DBG2TooShort",
++			"DBG2 table too short, expecting %zu bytes, "
++			"instead got %zu bytes for a DBG2 table "
++			"containing %" PRIu32 " debug device "
++			"information structures",
++			sizeof(fwts_acpi_table_dbg2), table->length,
++			dbg2->info_count);
++		goto done;
++	}
++
++	info = (fwts_acpi_table_dbg2_info *)(table->data + dbg2->info_offset);
++
++	/*
++	 *  Sanity check structures
++	 */
++	for (i = 0; i < dbg2->info_count; i++) {
++		uint32_t offset = (uint8_t *)info - (uint8_t *)table->data;
++		bool ok, length_ok;
++		char *port = NULL, *subport = NULL;
++
++		switch (info->port_type) {
++		case 0x8000:
++			port = "Serial";
++			switch (info->port_subtype) {
++			case 0x0000:
++				subport = "Fully 16550-compatible";
++				break;
++			case 0x0001:
++				subport = "16550 subset compatible";
++				break;
++			case 0x0003:
++				subport = "ARMPL011 UART";
++				break;
++			case 0x000d:
++				subport = "ARM SBSA Generic UART (deprecated)";
++				break;
++			case 0x000e:
++				subport = "ARM SBSA Generic UART";
++				break;
++			case 0x000f:
++				subport = "ARM DCC";
++				break;
++			case 0x0010:
++				subport = "BCM2835";
++				break;
++			default:
++				break;
++			}
++			break;
++		case 0x8001:
++			port = "1394";
++			switch (info->port_subtype) {
++			case 0x0000:
++				subport = "IEEE1394";
++				break;
++			default:
++				break;
++			}
++			break;
++		case 0x8002:
++			port = "USB";
++			switch (info->port_subtype) {
++			case 0x0000:
++				subport = "XHCI controller";
++				break;
++			case 0x0001:
++				subport = "EHCI controller";
++				break;
++			default:
++				break;
++			}
++			break;
++		case 0x8003:
++			port = "Net";
++			subport = "PCI";
++			break;
++		default:
++			break;
++		}
++
++		fwts_log_info_verbatim(fw, "DBG2 Info Structure %" PRIu32 ":", i);
++		fwts_log_info_verbatim(fw, "  Revision:                 0x%2.2" PRIx8, info->revision);
++		fwts_log_info_verbatim(fw, "  Length:                   0x%4.4" PRIx16, info->length);
++		fwts_log_info_verbatim(fw, "  Number of Registers       0x%2.2" PRIx8, info->number_of_regs);
++		fwts_log_info_verbatim(fw, "  Namespace String Length:  0x%4.4" PRIx16, info->namespace_length);
++		fwts_log_info_verbatim(fw, "  Namespace String Offset:  0x%4.4" PRIx16, info->namespace_offset);
++		fwts_log_info_verbatim(fw, "  OEM Data Length:          0x%4.4" PRIx16, info->oem_data_length);
++		fwts_log_info_verbatim(fw, "  OEM Data Offset:          0x%4.4" PRIx16, info->oem_data_offset);
++		fwts_log_info_verbatim(fw, "  Port Type:                0x%4.4" PRIx16 " (%s)", info->port_type,
++			port ? port : "(Reserved)");
++		fwts_log_info_verbatim(fw, "  Port Subtype:             0x%4.4" PRIx16 " (%s)", info->port_subtype,
++			subport ? subport : "(Reserved)");
++		fwts_log_info_verbatim(fw, "  Reserved:                 0x%4.4" PRIx16, info->reserved);
++		fwts_log_info_verbatim(fw, "  Base Address Offset:      0x%4.4" PRIx16, info->base_address_offset);
++		fwts_log_info_verbatim(fw, "  Address Size Offset:      0x%4.4" PRIx16, info->address_size_offset);
++		fwts_log_nl(fw);
++
++		if (info->revision != 0) {
++			passed = false;
++			fwts_failed(fw, LOG_LEVEL_HIGH,
++				"DBG2NonZeroRevision",
++				"DBG2 Info Structure Revision is 0x%2.2" PRIx8
++				" and was expecting 0x00",
++				info->revision);
++		}
++		if (port == NULL) {
++			passed = false;
++			fwts_failed(fw, LOG_LEVEL_HIGH,
++				"DBG2PortTypeReserved",
++				"DBG2 Info Structure Port Type is 0x%4.4" PRIx16
++				" which is a reserved type.",
++				info->port_type);
++		}
++		if (subport == NULL) {
++			passed = false;
++			fwts_failed(fw, LOG_LEVEL_HIGH,
++				"DBG2PortSubTypeReserved",
++				"DBG2 Info Structure Port Subtype is 0x%4.4" PRIx16
++				" which is a reserved type.",
++				info->port_subtype);
++		}
++
++		length_ok = true;
++		dbg2_check_offset(fw, table->length, offset + info->length,
++			"DBG2 Info Structure Namespace Length", &length_ok);
++		passed &= length_ok;
++
++		ok = true;
++		dbg2_check_offset(fw, table->length, offset + info->namespace_offset,
++			"DBG2 Info Structure Namespace String Offset", &ok);
++		dbg2_check_offset(fw, table->length, offset + info->namespace_offset + info->namespace_length,
++			"DBG2 Info Structure Namespace String End", &ok);
++		if (ok) {
++			char *str = (char *)table->data + offset + info->namespace_offset;
++			dbg2_check_namespace_string(fw, str, info->namespace_length, &passed);
++			fwts_log_info_verbatim(fw, "  Namespace String:         '%s'", str);
++			if (strcmp(str, ".") != 0) {
++				bool found = fwts_acpi_obj_find(fw, str);
++				if (!found) {
++					passed = false;
++					fwts_failed(fw, LOG_LEVEL_HIGH,
++							"DBG2DeviceNotFound",
++							"DBG2 Device '%s' not found in ACPI object name space.",
++							str);
++				}
++			}
++		}
++
++		dbg2_check_offset(fw, table->length, offset + info->oem_data_offset,
++			"DBG2 Info Structure OEM Data Offset", &passed);
++		dbg2_check_offset(fw, table->length, offset + info->oem_data_offset + info->oem_data_length,
++			"DBG2 Info Structure OEM Data End", &passed);
++
++		ok = true;
++		total_size = info->number_of_regs * sizeof(fwts_acpi_gas);
++		dbg2_check_offset(fw, table->length, offset + info->base_address_offset,
++			"DBG2 Info Structure Base Address Offset", &ok);
++		dbg2_check_offset(fw, table->length, offset + info->base_address_offset + total_size,
++			"DBG2 Info Structure Base Address End", &ok);
++		total_size = info->number_of_regs * sizeof(uint32_t);
++		dbg2_check_offset(fw, table->length, offset + info->address_size_offset,
++			"DBG2 Info Structure Address Size Offset", &ok);
++		dbg2_check_offset(fw, table->length, offset + info->address_size_offset + total_size,
++			"DBG2 Info Structure Address Size End", &ok);
++		passed &= ok;
++
++		/* Sanity check the GAS array */
++		if (ok) {
++			uint8_t j;
++			fwts_acpi_gas *gas = (fwts_acpi_gas *)(table->data + offset + info->base_address_offset);
++			uint32_t *addrsize = (uint32_t *)(table->data + offset + info->address_size_offset);
++
++			for (j = 0; j < info->number_of_regs; j++, gas++, addrsize++) {
++				fwts_log_info_verbatim(fw, "    Address Space ID:       0x%2.2" PRIx8, gas->address_space_id);
++				fwts_log_info_verbatim(fw, "    Register Bit Width      0x%2.2" PRIx8, gas->register_bit_width);
++				fwts_log_info_verbatim(fw, "    Register Bit Offset     0x%2.2" PRIx8, gas->register_bit_offset);
++				fwts_log_info_verbatim(fw, "    Access Size             0x%2.2" PRIx8, gas->access_width);
++				fwts_log_info_verbatim(fw, "    Address                 0x%16.16" PRIx64, gas->address);
++				fwts_log_nl(fw);
++
++				if (*addrsize == 0) {
++					passed = false;
++					fwts_failed(fw, LOG_LEVEL_HIGH,
++						"DBG2InvalidAddressSize",
++						"DBG2 Address Size is 0");
++				}
++
++				if (gas->register_bit_width == 0) {
++					passed = false;
++					fwts_failed(fw, LOG_LEVEL_HIGH,
++						"DBG2InvalidGasWidth",
++						"DBG2 Generic Address Structure has "
++						"zero register bit width which is probably incorrect");
++				}
++				if (gas->address == 0) {
++					passed = false;
++					fwts_failed(fw, LOG_LEVEL_HIGH,
++						"DBG2InvalidGasAddress",
++						"DBG2 Generic Address Structure has "
++						"a NULL Address which is incorrect");
++				}
++			}
++		}
++		if (!length_ok)
++			break;
++
++		/* ..and onto the next info structure .. */
++		info = (fwts_acpi_table_dbg2_info *)
++			((uint8_t *)info + info->length);
++	}
++
++done:
++	if (passed)
++		fwts_passed(fw, "No issues found in DBG2 table.");
++
++	return FWTS_OK;
++}
++
++static fwts_framework_minor_test sbbr_dbg2_tests[] = {
++	{ sbbr_dbg2_sbsa_uart_test, "DBG2 ARM SBSA Generic UART test," },
++	{ sbbr_dbg2_generic_test, "DBG2 (Debug Port Table 2) test." },
++	{ NULL, NULL }
++};
++
++static fwts_framework_ops sbbr_dbg2_ops = {
++	.description = "DBG2 (Debug Port Table 2) test.",
++	.init        = sbbr_dbg2_init,
++	.minor_tests = sbbr_dbg2_tests
++};
++
++FWTS_REGISTER("sbbr_dbg2", &sbbr_dbg2_ops, FWTS_TEST_ANYTIME, FWTS_FLAG_TEST_SBBR)
++
++#endif
+diff --git a/src/sbbr/dmicheck/dmicheck.c b/src/sbbr/dmicheck/dmicheck.c
+new file mode 100644
+index 0000000..6618c7d
+--- /dev/null
++++ b/src/sbbr/dmicheck/dmicheck.c
+@@ -0,0 +1,1617 @@
++/*
++ * Copyright (C) 2010-2017 Canonical
++ * Copyright (C) 2017      ARM Ltd
++ *
++ * This program is free software; you can redistribute it and/or
++ * modify it under the terms of the GNU General Public License
++ * as published by the Free Software Foundation; either version 2
++ * of the License, or (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
++ *
++ */
++
++#include <stdbool.h>
++#include <string.h>
++#include <stdlib.h>
++#include <inttypes.h>
++
++#include "fwts.h"
++
++#if defined(FWTS_HAS_SBBR)
++
++#include <stdlib.h>
++#include <stdio.h>
++#include <string.h>
++#include <sys/types.h>
++#include <sys/stat.h>
++#include <unistd.h>
++#include <limits.h>
++#include <fcntl.h>
++
++#define DMI_VERSION			(0x0300)
++#define VERSION_MAJOR(v)		((v) >> 8)
++#define VERSION_MINOR(v)		((v) & 0xff)
++
++#define SMBIOS_END_OF_TABLE		(127)
++
++#define DMI_NO_TABLE			"DMINoTable"
++#define DMI_NO_TABLE_HEADER		"DMINoTableHeader"
++#define DMI_BAD_TABLE_LENGTH		"DMIBadTableLength"
++#define DMI_BAD_UUID			"DMIBadUUID"
++#define DMI_STRUCT_COUNT		"DMIStructCount"
++#define DMI_VALUE_OUT_OF_RANGE		"DMIValueOutOfRange"
++#define DMI_STRING_INDEX_OUT_OF_RANGE	"DMIStringIndexOutOfRange"
++#define DMI_ILLEGAL_MAPPED_ADDR_RANGE	"DMIIllegalMappedAddrRange"
++#define DMI_MGMT_CTRL_HOST_TYPE		"DMIMgmtCtrlHostType"
++#define DMI_INVALID_ENTRY_LENGTH	"DMIInvalidEntryLength"
++#define DMI_INVALID_HARDWARE_ENTRY	"DMIInvalidHardwareEntry"
++#define DMI_RESERVED_VALUE_USED		"DMIReservedValueUsed"
++
++#define GET_UINT16(x) (uint16_t)(*(const uint16_t *)(x))
++#define GET_UINT32(x) (uint32_t)(*(const uint32_t *)(x))
++#define GET_UINT64(x) (uint64_t)(*(const uint64_t *)(x))
++
++#define CHASSIS_OTHER			0x00
++#define CHASSIS_DESKTOP			0x01
++#define CHASSIS_WORKSTATION		0x02
++#define CHASSIS_MOBILE			0x04
++#define CHASSIS_SERVER			0x08
++
++typedef struct {
++	const char *label;
++	const char *field;
++	const char *value;
++} fwts_dmi_pattern;
++
++typedef struct {
++	uint16_t   old;
++	uint16_t   new;
++} fwts_dmi_version;
++
++typedef struct {
++	const char *name;
++	uint8_t   original;
++} fwts_chassis_type_map;
++
++typedef struct {
++	uint8_t	type;
++	uint8_t	offset;
++} fwts_dmi_used_by_kernel;
++
++static bool smbios30_found = false;
++
++/*
++ *  Table derived by scanning thousands of DMI table dumps from bug reports
++ */
++static const fwts_dmi_pattern dmi_patterns[] = {
++	{ "DMISerialNumber",	"Serial Number",	"0000000" },
++	{ "DMISerialNumber",	"Serial Number",	"00000000" },
++	{ "DMISerialNumber",	"Serial Number",	"000000000" },
++	{ "DMISerialNumber",	"Serial Number",	"0000000000" },
++	{ "DMISerialNumber",	"Serial Number",	"0x00000000" },
++	{ "DMISerialNumber",	"Serial Number",	"0x0000000000000000" },
++	{ "DMISerialNumber",	"Serial Number",	"012345678" },
++	{ "DMISerialNumber",	"Serial Number",	"0123456789" },
++	{ "DMISerialNumber",	"Serial Number",	"01234567890" },
++	{ "DMISerialNumber",	"Serial Number",	"012345678900" },
++	{ "DMISerialNumber",	"Serial Number",	"0123456789000" },
++	{ "DMISerialNumber",	"Serial Number",	"System Serial Number" },
++	{ "DMISerialNumber",	"Serial Number",	"MB-1234567890" },
++	{ "DMISerialNumber",	"Serial Number",	"NB-1234567890" },
++	{ "DMISerialNumber",	"Serial Number",	"NB-0123456789" },
++	{ "DMISerialNumber",	"Serial Number",	"Base Board Serial Number" },
++	{ "DMISerialNumber",	"Serial Number",	"Chassis Serial Number" },
++	{ "DMISerialNumber",	"Serial Number",	"<cut out>" },
++	{ "DMISerialNumber",	"Serial Number",	"Empty" },
++	{ "DMISerialNumber",	"Serial Number",	"[Empty]" },
++	{ "DMISerialNumber",	"Serial Number",	"NA" },
++	{ "DMISerialNumber",	"Serial Number",	"N/A" },
++	{ "DMISerialNumber",	"Serial Number",	"None" },
++	{ "DMISerialNumber",	"Serial Number",	"None1" },
++	{ "DMISerialNumber",	"Serial Number",	"Not Available" },
++	{ "DMISerialNumber",	"Serial Number",	"Not Specified" },
++	{ "DMISerialNumber",	"Serial Number",	"NotSupport" },
++	{ "DMISerialNumber",	"Serial Number",	"Not Supported by CPU" },
++	{ "DMISerialNumber",	"Serial Number",	"Not Supported" },
++	{ "DMISerialNumber",	"Serial Number",	"OEM Chassis Serial Number" },
++	{ "DMISerialNumber",	"Serial Number",	"OEM_Define1" },
++	{ "DMISerialNumber",	"Serial Number",	"OEM_Define2" },
++	{ "DMISerialNumber",	"Serial Number",	"OEM_Define3" },
++	{ "DMISerialNumber",	"Serial Number",	"SerNum0" },
++	{ "DMISerialNumber",	"Serial Number",	"SerNum00" },
++	{ "DMISerialNumber",	"Serial Number",	"SerNum01" },
++	{ "DMISerialNumber",	"Serial Number",	"SerNum02" },
++	{ "DMISerialNumber",	"Serial Number",	"SerNum03" },
++	{ "DMISerialNumber",	"Serial Number",	"SerNum1" },
++	{ "DMISerialNumber",	"Serial Number",	"SerNum2" },
++	{ "DMISerialNumber",	"Serial Number",	"SerNum3" },
++	{ "DMISerialNumber",	"Serial Number",	"SerNum4" },
++	{ "DMISerialNumber",	"Serial Number",	"TBD by ODM" },
++	{ "DMISerialNumber",	"Serial Number",	"To Be Defined By O.E.M" },
++	{ "DMISerialNumber",	"Serial Number",	"To be filled by O.E.M." },
++	{ "DMISerialNumber",	"Serial Number",	"To Be Filled By O.E.M." },
++	{ "DMISerialNumber",	"Serial Number",	"Unknow" },
++	{ "DMISerialNumber",	"Serial Number",	"Unknown" },
++	{ "DMISerialNumber",	"Serial Number",	"XXXXXXXXXXXX" },
++	{ "DMISerialNumber",	"Serial Number",	"XXXXXXXXXXX" },
++	{ "DMISerialNumber",	"Serial Number",	"XXXXXXXXXX" },
++	{ "DMISerialNumber",	"Serial Number",	"XXXXXXXXX" },
++	{ "DMISerialNumber",	"Serial Number",	"XXXXXXXX" },
++	{ "DMISerialNumber",	"Serial Number",	"XXXXXX" },
++	{ "DMISerialNumber",	"Serial Number",	"XXXXX" },
++	{ "DMISerialNumber",	NULL,			"Chassis Serial Number" },
++	{ "DMIAssetTag",	"Asset Tag",		"0000000000" },
++	{ "DMIAssetTag",	"Asset Tag",		"0x00000000" },
++	{ "DMIAssetTag",	"Asset Tag",		"1234567890" },
++	{ "DMIAssetTag",	"Asset Tag",		"123456789000" },
++	{ "DMIAssetTag",	"Asset Tag",		"9876543210" },
++	{ "DMIAssetTag",	"Asset Tag",		"A1_AssetTagNum0" },
++	{ "DMIAssetTag",	"Asset Tag",		"A1_AssetTagNum1" },
++	{ "DMIAssetTag",	"Asset Tag",		"A1_AssetTagNum2" },
++	{ "DMIAssetTag",	"Asset Tag",		"A1_AssetTagNum3" },
++	{ "DMIAssetTag",	"Asset Tag",		"ABCDEFGHIJKLM" },
++	{ "DMIAssetTag",	"Asset Tag",		"Asset-1234567890" },
++	{ "DMIAssetTag",	"Asset Tag",		"Asset Tag" },
++	{ "DMIAssetTag",	"Asset Tag",		"Asset Tag:" },
++	{ "DMIAssetTag",	"Asset Tag",		"AssetTagNum0" },
++	{ "DMIAssetTag",	"Asset Tag",		"AssetTagNum1" },
++	{ "DMIAssetTag",	"Asset Tag",		"AssetTagNum2" },
++	{ "DMIAssetTag",	"Asset Tag",		"AssetTagNum3" },
++	{ "DMIAssetTag",	"Asset Tag",		"AssetTagNum4" },
++	{ "DMIAssetTag",	"Asset Tag",		"Asset tracking" },
++	{ "DMIAssetTag",	"Asset Tag",		"ATN12345678901234567" },
++	{ "DMIAssetTag",	"Asset Tag",		"Base Board Asset Tag#" },
++	{ "DMIAssetTag",	"Asset Tag",		"Base Board Asset Tag" },
++	{ "DMIAssetTag",	"Asset Tag",		"Chassis Asset Tag" },
++	{ "DMIAssetTag",	"Asset Tag",		"<cut out>" },
++	{ "DMIAssetTag",	"Asset Tag",		"Fill By OEM" },
++	{ "DMIAssetTag",	"Asset Tag",		"N/A" },
++	{ "DMIAssetTag",	"Asset Tag",		"No Asset Information" },
++	{ "DMIAssetTag",	"Asset Tag",		"No Asset Tag" },
++	{ "DMIAssetTag",	"Asset Tag",		"None" },
++	{ "DMIAssetTag",	"Asset Tag",		"Not Available" },
++	{ "DMIAssetTag",	"Asset Tag",		"Not Specified" },
++	{ "DMIAssetTag",	"Asset Tag",		"OEM_Define0" },
++	{ "DMIAssetTag",	"Asset Tag",		"OEM_Define1" },
++	{ "DMIAssetTag",	"Asset Tag",		"OEM_Define2" },
++	{ "DMIAssetTag",	"Asset Tag",		"OEM_Define3" },
++	{ "DMIAssetTag",	"Asset Tag",		"OEM_Define4" },
++	{ "DMIAssetTag",	"Asset Tag",		"TBD by ODM" },
++	{ "DMIAssetTag",	"Asset Tag",		"To Be Defined By O.E.M" },
++	{ "DMIAssetTag",	"Asset Tag",		"To be filled by O.E.M." },
++	{ "DMIAssetTag",	"Asset Tag",		"To Be Filled By O.E.M." },
++	{ "DMIAssetTag",	"Asset Tag",		"Unknown" },
++	{ "DMIAssetTag",	"Asset Tag",		"XXXXXXXXXXXX" },
++	{ "DMIAssetTag",	"Asset Tag",		"XXXXXXXXXXX" },
++	{ "DMIAssetTag",	"Asset Tag",		"XXXXXXXXXX" },
++	{ "DMIAssetTag",	"Asset Tag",		"XXXXXXXXX" },
++	{ "DMIAssetTag",	"Asset Tag",		"XXXXXXXX" },
++	{ "DMIAssetTag",	"Asset Tag",		"XXXXXXX" },
++	{ "DMIAssetTag",	"Asset Tag",		"XXXXXX" },
++	{ "DMIChassisVendor",	NULL,			"Chassis Manufacture" },
++	{ "DMIChassisVersion",	NULL,			"Chassis Version" },
++	{ "DMIProductVersion",	NULL,			"System Version" },
++	{ "DMIBadDefault",	NULL,			"To Be Defined By O.E.M" },
++	{ "DMIBadDefault",	NULL,			"To be filled by O.E.M." },
++	{ "DMIBadDefault",	NULL,			"To Be Filled By O.E.M." },
++	{ NULL,			NULL,			NULL }
++};
++
++static const char *uuid_patterns[] = {
++	"0A0A0A0A-0A0A-0A0A-0A0A-0A0A0A0A0A0A",
++	NULL,
++};
++
++static const fwts_chassis_type_map fwts_dmi_chassis_type[] = {
++	{ "Invalid",		FWTS_SMBIOS_CHASSIS_INVALID },
++	{ "Other",		FWTS_SMBIOS_CHASSIS_OTHER },
++	{ "Unknown",		FWTS_SMBIOS_CHASSIS_UNKNOWN },
++	{ "Desktop",		FWTS_SMBIOS_CHASSIS_DESKTOP },
++	{ "Low Profile Desktop",FWTS_SMBIOS_CHASSIS_LOW_PROFILE_DESKTOP },
++	{ "Pizza Box",		FWTS_SMBIOS_CHASSIS_PIZZA_BOX },
++	{ "Mini Tower",		FWTS_SMBIOS_CHASSIS_MINI_TOWER },
++	{ "Chassis Tower",	FWTS_SMBIOS_CHASSIS_TOWER },
++	{ "Portable",		FWTS_SMBIOS_CHASSIS_PORTABLE },
++	{ "Laptop",		FWTS_SMBIOS_CHASSIS_LAPTOP },
++	{ "Notebook",		FWTS_SMBIOS_CHASSIS_NOTEBOOK },
++	{ "Handheld",		FWTS_SMBIOS_CHASSIS_HANDHELD },
++	{ "Docking Station",	FWTS_SMBIOS_CHASSIS_DOCKING_STATION },
++	{ "All In One",		FWTS_SMBIOS_CHASSIS_ALL_IN_ONE },
++	{ "Sub Notebook",	FWTS_SMBIOS_CHASSIS_SUB_NOTEBOOK },
++	{ "Space Saving",	FWTS_SMBIOS_CHASSIS_SPACE_SAVING },
++	{ "Lunch Box",		FWTS_SMBIOS_CHASSIS_LUNCH_BOX},
++	{ "Server Chassis",	FWTS_SMBIOS_CHASSIS_MAIN_SERVER_CHASSIS },
++	{ "Expansion Chassis",	FWTS_SMBIOS_CHASSIS_EXPANISON_CHASSIS },
++	{ "Sub Chassis",	FWTS_SMBIOS_CHASSIS_SUB_CHASSIS },
++	{ "Bus Expansion Chassis", FWTS_SMBIOS_CHASSIS_BUS_EXPANSION_CHASSIS },
++	{ "Peripheral Chassis",	FWTS_SMBIOS_CHASSIS_PERIPHERAL_CHASSIS },
++	{ "Raid Chassis",	FWTS_SMBIOS_CHASSIS_RAID_CHASSIS },
++	{ "Rack Mount Chassis",	FWTS_SMBIOS_CHASSIS_RACK_MOUNT_CHASSIS },
++	{ "Sealed Case PC",	FWTS_SMBIOS_CHASSIS_SEALED_CASE_PC },
++	{ "Multi System Chassis",FWTS_SMBIOS_CHASSIS_MULTI_SYSTEM_CHASSIS },
++	{ "Compact PCI",	FWTS_SMBIOS_CHASSIS_COMPACT_PCI },
++	{ "Advanced TCA",	FWTS_SMBIOS_CHASSIS_ADVANCED_TCA },
++	{ "Blade",		FWTS_SMBIOS_CHASSIS_BLADE },
++	{ "Enclosure",		FWTS_SMBIOS_CHASSIS_BLADE_ENCLOSURE },
++	{ "Tablet",		FWTS_SMBIOS_CHASSIS_TABLET },
++	{ "Convertible",	FWTS_SMBIOS_CHASSIS_CONVERTIBLE },
++	{ "Detachable",		FWTS_SMBIOS_CHASSIS_DETACHABLE },
++};
++
++#define FIELD_ANY	0xff
++#define TYPE_EOD	0xff
++#define ANCHOR_SIZE 8
++
++/*
++ *  DMI decoded fields used by the kernel, i.e. fields
++ *  we care that work,
++ *	see drivers/firmware/dmi_scan.c, dmi_decode()
++ */
++static fwts_dmi_used_by_kernel dmi_used_by_kernel_table[] = {
++	/* Type 0 BIOS Information fields */
++	{ 0, 4 },
++	{ 0, 5 },
++	{ 0, 8 },
++	/* Type 1, System Information */
++	{ 1, 4 },
++	{ 1, 5 },
++	{ 1, 6 },
++	{ 1, 7 },
++	{ 1, 8 },
++	/* Type 2, Base Board Information */
++	{ 2, 4 },
++	{ 2, 5 },
++	{ 2, 6 },
++	{ 2, 7 },
++	{ 2, 8 },
++	/* Type 3, Chassis Information */
++	{ 3, 4 },
++	{ 3, 5 },
++	{ 3, 6 },
++	{ 3, 7 },
++	{ 3, 8 },
++	/* Type 10, Onboard Devices Information */
++	{ 10, FIELD_ANY },
++	/* Type 11, OEM Strings */
++	{ 11, FIELD_ANY },
++	/* Type 38, IPMI Device Information */
++	{ 38, FIELD_ANY },
++	/* Type 41, Onboard Devices Extended Information */
++	{ 41, FIELD_ANY },
++	/* End */
++	{ TYPE_EOD, 0xff },
++};
++
++static int dmi_load_file(const char* filename, void *buf, size_t size)
++{
++	int fd;
++	ssize_t ret;
++
++	if ((fd = open(filename, O_RDONLY)) < 0)
++		return FWTS_ERROR;
++	ret = read(fd, buf, size);
++	(void)close(fd);
++	if (ret != (ssize_t)size)
++		return FWTS_ERROR;
++	return FWTS_OK;
++}
++
++static void* dmi_table_smbios30(fwts_framework *fw, fwts_smbios30_entry *entry)
++{
++	size_t length = (size_t)entry->struct_table_max_size;
++	void *table;
++	char anchor[ANCHOR_SIZE];
++
++	/* 64 bit entry sanity check on length */
++	if ((length == 0) || (length > 0xffffff)) {
++		fwts_log_info(fw, "SMBIOS table size of %zu bytes looks "
++			"suspicious",  length);
++		return NULL;
++	}
++
++	if (dmi_load_file("/sys/firmware/dmi/tables/smbios_entry_point", anchor, sizeof("_SM3_")) == FWTS_OK
++			&& strncmp(anchor, "_SM3_", sizeof("_SM3_")) == 0) {
++		table = malloc(length);
++		if (!table)
++			return NULL;
++		if (dmi_load_file("/sys/firmware/dmi/tables/DMI", table, length) == FWTS_OK) {
++			fwts_log_info(fw, "SMBIOS30 table loaded from /sys/firmware/dmi/tables/DMI\n");
++			return table;
++		}
++		free(table);
++	}
++
++	fwts_log_error(fw, "Cannot mmap SMBIOS 3.0 table from %16.16" PRIx64 "..%16.16" PRIx64 ".",
++			entry->struct_table_address, entry->struct_table_address + entry->struct_table_max_size);
++	return NULL;
++}
++
++static void dmi_table_free(void* table)
++{
++	if (table)
++		free(table);
++}
++
++
++static void dmi_dump_entry30(fwts_framework *fw, fwts_smbios30_entry *entry)
++{
++
++	fwts_log_info_verbatim(fw, "SMBIOS30 Entry Point Structure:");
++	fwts_log_info_verbatim(fw, "  Anchor String          : %5.5s", entry->signature);
++	fwts_log_info_verbatim(fw, "  Checksum               : 0x%2.2" PRIx8, entry->checksum);
++	fwts_log_info_verbatim(fw, "  Entry Point Length     : 0x%2.2" PRIx8, entry->length);
++	fwts_log_info_verbatim(fw, "  Major Version          : 0x%2.2" PRIx8, entry->major_version);
++	fwts_log_info_verbatim(fw, "  Minor Version          : 0x%2.2" PRIx8, entry->minor_version);
++	fwts_log_info_verbatim(fw, "  Docrev                 : 0x%2.2" PRIx8, entry->docrev);
++	fwts_log_info_verbatim(fw, "  Entry Point Revision   : 0x%2.2" PRIx8, entry->revision);
++	fwts_log_info_verbatim(fw, "  Reserved               : 0x%2.2" PRIx8, entry->reserved);
++	fwts_log_info_verbatim(fw, "  Table maximum size     : 0x%8.8" PRIx32, entry->struct_table_max_size);
++	fwts_log_info_verbatim(fw, "  Table address          : 0x%16.16" PRIx64, entry->struct_table_address);
++
++}
++
++static int dmi_smbios30_sane(fwts_framework *fw, fwts_smbios30_entry *entry)
++{
++	uint8_t	*table, *ptr;
++	uint16_t i = 0;
++	uint32_t table_length = entry->struct_table_max_size;
++	int ret = FWTS_OK;
++
++	ptr = table = dmi_table_smbios30(fw, entry);
++	if (table == NULL)
++		return FWTS_ERROR;
++
++	for (;;) {
++		uint8_t struct_length;
++		uint8_t struct_type;
++
++		if (ptr > table + table_length) {
++			fwts_failed(fw, LOG_LEVEL_MEDIUM,
++				"SMBIOS30TableLengthTooSmall",
++				"The maximum size indicated by the SMBIOS 3.0 table length is "
++				"smaller than the dmi data or the DMI end of table not found.");
++			ret = FWTS_ERROR;
++			break;
++		}
++
++		struct_type = ptr[0];
++		struct_length = ptr[1];
++
++		if (struct_length < 4) {
++			fwts_failed(fw, LOG_LEVEL_MEDIUM,
++				"SMBIOSIllegalTableEntry",
++				"The size of a DMI entry %" PRIu16 " is illegal, "
++				"DMI data is either wrong or the SMBIOS Table "
++				"Pointer is pointing to the wrong memory region.", i);
++			ret = FWTS_ERROR;
++			break;
++		}
++		ptr += struct_length;
++
++		/* Scan for end of DMI entry, must be 2 zero bytes */
++		while (((ptr - table + 1) < (ssize_t)table_length) &&
++		       ((ptr[0] != 0) || (ptr[1] != 0)))
++				ptr++;
++		/* Skip over the two zero bytes */
++		ptr += 2;
++
++		/* We found DMI end of table and inside the maximum length? */
++		if (struct_type == 127) {
++			if (ptr <= table + table_length)
++				break;
++			else {
++				fwts_failed(fw, LOG_LEVEL_HIGH,
++					"SMBIOS30TableLengthTooSmall",
++					"The end of DMI table marker structure was found "
++					"but outside the structure table maximum size");
++				ret = FWTS_ERROR;
++				break;
++			}
++		}
++	}
++
++	dmi_table_free(table);
++
++	return ret;
++}
++
++static int smbios30_entry_check(fwts_framework *fw)
++{
++	void *addr = 0;
++
++	fwts_smbios30_entry entry;
++	uint16_t version;
++	uint8_t checksum;
++
++	if ((addr = fwts_smbios30_find_entry(fw, &entry, &version)) == NULL)
++		return FWTS_ERROR;
++
++	fwts_passed(fw, "Found SMBIOS30 Table Entry Point at %p", addr);
++	dmi_dump_entry30(fw, &entry);
++	fwts_log_nl(fw);
++
++	checksum = fwts_checksum((uint8_t *)&entry, sizeof(fwts_smbios30_entry));
++	if (checksum != 0)
++		fwts_failed(fw, LOG_LEVEL_HIGH,
++			"SMBIOS30BadChecksum",
++			"SMBIOS30 Table Entry Point Checksum is 0x%2.2" PRIx8
++			", should be 0x%2.2" PRIx8,
++			entry.checksum, (uint8_t)(entry.checksum - checksum));
++	else
++		fwts_passed(fw, "SMBIOS30 Table Entry Point Checksum is valid.");
++
++	if (entry.length != 0x18) {
++		fwts_failed(fw, LOG_LEVEL_MEDIUM,
++			"SMBIOS30BadEntryLength",
++			"SMBIOS30 Table Entry Point Length is 0x%2.2"  PRIx8
++			", should be 0x18", entry.length);
++	} else
++		fwts_passed(fw, "SMBIOS30 Table Entry Point Length is valid.");
++
++	if (entry.reserved)
++		fwts_failed(fw, LOG_LEVEL_MEDIUM,
++			"SMBIOSBadReserved",
++			"SMBIOS30 Table Entry Point Reserved is 0x%2.2" PRIx8
++			", should be 0", entry.reserved);
++
++	if ((entry.revision == 1) && (entry.struct_table_address == 0)) {
++		fwts_failed(fw, LOG_LEVEL_HIGH,
++			"SMBIOS30BadTableAddress",
++			"SMBIOS Table Entry Structure Table Address is NULL and should be defined.");
++	} else {
++		/*
++		 * Now does the SMBIOS 3.0.0 table look sane? If not,
++		 * the SMBIOS Structure Table could be bad
++		 */
++		if (dmi_smbios30_sane(fw, &entry) == FWTS_OK)
++			fwts_passed(fw, "SMBIOS 3.0 Table Entry Structure Table Address and Length looks valid.");
++	}
++
++	return FWTS_OK;
++
++}
++
++static int sbbr_dmicheck_revision_test(fwts_framework *fw)
++{
++
++	if (smbios30_entry_check(fw) != FWTS_ERROR) {
++		smbios30_found = true;
++	}
++
++	if (!smbios30_found) {
++		fwts_failed(fw, LOG_LEVEL_HIGH,
++			"SMBIOSNoEntryPoint",
++			"Could not find any SMBIOS Table Entry Points.");
++		return FWTS_ERROR;
++	}
++
++	return FWTS_OK;
++}
++
++static bool dmi_used_by_kernel(uint8_t type, uint8_t offset)
++{
++	int i;
++
++	for (i = 0; dmi_used_by_kernel_table[i].type != TYPE_EOD; i++) {
++		if (dmi_used_by_kernel_table[i].type == type)
++			if ((dmi_used_by_kernel_table[i].offset == FIELD_ANY) ||
++			    (dmi_used_by_kernel_table[i].offset == offset))
++				return true;
++	}
++	return false;
++}
++
++static void dmi_out_of_range_advice(fwts_framework *fw, uint8_t type, uint8_t offset)
++{
++	if (dmi_used_by_kernel(type, offset))
++		fwts_advice(fw,
++			"A value that is out of range is incorrect and not conforming to "
++			"the SMBIOS specification.  The Linux kernel extracts and uses "
++			"this particular data item, so it is recommended that this SMBIOS "
++			"configuration is corrected even if the impact on the system "
++			"is most probably not critical.");
++	else
++		fwts_advice(fw,
++			"A value that is out of range is incorrect and not conforming to "
++			"the SMBIOS specification.  This field is not currently used by "
++			"the Linux kernel, so this firmware bug shouldn't cause any "
++			"problems.");
++}
++
++static void dmi_min_max_uint8_check(fwts_framework *fw,
++	const char *table,
++	uint32_t addr,
++	const char *field,
++	const fwts_dmi_header *hdr,
++	uint8_t offset,
++	uint8_t min,
++	uint8_t max)
++{
++	uint8_t val = hdr->data[offset];
++	if ((val < min) || (val > max)) {
++		fwts_failed(fw, LOG_LEVEL_HIGH,
++			DMI_VALUE_OUT_OF_RANGE,
++			"Out of range value 0x%2.2" PRIx8
++			" (range allowed 0x%2.2" PRIx8 "..0x%2.2" PRIx8 ") "
++			"while accessing entry '%s' @ 0x%8.8" PRIx32
++			", field '%s', offset 0x%2.2" PRIx8,
++			val, min, max, table, addr, field, offset);
++		dmi_out_of_range_advice(fw, hdr->type, offset);
++	}
++}
++
++static void dmi_min_max_mask_uint8_check(fwts_framework *fw,
++	const char *table,
++	uint32_t addr,
++	const char *field,
++	const fwts_dmi_header *hdr,
++	uint8_t offset,
++	uint8_t min,
++	uint8_t max,
++	uint8_t shift,
++	uint8_t mask)
++{
++	uint8_t val = (hdr->data[offset] >> shift) & mask;
++
++	if ((val < min) || (val > max)) {
++		fwts_failed(fw, LOG_LEVEL_HIGH, DMI_VALUE_OUT_OF_RANGE,
++			"Out of range value 0x%2.2" PRIx8
++			" (range allowed 0x%2.2" PRIx8 "..0x%2.2" PRIx8 ") "
++			"while accessing entry '%s' @ 0x%8.8" PRIx32
++			", field '%s', offset 0x%2.2" PRIx8,
++			val, min, max, table, addr, field, offset);
++		dmi_out_of_range_advice(fw, hdr->type, offset);
++	}
++}
++
++static void dmi_str_check_index(fwts_framework *fw,
++	const char *table,
++	uint32_t addr,
++	const char *field,
++	const fwts_dmi_header *hdr,
++	uint8_t offset,
++	uint8_t index)
++{
++	char	*data = (char *)hdr->data;
++	uint8_t	i = index;
++	bool used_by_kernel = dmi_used_by_kernel(hdr->type, offset);
++
++	if (i > 0) {
++		int	j;
++		int	failed = -1;
++
++		data += hdr->length;
++		while (i > 1 && *data) {
++			data += strlen(data) + 1;
++			i--;
++		}
++
++		/* Sanity checks */
++		if (*data == '\0') {
++			int level = used_by_kernel ? LOG_LEVEL_HIGH : LOG_LEVEL_LOW;
++
++			/* This entry is clearly broken so flag it as a corrupt entry */
++			fwts_failed(fw, level, DMI_STRING_INDEX_OUT_OF_RANGE,
++				"Out of range string index 0x%2.2" PRIx8
++				" while accessing entry '%s' "
++				"@ 0x%8.8" PRIx32 ", field '%s', offset 0x%2.2" PRIx8,
++				index, table, addr, field, offset);
++			if (used_by_kernel)
++				fwts_advice(fw,
++					"DMI strings are stored in a manner that uses a special "
++					"index to fetch the Nth string from the data. For this "
++					"particular DMI string the index given is not in range "
++					"which means this particular entry is broken. The Linux "
++					"kernel uses this string - hence this string should be "
++					"fixed to ensure sane data is passed to the kernel. "
++					"Note that this probably won't cause any critical system "
++					"errors.");
++			else
++				fwts_advice(fw,
++					"DMI strings are stored in a manner that uses a special "
++					"index to fetch the Nth string from the data. For this "
++					"particular DMI string the index given is not in range "
++					"which means this particular entry is broken. The Linux "
++					"kernel does not use this string, so this error will not "
++					"cause any system errors.");
++			return;
++		}
++
++		/* Scan for known BIOS defaults that vendors forget to set */
++		for (j = 0; dmi_patterns[j].label != NULL; j++) {
++			if (dmi_patterns[j].field &&
++				(strcmp(dmi_patterns[j].field, field) == 0) &&
++				(strcmp(dmi_patterns[j].value, data) == 0)) {
++				failed = j;
++				break;
++			} else if (strcmp(dmi_patterns[j].value, data) == 0) {
++				failed = j;
++				break;
++			}
++		}
++		if (failed != -1) {
++			int level = used_by_kernel ? LOG_LEVEL_MEDIUM : LOG_LEVEL_LOW;
++
++			fwts_failed(fw, level, dmi_patterns[j].label,
++				"String index 0x%2.2" PRIx8
++				" in table entry '%s' @ 0x%8.8" PRIx32
++				", field '%s', offset 0x%2.2" PRIx8
++				" has a default value '%s' and probably has "
++				"not been updated by the BIOS vendor.",
++				index, table, addr, field, offset, data);
++
++			if (used_by_kernel) {
++				fwts_advice(fw,
++					"The DMI table contains data which is clearly been "
++					"left in a default setting and not been configured "
++					"for this machine. "
++					"Somebody has probably forgotten to define this "
++					"field and it basically means this field is effectively "
++					"useless. Note that the kernel uses this field so "
++					"it probably should be corrected to ensure the kernel "
++					"is using sane values.");
++			} else {
++				/* This string is broken, but we don't care about it too much */
++				fwts_advice(fw,
++					"The DMI table contains data which is clearly been "
++					"left in a default setting and not been configured "
++					"for this machine. "
++					"Somebody has probably forgotten to define this "
++					"field and it basically means this field is effectively "
++					"useless, however the kernel does not use this data "
++					"so the issue is fairly low.");
++			}
++		}
++	}
++}
++
++static void dmi_str_check(fwts_framework *fw,
++	const char *table,
++	uint32_t addr,
++	const char *field,
++	const fwts_dmi_header *hdr,
++	uint8_t offset)
++{
++	dmi_str_check_index(fw, table, addr, field, hdr, offset, hdr->data[offset]);
++}
++
++static void dmi_uuid_check(fwts_framework *fw,
++	const char *table,
++	uint32_t addr,
++	const char *field,
++	const fwts_dmi_header *hdr,
++	uint8_t offset)
++{
++	char guid_str[37];
++	int i;
++
++	fwts_guid_buf_to_str(hdr->data + offset, guid_str, sizeof(guid_str));
++
++	for (i = 0; uuid_patterns[i] != NULL; i++) {
++		if (strcmp(guid_str, uuid_patterns[i]) == 0) {
++			fwts_failed(fw, LOG_LEVEL_LOW, DMI_BAD_UUID,
++				"UUID in table entry '%s' @ 0x%8.8" PRIx32
++				" field '%s', offset 0x%2.2" PRIx8
++				" has a default value '%s' and probably has "
++				"not been updated by the BIOS vendor.",
++				table, addr, field, offset, guid_str);
++			fwts_advice(fw,
++				"The DMI table contains a UUID which is clearly been "
++				"left in a default setting and not been configured "
++				"for this machine.  While this is not critical it does "
++				"mean that somebody has probably forgotten to define this "
++				"field and it basically means this field is effectively "
++				"useless.");
++		}
++	}
++}
++
++static void dmicheck_entry(fwts_framework *fw,
++	uint32_t addr,
++	const fwts_dmi_header *hdr)
++{
++	uint8_t *ptr;
++	uint8_t count;
++	uint8_t val;
++	uint8_t *data = hdr->data;
++	char	tmp[64];
++	char	*table;
++	int	i;
++	int	len;
++	uint32_t failed_count = fw->minor_tests.failed;
++	int	battery_count;
++	int	ret;
++	bool	advice_given = false;
++
++	switch (hdr->type) {
++		case 0: /* 7.1 */
++			table = "BIOS Information (Type 0)";
++			if (hdr->length < 0x12)
++				break;
++			dmi_str_check(fw, table, addr, "Vendor", hdr, 0x4);
++			dmi_str_check(fw, table, addr, "BIOS Version", hdr, 0x5);
++			dmi_str_check(fw, table, addr, "Release Date", hdr, 0x8);
++			break;
++
++		case 1: /* 7.2 */
++			table = "System Information (Type 1)";
++			if (hdr->length < 0x08)
++				break;
++			dmi_str_check(fw, table, addr, "Manufacturer", hdr, 0x4);
++			dmi_str_check(fw, table, addr, "Product Name", hdr, 0x5);
++			dmi_str_check(fw, table, addr, "Version", hdr, 0x6);
++			dmi_str_check(fw, table, addr, "Serial Number", hdr, 0x7);
++			if (hdr->length < 0x19)
++				break;
++			dmi_uuid_check(fw, table, addr, "UUID", hdr, 0x8);
++			dmi_min_max_uint8_check(fw, table, addr, "Wakeup Type", hdr, 0x18, 0x0, 0x08);
++			if (hdr->length < 0x1b)
++				break;
++			dmi_str_check(fw, table, addr, "SKU Number", hdr, 0x19);
++			dmi_str_check(fw, table, addr, "Family", hdr, 0x1a);
++			break;
++
++		case 2: /* 7.3 */
++			table = "Base Board Information (Type 2)";
++			if (hdr->length < 0x08)
++				break;
++			dmi_str_check(fw, table, addr, "Manufacturer", hdr, 0x4);
++			dmi_str_check(fw, table, addr, "Product", hdr, 0x5);
++			dmi_str_check(fw, table, addr, "Version", hdr, 0x6);
++			dmi_str_check(fw, table, addr, "Serial Number", hdr, 0x7);
++			if (hdr->length < 0x09)
++				break;
++			dmi_str_check(fw, table, addr, "Asset Tag", hdr, 0x8);
++			if (hdr->length < 0x0f)
++				break;
++			dmi_str_check(fw, table, addr, "Location In Chassis", hdr, 0xa);
++			dmi_min_max_uint8_check(fw, table, addr, "Type", hdr, 0xd, 0x1, 0xd);
++			break;
++
++		case 3: /* 7.4 */
++			table = "Chassis Information (Type 3)";
++			if (hdr->length < 0x09)
++				break;
++			dmi_str_check(fw, table, addr, "Manufacturer", hdr, 0x4);
++			dmi_min_max_mask_uint8_check(fw, table, addr, "Chassis Type", hdr, 0x5, 0x1, 0x1d, 0x0, 0x7f);
++
++			if (data[5] >=
++				(sizeof(fwts_dmi_chassis_type) / sizeof(fwts_chassis_type_map))) {
++				fwts_failed(fw, LOG_LEVEL_HIGH, DMI_INVALID_HARDWARE_ENTRY,
++					"Incorrect Chassis Type "
++					"SMBIOS Type 3 reports 0x%" PRIx8,
++					data[5]);
++				break;
++			}
++
++			dmi_min_max_mask_uint8_check(fw, table, addr, "Chassis Lock", hdr, 0x5, 0x0, 0x1, 0x7, 0x1);
++			dmi_str_check(fw, table, addr, "Version", hdr, 0x6);
++			dmi_str_check(fw, table, addr, "Serial Number", hdr, 0x7);
++			dmi_str_check(fw, table, addr, "Asset Tag", hdr, 0x8);
++			dmi_min_max_uint8_check(fw, table, addr, "Boot-up State", hdr, 0x9, 0x1, 0x6);
++			dmi_min_max_uint8_check(fw, table, addr, "Power Supply State", hdr, 0xa, 0x1, 0x6);
++			dmi_min_max_uint8_check(fw, table, addr, "Thermal State", hdr, 0xb, 0x1, 0x6);
++			dmi_min_max_uint8_check(fw, table, addr, "Security Status", hdr, 0xc, 0x1, 0x5);
++			if (hdr->length < 0x15 + data[0x13] * data[0x14])
++				break;
++			ptr = data + 0x15;
++			len = data[0x14];
++			if (len >= 0x3) {
++				for (i = 0; i < data[0x13]; i++) {
++					val = ptr[i * len] & 0x7f;
++					if (ptr[i * len] & 0x80) {
++						if (val > 0x42)
++							fwts_failed(fw, LOG_LEVEL_HIGH, DMI_VALUE_OUT_OF_RANGE,
++								"Out of range value 0x%2.2" PRIx8
++								" (range allowed 0x00..0x42) "
++								"while accessing entry '%s' @ "
++								"0x%8.8" PRIx32 ", field "
++								"'SMBIOS Structure Type %d', "
++								"offset 0x%2.2x",
++								val, table, addr, i, 0x15 + (i*len));
++					} else {
++						if ((val < 0x1) || (val > 0xd)) {
++							fwts_failed(fw, LOG_LEVEL_HIGH, DMI_VALUE_OUT_OF_RANGE,
++								"Out of range value 0x%2.2" PRIx8
++								" (range allowed 0x01..0x0d) "
++								"while accessing entry '%s' @ "
++								"0x%8.8" PRIx32 ", field "
++								"'Base Board Type %d', offset 0x%2.2x",
++								val, table, addr, i, 0x15 + (i*len));
++						}
++					}
++				}
++			}
++			if (hdr->length < 0x16 + data[0x13] * data[0x14])
++				break;
++			dmi_str_check(fw, table, addr, "SKU Number", hdr, 0x15 + data[0x13] * data[0x14]);
++			break;
++
++		case 4: /* 7.5 */
++			table = "Processor Information (Type 4)";
++			if (hdr->length < 0x1a)
++				break;
++			dmi_str_check(fw, table, addr, "Socket Designation", hdr, 0x4);
++			dmi_min_max_uint8_check(fw, table, addr, "Processor Type", hdr, 0x5, 0x1, 0x6);
++			dmi_str_check(fw, table, addr, "Processor Manufacturer", hdr, 0x7);
++			dmi_str_check(fw, table, addr, "Processor Version", hdr, 0x10);
++			dmi_min_max_uint8_check(fw, table, addr, "Upgrade", hdr, 0x19, 0x1, 0x30);
++			if (hdr->length < 0x23)
++				break;
++			dmi_str_check(fw, table, addr, "Serial Number", hdr, 0x20);
++			dmi_str_check(fw, table, addr, "Asset Tag", hdr, 0x21);
++			dmi_str_check(fw, table, addr, "Part Number", hdr, 0x22);
++			if (hdr->length < 0x28)
++				break;
++			if (GET_UINT16(data + 0x26) & 0xff00)
++				fwts_failed(fw, LOG_LEVEL_MEDIUM, DMI_RESERVED_VALUE_USED,
++					"Reserved bits 0x%4.4" PRIx16 " was used"
++					"bits 8..15 would be reserved while accessing entry '%s' @ "
++					"0x%8.8" PRIx32 ", field '%s', offset 0x%2.2x",
++					GET_UINT16(data + 0x26),
++					table, addr, "Processor Characteristics", 0x26);
++			break;
++
++		case 5: /* 7.6 */
++			table = "Memory Controller Information (Type 5)";
++			if (hdr->length < 0x0f)
++				break;
++			dmi_min_max_uint8_check(fw, table, addr, "Error Detecting Method", hdr, 0x4, 0x1, 0x8);
++			dmi_min_max_uint8_check(fw, table, addr, "Supported Interleave", hdr, 0x6, 0x1, 0x7);
++			dmi_min_max_uint8_check(fw, table, addr, "Current Interleave", hdr, 0x7, 0x1, 0x7);
++			break;
++
++		case 6: /* 7.7 */
++			table = "Memory Module Information (Type 6)";
++			if (hdr->length < 0x0c)
++				break;
++			dmi_str_check(fw, table, addr, "Socket Designation", hdr, 0x4);
++			break;
++
++		case 7: /* 7.8 */
++			table = "Cache Information (Type 7)";
++			if (hdr->length < 0x0f)
++				break;
++			dmi_str_check(fw, table, addr, "Socket Designation", hdr, 0x4);
++			if (((GET_UINT16(data + 0x05) >> 5) & 0x0003) == 0x2)
++				fwts_failed(fw, LOG_LEVEL_HIGH, DMI_VALUE_OUT_OF_RANGE,
++					"Out of range value %x4.4" PRIx16 " "
++					"bits 5..6 set to illegal value 0x2, only allowed"
++					"0x0, 0x1, 0x3 while accessing entry '%s' @ "
++					"0x%8.8" PRIx32 ", field '%s', offset 0x%2.2x",
++					GET_UINT16(data + 0x05),
++					table, addr, "Cache Location", 0x5);
++			if (hdr->length < 0x13)
++				break;
++			dmi_min_max_uint8_check(fw, table, addr, "Error Correction Type", hdr, 0x10, 0x1, 0x6);
++			dmi_min_max_uint8_check(fw, table, addr, "System Cache Type", hdr, 0x11, 0x1, 0x5);
++			dmi_min_max_uint8_check(fw, table, addr, "Associativity", hdr, 0x12, 0x1, 0xe);
++			break;
++
++		case 8: /* 7.9 */
++			table = "Port Connector Information (Type 8)";
++			if (hdr->length < 0x09)
++				break;
++			dmi_str_check(fw, table, addr, "Internal Reference Designator", hdr, 0x4);
++			if (!((data[0x5] <= 0x22) ||
++			      (data[0x5] == 0xff) ||
++			      ((data[0x5] >= 0xa0) && (data[0x5] <= 0xa4))))
++				fwts_failed(fw, LOG_LEVEL_HIGH, DMI_VALUE_OUT_OF_RANGE,
++					"Out of range value 0x%2.2" PRIx8 " "
++					"(range allowed 0x00..0x22, 0xa0..0xa4, 0xff) "
++					"while accessing entry '%s' @ "
++					"0x%8.8" PRIx32 ", field '%s', offset 0x%2.2x",
++					data[0x5], table, addr, "Internal Connector Type", 0x5);
++			dmi_str_check(fw, table, addr, "External Reference Designator", hdr, 0x6);
++			if (!((data[0x7] <= 0x22) ||
++			      (data[0x7] == 0xff) ||
++			      ((data[0x7] >= 0xa0) && (data[0x7] <= 0xa4))))
++				fwts_failed(fw, LOG_LEVEL_HIGH, DMI_VALUE_OUT_OF_RANGE,
++					"Out of range value 0x%2.2" PRIx8 " "
++					"(range allowed 0x00..0x22, 0xa0..0xa4, 0xff) "
++					"while accessing entry '%s' @ "
++					"0x%8.8" PRIx32 ", field '%s', offset 0x%2.2x",
++					data[0x7], table, addr, "Internal Connector Type", 0x7);
++
++			if (!((data[0x8] <= 0x21) ||
++			      (data[0x8] == 0xff) ||
++			      ((data[0x8] >= 0xa0) && (data[0x8] <= 0xa1))))
++				fwts_failed(fw, LOG_LEVEL_HIGH, DMI_VALUE_OUT_OF_RANGE,
++					"Out of range value 0x%2.2" PRIx8 " "
++					"(range allowed 0x00..0x21, 0xa0..0xa1, 0xff) "
++					"while accessing entry '%s' @ 0x%8.8" PRIx32 ", "
++					"field '%s', offset 0x%2.2x",
++					data[0x8], table, addr, "Port Type", 0x8);
++			break;
++
++		case 9: /* 7.10 */
++			table = "System Slot Information (Type 9)";
++			if (hdr->length < 0x0c)
++				break;
++			dmi_str_check(fw, table, addr, "Slot Designation", hdr, 0x4);
++			if (!(((data[0x5] >= 0x01) && (data[0x5] <= 0x20)) ||
++			      ((data[0x5] >= 0xa0) && (data[0x5] <= 0xb6))))
++				fwts_failed(fw, LOG_LEVEL_HIGH, DMI_VALUE_OUT_OF_RANGE,
++					"Out of range value 0x%2.2x" PRIx8 " "
++					"(range allowed 0x01..0x08, 0xa0..0xa2) "
++					"while accessing entry '%s' @ 0x%8.8" PRIx32 ", "
++					"field '%s', offset 0x%2.2x",
++					data[0x5], table, addr, "Slot Type", 0x5);
++			dmi_min_max_uint8_check(fw, table, addr, "Slot Data Bus Width", hdr, 0x6, 0x1, 0xe);
++			dmi_min_max_uint8_check(fw, table, addr, "Current Usage", hdr, 0x7, 0x1, 0x4);
++			dmi_min_max_uint8_check(fw, table, addr, "Slot Length", hdr, 0x8, 0x1, 0x6);
++			if (hdr->length < 0x0d)
++				break;
++			if (data[0xc] & 0xf8)
++				fwts_failed(fw, LOG_LEVEL_MEDIUM, DMI_RESERVED_VALUE_USED,
++					"Reserved bits 0x%2.2" PRIx8 " was used"
++					"bits 3..7 would be reserved while accessing entry '%s' @ "
++					"0x%8.8" PRIx32 ", field '%s', offset 0x%2.2x",
++					data[0xc],
++					table, addr, "Slot Characteristics 2", 0xc);
++			break;
++
++		case 10: /* 7.11 */
++			table = "On Board Devices (Type 10)";
++			count = (hdr->length - 4) / 2;
++			for (i = 0; i < count; i++) {
++				snprintf(tmp, sizeof(tmp), "Type (Device #%d)", i);
++				dmi_min_max_mask_uint8_check(fw, table, addr, tmp, hdr, 4 + (2 * i), 0x1, 0xa, 0x0, 0x7f);
++				snprintf(tmp, sizeof(tmp), "Description (Device #%d)", i);
++				dmi_str_check(fw, table, addr, tmp, hdr, 5 + (2 * i));
++			}
++			break;
++
++		case 11: /* 7.12 */
++			table = "OEM Strings (Type 11)";
++			if (hdr->length < 0x5)
++				break;
++			for (i = 1; i <= hdr->data[4]; i++) {
++				snprintf(tmp, sizeof(tmp), "String %d", i);
++				dmi_str_check_index(fw, table, addr, tmp, hdr, 0x4, i);
++			}
++			break;
++
++		case 12: /* 7.13 */
++			table = "System Configuration Options (Type 12)";
++			if (hdr->length < 0x5)
++				break;
++			for (i = 1; i <= hdr->data[4]; i++) {
++				snprintf(tmp, sizeof(tmp), "Option %d", i);
++				dmi_str_check_index(fw, table, addr, tmp, hdr, 0x4, i);
++			}
++			break;
++
++		case 13: /* 7.14 */
++			table = "BIOS Language Information (Type 13)";
++			if (hdr->length < 0x16)
++				break;
++			for (i = 1; i <= hdr->data[4]; i++) {
++				snprintf(tmp, sizeof(tmp), "BIOS Language String %d", i);
++				dmi_str_check_index(fw, table, addr, tmp, hdr, 0x4, i);
++			}
++			dmi_str_check(fw, table, addr, "Currently Installed Language", hdr, 0x15);
++			break;
++
++		case 14: /* 7.15 */
++			table = "Group Associations (Type 14)";
++			if (hdr->length < 0x05)
++				break;
++			dmi_str_check(fw, table, addr, "Name", hdr, 0x4);
++			break;
++
++		case 15: /* 7.16 */
++			table = "System Event Log (Type 15)";
++			if (hdr->length < 0x14)
++				break;
++			val = hdr->data[0x0a];
++			if (!((val <= 0x04) || (val >= 0x80))) {
++				fwts_failed(fw, LOG_LEVEL_HIGH, DMI_VALUE_OUT_OF_RANGE,
++					"Out of range value 0x%2.2" PRIx8 " "
++					"(range allowed 0x00..0x01, "
++					"0x80..0xff) while accessing entry '%s' @ "
++					"0x%8.8" PRIx32 ", field '%s', offset 0x%2.2x",
++					val, table, addr, "Access Method", 0x0a);
++			}
++			if (hdr->length < 0x17)
++				break;
++			val = hdr->data[0x14];
++			if (!((val <= 0x01) || (val >= 0x80))) {
++				fwts_failed(fw, LOG_LEVEL_HIGH, DMI_VALUE_OUT_OF_RANGE,
++					"Out of range value 0x%2.2" PRIx8 " "
++					"(range allowed 0x00..0x01, "
++					"0x80..0xff) while accessing entry '%s' @ "
++					"0x%8.8" PRIx32 ", field '%s', offset 0x%2.2x",
++					val, table, addr, "Log Header Format", 0x14);
++			}
++			if (hdr->length < 0x17 + data[0x15] * data[0x16])
++				break;
++			if (data[0x16] >= 0x02) {
++				uint8_t *tmpptr = data + 0x17;
++				int k;
++				for (k = 0; k < data[0x15]; k++) {
++					int j = data[0x16] * k;
++					val = tmpptr[j];
++					if (!(((val >= 0x01) && (val <= 0x0e)) ||
++					      ((val >= 0x10) && (val <= 0x17)) ||
++					      (val >= 0x80))) {
++						fwts_failed(fw, LOG_LEVEL_HIGH, DMI_VALUE_OUT_OF_RANGE,
++							"Out of range value 0x%2.2" PRIx8 " "
++							"(range allowed 0x01..0x0e, 0x10..0x17, "
++							"0x80..0xff) while accessing entry '%s' @ "
++							"0x%8.8" PRIx32 ", field '%s', item %d",
++							val, table, addr, "Log Descriptor Type", k);
++					}
++					val = tmpptr[j + 1];
++					if ((val > 0x06) && (val < 0x80)) {
++						fwts_failed(fw, LOG_LEVEL_HIGH, DMI_VALUE_OUT_OF_RANGE,
++							"Out of range value 0x%2.2" PRIx8 " "
++							"(range allowed 0x00..0x06, 0x80..0xff) "
++							"while accessing entry '%s' @ "
++							"0x%8.8" PRIx32 ", field '%s', item %d",
++							val, table, addr, "Log Descriptor Format", k);
++					}
++				}
++			}
++			break;
++
++		case 16: /* 7.17 */
++			table = "Physical Memory Array (Type 16)";
++			if (hdr->length < 0x0f)
++				break;
++			if (!(((data[0x4] >= 0x01) && (data[0x4] <= 0x0a)) ||
++			      ((data[0x4] >= 0xa0) && (data[0x4] <= 0xa3))))
++				fwts_failed(fw, LOG_LEVEL_HIGH, DMI_VALUE_OUT_OF_RANGE,
++					"Out of range value 0x%2.2" PRIx8 " "
++					"(range allowed 0x01..0x0a, 0xa0..0xa3) "
++					"while accessing entry '%s' @ "
++					"0x%8.8" PRIx32 ", field '%s', offset 0x%2.2x",
++					data[0x4], table, addr, "Location", 0x4);
++			dmi_min_max_uint8_check(fw, table, addr, "Use", hdr, 0x5, 0x1, 0x7);
++			dmi_min_max_uint8_check(fw, table, addr, "Error Corrrection Type", hdr, 0x6, 0x1, 0x7);
++			break;
++
++		case 17: /* 7.18 */
++			table = "Memory Device (Type 17)";
++			if (hdr->length < 0x15)
++				break;
++			dmi_min_max_uint8_check(fw, table, addr, "Form Factor", hdr, 0xe, 0x1, 0xf);
++			dmi_str_check(fw, table, addr, "Locator", hdr, 0x10);
++			dmi_str_check(fw, table, addr, "Bank Locator", hdr, 0x11);
++			dmi_min_max_uint8_check(fw, table, addr, "Memory Type", hdr, 0x12, 0x1, 0x1e);
++			if (hdr->length < 0x1b)
++				break;
++			dmi_str_check(fw, table, addr, "Manufacturer", hdr, 0x17);
++			dmi_str_check(fw, table, addr, "Serial Number", hdr, 0x18);
++			dmi_str_check(fw, table, addr, "Asset Tag", hdr, 0x19);
++			dmi_str_check(fw, table, addr, "Part Number", hdr, 0x1a);
++			break;
++
++		case 18: /* 7.19 */
++			table = "32-bit Memory Error Information (Type 18)";
++			if (hdr->length < 0x17)
++				break;
++			dmi_min_max_uint8_check(fw, table, addr, "Error Type", hdr, 0x4, 0x1, 0xe);
++			dmi_min_max_uint8_check(fw, table, addr, "Error Granularity", hdr, 0x5, 0x1, 0x4);
++			dmi_min_max_uint8_check(fw, table, addr, "Error Operation", hdr, 0x6, 0x1, 0x5);
++			break;
++
++		case 19: /* 7.20 */
++			table = "Memory Array Mapped Address (Type 19)";
++			if (hdr->length < 0x0F)
++				break;
++			if (hdr->length >= 0x1F && GET_UINT32(data + 0x04) == 0xFFFFFFFF) {
++				uint64_t start, end;
++				start = GET_UINT64(data + 0x0F);
++				end = GET_UINT64(data + 0x17);
++				if (start == end)
++					fwts_failed(fw, LOG_LEVEL_HIGH, DMI_ILLEGAL_MAPPED_ADDR_RANGE,
++						"Extended Start and End addresses are identical "
++						"while accessing entry '%s' @ 0x%8.8" PRIx32 ", "
++						"fields 'Extended Starting Address' and 'Extended Ending Address'",
++						table, addr);
++			} else {
++				if (GET_UINT32(data + 0x08) - GET_UINT32(data + 0x04) + 1 == 0)
++					fwts_failed(fw, LOG_LEVEL_HIGH, DMI_ILLEGAL_MAPPED_ADDR_RANGE,
++						"Illegal zero mapped address range "
++						"for entry '%s' @ 0x%8.8" PRIx32, table, addr);
++			}
++			break;
++
++		case 20: /* 7.21 */
++			table = "Memory Device Mapped Address (Type 20)";
++			if (hdr->length < 0x13)
++				break;
++			if (hdr->length >= 0x23 && GET_UINT32(data + 0x04) == 0xFFFFFFFF) {
++				uint64_t start, end;
++				start = GET_UINT64(data + 0x13);
++				end = GET_UINT64(data + 0x1B);
++				if (start == end)
++					fwts_failed(fw, LOG_LEVEL_HIGH, DMI_ILLEGAL_MAPPED_ADDR_RANGE,
++						"Extended Start and End addresses are identical "
++						"while accessing entry '%s' @ 0x%8.8" PRIx32 ", "
++						"fields 'Extended Starting Address' and 'Extended Ending Address'",
++						table, addr);
++			} else {
++				if (GET_UINT32(data + 0x08) - GET_UINT32(data + 0x04) + 1 == 0)
++					fwts_failed(fw, LOG_LEVEL_HIGH, DMI_ILLEGAL_MAPPED_ADDR_RANGE,
++						"Illegal zero mapped address range "
++						"for entry '%s' @ 0x%8.8" PRIx32, table, addr);
++			}
++			if (data[0x10] == 0)
++				fwts_failed(fw, LOG_LEVEL_HIGH, DMI_ILLEGAL_MAPPED_ADDR_RANGE,
++					"Illegal row position %2.2" PRIx8 ", "
++					"while accessing entry '%s' @ 0x%8.8" PRIx32
++					", field '%s', offset 0x%2.2x",
++					data[0x10], table, addr, "Partial Row Position", 0x10);
++			break;
++
++		case 21: /* 7.22 */
++			table = "Built-in Pointing Device (Type 21)";
++			if (hdr->length < 0x07)
++				break;
++			dmi_min_max_uint8_check(fw, table, addr, "Type", hdr, 0x4, 0x1, 0x9);
++			if (!(((data[0x5] >= 0x01) && (data[0x5] <= 0x08)) ||
++			      ((data[0x5] >= 0xa0) && (data[0x5] <= 0xa2)))) {
++				fwts_failed(fw, LOG_LEVEL_HIGH, DMI_VALUE_OUT_OF_RANGE,
++					"Out of range value 0x%2.2" PRIx8 " "
++					"(range allowed 0x01..0x08, 0xa0..0xa2) "
++					"while accessing '%s', field '%s', offset 0x%2.2x",
++					data[0x5], table, "Interface", 0x5);
++			}
++			break;
++
++		case 22: /* 7.23 */
++			table = "Portable Battery (Type 22)";
++			if (hdr->length < 0x10)
++				break;
++			dmi_str_check(fw, table, addr, "Location", hdr, 0x4);
++			dmi_str_check(fw, table, addr, "Manufacturer", hdr, 0x5);
++			if (data[0x06] || hdr->length < 0x1A)
++				dmi_str_check(fw, table, addr, "Manufacturer Date", hdr, 0x6);
++			if (data[0x07] || hdr->length < 0x1A)
++				dmi_str_check(fw, table, addr, "Serial Number", hdr, 0x7);
++			dmi_str_check(fw, table, addr, "Device Name", hdr, 0x8);
++			if (data[0x09] != 0x02 || hdr->length < 0x1A)
++				dmi_str_check(fw, table, addr, "Device Chemistry", hdr, 0x9);
++
++			dmi_str_check(fw, table, addr, "SBDS Version Number", hdr, 0xe);
++			if (hdr->length < 0x1A)
++				break;
++			if (data[0x09] == 0x02)
++				dmi_str_check(fw, table, addr, "SBDS Device Chemistry", hdr, 0x14);
++
++			ret = fwts_battery_get_count(fw, &battery_count);
++			if (ret != FWTS_OK || battery_count < 1) {
++				fwts_failed(fw, LOG_LEVEL_MEDIUM, DMI_INVALID_HARDWARE_ENTRY,
++					"Invalid Hardware Configuration "
++					"(no battery found) ");
++			}
++			break;
++		case 23: /* 7.24 */
++			table = "System Reset (Type 23)";
++			if (hdr->length < 0x0D)
++				break;
++			if (!(data[0x04] & (1 << 5)))
++				break;
++			dmi_min_max_mask_uint8_check(fw, table, addr, "Capabilities (bits 1..2)", hdr, 0x4, 0x1, 0x3, 1, 0x3);
++			dmi_min_max_mask_uint8_check(fw, table, addr, "Capabilities (bits 3..4)", hdr, 0x4, 0x1, 0x3, 3, 0x3);
++			break;
++
++		case 24: /* 7.25 */
++			table = "Hardware Security (Type 24)";
++			/* if (hdr->length < 0x05)
++				break; */
++			break;
++
++		case 25: /* 7.26 */
++			table = "System Power Controls (Type 25)";
++			/* if (hdr->length < 0x9)
++				break; */
++			break;
++
++		case 26: /* 7.27 */
++			table = "Voltage Probe (Type 26)";
++			if (hdr->length < 0x14)
++				break;
++			dmi_str_check(fw, table, addr, "Description", hdr, 0x4);
++			dmi_min_max_mask_uint8_check(fw, table, addr, "Location (bits 0..4)", hdr, 0x5, 0x1, 0xb, 0, 0x1f);
++			dmi_min_max_mask_uint8_check(fw, table, addr, "Status (bits 5..7)", hdr, 0x5, 0x1, 0x6, 5, 0x7);
++			break;
++
++		case 27: /* 7.28 */
++			table = "Cooling Device (Type 27)";
++			if (hdr->length < 0xc)
++				break;
++			val = data[0x06] & 0x1f;
++			if (!(((val >= 0x01) && (val <= 0x09)) ||
++			      ((val >= 0x10) && (val <= 0x11))))
++				fwts_failed(fw, LOG_LEVEL_HIGH, DMI_VALUE_OUT_OF_RANGE,
++					"Out of range value 0x%2.2" PRIx8 " "
++					"(range allowed 0x01..0x09, 0x10..0x11) "
++					"while accessing entry '%s' @ "
++					"0x%8.8" PRIx32 ", field '%s', "
++					"offset 0x%2.2x, mask 0x%2.2x",
++					data[0x6], table, addr, "Device Type", 0x6, 0x1f);
++			dmi_min_max_mask_uint8_check(fw, table, addr, "Status (bits 5..7)", hdr, 0x6, 0x1, 0x6, 5, 0x7);
++			if (hdr->length < 0x0f)
++				break;
++			dmi_str_check(fw, table, addr, "Description", hdr, 0xe);
++			break;
++
++		case 28: /* 7.29 */
++			table = "Temperature Probe (Type 28)";
++			if (hdr->length < 0x14)
++				break;
++			dmi_str_check(fw, table, addr, "Description", hdr, 0x4);
++			dmi_min_max_mask_uint8_check(fw, table, addr, "Location (bits 0..4)", hdr, 0x5, 0x1, 0xf, 0, 0x1f);
++			dmi_min_max_mask_uint8_check(fw, table, addr, "Status (bits 5..7)", hdr, 0x5, 0x1, 0x6, 5, 0x7);
++			break;
++
++		case 29: /* 7.30 */
++			table = "Electrical Current Probe (Type 29)";
++			if (hdr->length < 0x14)
++				break;
++			dmi_str_check(fw, table, addr, "Description", hdr, 0x4);
++			dmi_min_max_mask_uint8_check(fw, table, addr, "Location (bits 0..4)", hdr, 0x5, 0x1, 0xb, 0, 0x1f);
++			dmi_min_max_mask_uint8_check(fw, table, addr, "Status (bits 5..7)", hdr, 0x5, 0x1, 0x6, 5, 0x7);
++			break;
++
++		case 30: /* 7.31 */
++			table = "Out-of-band Remote Access (Type 30)";
++			if (hdr->length < 0x06)
++				break;
++			dmi_str_check(fw, table, addr, "Manufacturer Name", hdr, 0x4);
++			break;
++
++		case 31: /* 7.32 */
++			table = "Boot Integrity Services Entry Point (Type 31)";
++			/*
++			if (hdr->length < 0x1c)
++				break;
++			*/
++			break;
++
++		case 32: /* 7.33 */
++			table = "System Boot Information (Type 32)";
++			if (hdr->length < 0xb)
++				break;
++			if ((data[0xa] > 0x8) && (data[0xa] < 128))
++				fwts_failed(fw, LOG_LEVEL_HIGH, DMI_VALUE_OUT_OF_RANGE,
++					"Out of range value 0x%2.2" PRIx8 " "
++					"(range allowed 0x00..0x08, 0x80..0xff) "
++					"while accessing entry '%s' @ "
++					"0x%8.8" PRIx32 ", field '%s', offset 0x%2.2x",
++					data[0xa], table, addr, "Boot Status", 0xa);
++			break;
++
++		case 33: /* 7.34 */
++			table = "64-bit Memory Error Information (Type 33)";
++			if (hdr->length < 0x1f)
++				break;
++			dmi_min_max_uint8_check(fw, table, addr, "Error Type", hdr, 0x4, 0x1, 0xe);
++			dmi_min_max_uint8_check(fw, table, addr, "Error Granularity", hdr, 0x5, 0x1, 0x4);
++			dmi_min_max_uint8_check(fw, table, addr, "Error Operation", hdr, 0x6, 0x1, 0x5);
++			break;
++
++		case 34: /* 7.35 */
++			table = "Management Device (Type 34)";
++			if (hdr->length < 0x0b)
++				break;
++			dmi_str_check(fw, table, addr, "Description", hdr, 0x4);
++			dmi_min_max_uint8_check(fw, table, addr, "Type", hdr, 0x5, 0x1, 0xd);
++			dmi_min_max_uint8_check(fw, table, addr, "Address Type", hdr, 0xa, 0x1, 0x5);
++			break;
++
++		case 35: /* 7.36 */
++			table = "Management Device Component (Type 35)";
++			if (hdr->length < 0x0b)
++				break;
++			dmi_str_check(fw, table, addr, "Description", hdr, 0x4);
++			break;
++
++		case 36: /* 7.37 */
++			table = "Management Device Threshold Data (Type 36)";
++			/*
++			if (hdr->length < 0x10)
++				break;
++			*/
++			break;
++
++		case 37: /* 7.38 */
++			table = "Memory Channel (Type 37)";
++			if (hdr->length < 0x07)
++				break;
++			dmi_min_max_uint8_check(fw, table, addr, "Type", hdr, 0x4, 0x1, 0x4);
++			break;
++
++		case 38: /* 7.39 */
++			table = "IPMI Device Information (Type 38)";
++			dmi_min_max_uint8_check(fw, table, addr, "Interface Type", hdr, 0x4, 0x0, 0x3);
++			break;
++
++		case 39: /* 7.40 */
++			table = "System Power Supply (Type 39)";
++			if (hdr->length < 0x10)
++				break;
++			dmi_str_check(fw, table, addr, "Location", hdr, 0x5);
++			dmi_str_check(fw, table, addr, "Device Name", hdr, 0x6);
++			dmi_str_check(fw, table, addr, "Manufacturer", hdr, 0x7);
++			dmi_str_check(fw, table, addr, "Serial Number", hdr, 0x8);
++			dmi_str_check(fw, table, addr, "Asset Tag", hdr, 0x9);
++			dmi_str_check(fw, table, addr, "Model Part Number", hdr, 0xa);
++			dmi_str_check(fw, table, addr, "Revision Level", hdr, 0xb);
++			break;
++
++		case 40: /* 7.41 */
++			table = "Additional Information (Type 40)";
++			break;
++
++		case 41: /* 7.42 */
++			table = "Onboard Device (Type 41)";
++			if (hdr->length < 0xb)
++				break;
++			dmi_str_check(fw, table, addr, "Reference Designation", hdr, 0x4);
++			dmi_min_max_mask_uint8_check(fw, table, addr, "Device Type", hdr, 0x5, 0x1, 0xa, 0, 0x7f);
++			break;
++
++		case 42: /* 7.43 */
++			table = "Management Controller Host Interface (Type 42)";
++			if (hdr->length < 0x05)
++				break;
++			if (!((data[0x04] >= 0x02 && data[0x04] <= 0x08) ||
++			      (data[0x04] == 0xF0)))
++				fwts_failed(fw, LOG_LEVEL_MEDIUM, DMI_MGMT_CTRL_HOST_TYPE,
++					"Out of range value 0x%2.2" PRIx8 " "
++					"(range allowed 0x02..0x08, 0xf0) "
++					"while accessing entry '%s' @ "
++					"0x%8.8" PRIx32 ", field '%s', offset 0x%2.2x",
++					data[0x4], table, addr, "Reference Designation", 0x4);
++			break;
++
++		case 126: /* 7.44 */
++			table = "Inactive (Type 126)";
++			break;
++		case SMBIOS_END_OF_TABLE: /* 7.45 */
++			table = "End of Table (Type 127)";
++			break;
++		default:
++			snprintf(tmp, sizeof(tmp), "Unknown (Type %" PRId8 ")", hdr->type);
++			table = tmp;
++			break;
++	}
++	if (fw->minor_tests.failed == failed_count)
++		fwts_passed(fw, "Entry @ 0x%8.8" PRIx32 " '%s'", addr, table);
++	else if (!advice_given && hdr->type <= 42)
++		fwts_advice(fw,
++			"It may be worth checking against section 7.%" PRId8 " of the "
++			"System Management BIOS (SMBIOS) Reference Specification "
++			"(see http://www.dmtf.org/standards/smbios).", hdr->type+1);
++}
++
++static void dmi_scan_smbios30_table(fwts_framework *fw,
++	fwts_smbios30_entry *entry,
++	uint8_t  *table)
++{
++	uint8_t *entry_data = table;
++	uint16_t table_max_length;
++	int i = 0;
++
++	table_max_length = entry->struct_table_max_size;
++
++	for (i = 0; entry_data <= (table + table_max_length - 4); i++) {
++		uint64_t addr = entry->struct_table_address + (entry_data - table);
++		fwts_dmi_header hdr;
++		uint8_t *next_entry;
++
++		hdr.type   = entry_data[0];
++		hdr.length = entry_data[1];
++		hdr.handle = GET_UINT16(entry_data + 2);
++		hdr.data   = entry_data;
++
++		/* We found DMI end of table */
++		if (hdr.type == SMBIOS_END_OF_TABLE)
++			break;
++
++		/* Sanity check */
++		if (hdr.length < 4) {
++			fwts_failed(fw, LOG_LEVEL_HIGH, DMI_INVALID_ENTRY_LENGTH,
++				"Invald header length of entry #%d, "
++				"length was 0x%2.2" PRIx8 ".",
++				i, hdr.length);
++			fwts_advice(fw,
++				"DMI entry header lengths must be 4 or more bytes long "
++				"so this error indicates that the DMI table is unreliable "
++				"and DMI table checking has been aborted at entry #%d.", i);
++			break;
++		}
++
++		/* Real Physical Address */
++		next_entry = entry_data + hdr.length;
++
++		/* Look for structure terminator, ends in two zero bytes */
++		while (((next_entry - table + 1) < table_max_length) &&
++		       ((next_entry[0] != 0) || (next_entry[1] != 0))) {
++			next_entry++;
++		}
++
++		/* Skip over terminating two zero bytes, see section 6.1 of spec */
++		next_entry += 2;
++
++		if ((next_entry - table) <= table_max_length)
++			dmicheck_entry(fw, addr, &hdr);
++		else {
++			fwts_failed(fw, LOG_LEVEL_HIGH, DMI_BAD_TABLE_LENGTH,
++				"DMI table maximum size was %" PRId32 " bytes (as specified by "
++				"the SMBIOS 3.0 header) but the DMI entries over the maximum "
++				"length without finding the End-of-Table(Type 127).",
++				table_max_length);
++			break;
++		}
++
++		entry_data = next_entry;
++	}
++
++}
++
++static int sbbr_dmicheck_consistency_test(fwts_framework *fw)
++{
++	void *addr;
++	fwts_smbios30_entry entry30;
++	uint16_t version = 0;
++	uint8_t  *table;
++
++	if (!smbios30_found) {
++		fwts_skipped(fw, "Cannot find SMBIOS30 table entry, skip the test.");
++		return FWTS_SKIP;
++	}
++
++	addr = fwts_smbios30_find_entry(fw, &entry30, &version);
++	if (addr == NULL) {
++		fwts_failed(fw, LOG_LEVEL_HIGH, DMI_NO_TABLE_HEADER,
++			"Cannot find SMBIOS 3.0 table entry.");
++		return FWTS_ERROR;
++	}
++
++	table = dmi_table_smbios30(fw, &entry30);
++	if (table == NULL)
++		return FWTS_ERROR;
++
++	dmi_scan_smbios30_table(fw, &entry30, table);
++
++	dmi_table_free(table);
++
++	return FWTS_OK;
++}
++
++/*
++ * ARM SBBR SMBIOS Structure Test
++ */
++
++/* Test Entry Structure */
++typedef struct {
++	const char *name;
++	const uint8_t type;
++} sbbr_test_entry;
++
++/* Test Definition Array */
++sbbr_test_entry sbbr_test[] = {
++	{"BIOS Information", 0},
++	{"System Information", 1},
++	{"Baseboard Information", 2},
++	{"System Enclosure or Chassis", 3},
++	{"Processor Information", 4},
++	{"Cache Information", 7},
++	{"Port Connector Information", 8},
++	{"System Slots", 9},
++	{"OEM Strings", 11},
++	{"BIOS Language Information", 13},
++	{"System Event Log", 15},
++	{"Physical Memory Array", 16},
++	{"Memory Device", 17},
++	{"Memory Array Mapped Address", 19},
++	{"System Boot Information", 32},
++	{"IPMI Device Information", 38},
++	{"Onboard Devices Extended Information", 41},
++	{0, 0}
++};
++
++/* Finds SMBIOS structure of a given type in an SMBIOS30 table. */
++static uint8_t * sbbr_smbios30_locate_structure (uint8_t *table, const int table_max_length, uint8_t type)
++{
++	uint8_t *entry_data;
++	fwts_dmi_header *hdr;
++
++
++	entry_data = table;
++    while ( (entry_data != NULL) &&
++    		(entry_data < (table + table_max_length)) )
++    {
++    	hdr = (fwts_dmi_header *)(entry_data);
++
++		/* We found the entry we're looking for. */
++		if (hdr->type == type)
++			return hdr->data;
++
++		/* We found DMI end of table */
++		if (hdr->type == SMBIOS_END_OF_TABLE)
++			return NULL;
++
++		entry_data = entry_data + hdr->length;
++
++		while( *((int *)(entry_data)) != 0)
++		{
++			entry_data++;
++
++		}
++		entry_data += 2; /* Increment address to start of next structure */
++
++	}
++
++
++	return NULL;
++}
++
++/* SBBR SMBIOS structure test function. */
++static int sbbr_smbios30_test(fwts_framework *fw)
++{
++	fwts_smbios30_entry entry30;
++	fwts_dmi_header hdr;
++	uint16_t version;
++	void *addr;
++	uint32_t i;
++	uint8_t *table;
++
++	/* Finding SMBIOS30 entry point. */
++	addr = fwts_smbios30_find_entry(fw, &entry30, &version);
++	if (addr == NULL) {
++		fwts_failed(fw, LOG_LEVEL_HIGH, "SbbrSmbiosNoTable", "Cannot find SMBIOS30 table "
++		            "entry.");
++		return FWTS_ERROR;
++	}
++
++	/* Getting SMBIOS table contents. */
++	table = dmi_table_smbios30(fw, &entry30);
++	if (table == NULL)
++		return FWTS_ERROR;
++
++	/* Searching for each SMBIOS structure needed by SBBR. */
++	for (i = 0; sbbr_test[i].name != NULL; i++) {
++
++		hdr.data = sbbr_smbios30_locate_structure (table, entry30.struct_table_max_size, sbbr_test[i].type);
++
++		if (hdr.data != NULL)
++			dmicheck_entry(fw, (uintptr_t)hdr.data, &hdr);
++		else
++			fwts_failed(fw, LOG_LEVEL_HIGH, "SbbrSmbiosNoStruct", "Cannot find SMBIOS "
++			            "structure: %s (Type %d)", sbbr_test[i].name, sbbr_test[i].type);
++	}
++
++	dmi_table_free(table);
++
++	return FWTS_OK;
++}
++
++static fwts_framework_minor_test sbbr_dmicheck_tests[] = {
++	{ sbbr_dmicheck_revision_test, "Find and test SMBIOS Table Entry Points." },
++	{ sbbr_dmicheck_consistency_test, "Test DMI/SMBIOS3 tables for errors." },
++	{ sbbr_smbios30_test, "Test ARM SBBR SMBIOS structure requirements."},
++	{ NULL, NULL }
++};
++
++static fwts_framework_ops sbbr_dmicheck_ops = {
++	.description = "DMI/SMBIOS table tests.",
++	.minor_tests = sbbr_dmicheck_tests
++};
++
++FWTS_REGISTER("sbbr_dmicheck", &sbbr_dmicheck_ops, FWTS_TEST_ANYTIME, FWTS_FLAG_TEST_SBBR)
++
++#endif
+diff --git a/src/sbbr/fadt/fadt.c b/src/sbbr/fadt/fadt.c
+new file mode 100644
+index 0000000..82645e8
+--- /dev/null
++++ b/src/sbbr/fadt/fadt.c
+@@ -0,0 +1,417 @@
++/*
++ * Copyright (C) 2010-2017 Canonical
++ * Copyright (C) 2017 ARM Ltd
++ * Portions of this code original from the Linux-ready Firmware Developer Kit
++ *
++ * This program is free software; you can redistribute it and/or
++ * modify it under the terms of the GNU General Public License
++ * as published by the Free Software Foundation; either version 2
++ * of the License, or (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
++ *
++ */
++#include "fwts.h"
++
++#if defined(FWTS_HAS_SBBR)
++
++#include "fwts_acpi_object_eval.h"
++
++#include <stdio.h>
++#include <stdlib.h>
++#include <sys/types.h>
++#include <sys/stat.h>
++#include <unistd.h>
++#include <inttypes.h>
++#include <string.h>
++
++static const fwts_acpi_table_fadt *fadt;
++static int fadt_size;
++
++static int sbbr_fadt_init(fwts_framework *fw)
++{
++	fwts_acpi_table_info *table;
++
++	if (fwts_acpi_find_table(fw, "FACP", 0, &table) != FWTS_OK) {
++		fwts_log_error(fw, "Cannot read ACPI table FACP.");
++		return FWTS_ERROR;
++	}
++	if (table == NULL) {
++		fwts_log_error(fw, "ACPI table FACP does not exist!");
++		return FWTS_ERROR;
++	}
++	fadt = (const fwts_acpi_table_fadt *)table->data;
++	fadt_size = table->length;
++
++	/*  Not having a FADT is a failure on ARM SBBR Architecture */
++	if (fadt_size == 0) {
++    	fwts_log_error(fw, "ACPI table FACP has zero length!");
++		return FWTS_ERROR;
++	}
++
++	return FWTS_OK;
++}
++
++static int sbbr_fadt_revision_test1(fwts_framework *fw)
++{
++	const uint8_t SBBR_LATEST_MAJOR = 6;
++	const uint8_t SBBR_LATEST_MINOR = 0;
++	uint8_t major;
++	uint8_t minor;
++
++	major = fadt->header.revision;
++	minor = 0;
++	if (major >= 5 && fadt->header.length >= 268)
++		minor = fadt->minor_version;   /* field added ACPI 5.1 */
++
++	fwts_log_info(fw, "FADT revision: %d.%d", major, minor);
++
++	if (major >= SBBR_LATEST_MAJOR && minor >= SBBR_LATEST_MINOR)
++		fwts_passed(fw, "FADT revision is up to date.");
++	else {
++		fwts_failed(fw, LOG_LEVEL_CRITICAL, "fadt_revision:", "FADT revision is outdated: %d.%d",
++			     major, minor);
++	}
++
++	return FWTS_OK;
++}
++
++static int sbbr_fadt_reduced_hw_test2(fwts_framework *fw)
++{
++	bool rhw;
++	bool passed;
++	static const fwts_acpi_gas null_gas;
++	uint32_t flag_mask;
++
++	rhw = fwts_acpi_is_reduced_hardware(fadt);
++	if (rhw == 0)
++		fwts_failed(fw, LOG_LEVEL_CRITICAL, "fadt_reduced_hw:", "FADT indicates ACPI is not in reduced hardware mode.");
++	else
++		fwts_passed(fw, "FADT indicates ACPI is in reduced hardware mode.");
++
++
++	if (!rhw)
++		return FWTS_OK;
++
++	passed = true;
++
++	/* check all the fields that will be ignored */
++	/* if the HW_REDUCED_ACPI flag in the table is set,
++	   OSPM will ignore fields related to the ACPI HW register interface:
++	   Fields at offsets 46 through 108 and 148 through 232, as well as
++	   FADT Flag bits 1, 2, 3,7,8,12,13, 14, 16 and 17 */
++
++	if (fadt->sci_int != 0) {
++		passed = false;
++		fwts_log_warning(fw, "SCI_INT is non-zero: 0x%x",
++			      fadt->smi_cmd);
++	}
++	if (fadt->smi_cmd != 0) {
++		passed = false;
++		fwts_log_warning(fw, "SMI_CMD is non-zero: 0x%x",
++			      fadt->smi_cmd);
++	}
++	if (fadt->acpi_enable != 0) {
++		passed = false;
++		fwts_log_warning(fw, "ACPI_ENABLE is non-zero: 0x%x",
++			      fadt->acpi_enable);
++	}
++	if (fadt->acpi_disable != 0) {
++		passed = false;
++		fwts_log_warning(fw, "ACPI_DISABLE is non-zero: 0x%x",
++			      fadt->acpi_disable);
++	}
++	if (fadt->s4bios_req != 0) {
++		passed = false;
++		fwts_log_warning(fw, "S4BIOS_REQ is non-zero: 0x%x",
++			      fadt->s4bios_req);
++	}
++	if (fadt->pstate_cnt != 0) {
++		passed = false;
++		fwts_log_warning(fw, "PSTATE_CNT is non-zero: 0x%x",
++			      fadt->pstate_cnt);
++	}
++	if (fadt->pm1a_evt_blk != 0) {
++		passed = false;
++		fwts_log_warning(fw, "PM1A_EVT_BLK is non-zero: 0x%x",
++			      fadt->pm1a_evt_blk);
++	}
++	if (fadt->pm1b_evt_blk != 0) {
++		passed = false;
++		fwts_log_warning(fw, "PM1B_EVT_BLK is non-zero: 0x%x",
++			      fadt->pm1b_evt_blk);
++	}
++	if (fadt->pm1a_cnt_blk != 0) {
++		passed = false;
++		fwts_log_warning(fw, "PM1A_CNT_BLK is non-zero: 0x%x",
++			      fadt->pm1a_cnt_blk);
++	}
++	if (fadt->pm1b_cnt_blk != 0) {
++		passed = false;
++		fwts_log_warning(fw, "PM1B_CNT_BLK is non-zero: 0x%x",
++			      fadt->pm1b_cnt_blk);
++	}
++	if (fadt->pm2_cnt_blk != 0) {
++		passed = false;
++		fwts_log_warning(fw, "PM2_CNT_BLK is non-zero: 0x%x",
++			      fadt->pm2_cnt_blk);
++	}
++	if (fadt->pm_tmr_blk != 0) {
++		passed = false;
++		fwts_log_warning(fw, "PM_TMR_BLK is non-zero: 0x%x",
++			      fadt->pm_tmr_blk);
++	}
++	if (fadt->gpe0_blk != 0) {
++		passed = false;
++		fwts_log_warning(fw, "GPE0_BLK is non-zero: 0x%x",
++			      fadt->gpe0_blk);
++	}
++	if (fadt->gpe1_blk != 0) {
++		passed = false;
++		fwts_log_warning(fw, "GPE1_BLK is non-zero: 0x%x",
++			      fadt->gpe1_blk);
++	}
++	if (fadt->pm1_evt_len != 0) {
++		passed = false;
++		fwts_log_warning(fw, "PM1_EVT_LEN is non-zero: 0x%x",
++			      fadt->pm1_evt_len);
++	}
++	if (fadt->pm1_cnt_len != 0) {
++		passed = false;
++		fwts_log_warning(fw, "PM1_CNT_LEN is non-zero: 0x%x",
++			      fadt->pm1_cnt_len);
++	}
++	if (fadt->pm2_cnt_len != 0) {
++		passed = false;
++		fwts_log_warning(fw, "PM2_CNT_LEN is non-zero: 0x%x",
++			      fadt->pm2_cnt_len);
++	}
++	if (fadt->pm_tmr_len != 0) {
++		passed = false;
++		fwts_log_warning(fw, "PM_TMR_LEN is non-zero: 0x%x",
++			      fadt->pm_tmr_len);
++	}
++	if (fadt->gpe0_blk_len != 0) {
++		passed = false;
++		fwts_log_warning(fw, "GPE0_BLK_LEN is non-zero: 0x%x",
++			      fadt->gpe0_blk_len);
++	}
++	if (fadt->gpe1_blk_len != 0) {
++		passed = false;
++		fwts_log_warning(fw, "GPE1_BLK_LEN is non-zero: 0x%x",
++			      fadt->gpe1_blk_len);
++	}
++	if (fadt->gpe1_base != 0) {
++		passed = false;
++		fwts_log_warning(fw, "GPE1_BASE is non-zero: 0x%x",
++			      fadt->gpe1_base);
++	}
++	if (fadt->cst_cnt != 0) {
++		passed = false;
++		fwts_log_warning(fw, "CST_CNT is non-zero: 0x%x",
++			      fadt->cst_cnt);
++	}
++	if (fadt->p_lvl2_lat != 0) {
++		passed = false;
++		fwts_log_warning(fw, "P_LVL2_LAT is non-zero: 0x%x",
++			      fadt->p_lvl2_lat);
++	}
++	if (fadt->p_lvl3_lat != 0) {
++		passed = false;
++		fwts_log_warning(fw, "P_LVL3_LAT is non-zero: 0x%x",
++			      fadt->p_lvl3_lat);
++	}
++	if (fadt->flush_size != 0) {
++		passed = false;
++		fwts_log_warning(fw, "FLUSH_SIZE is non-zero: 0x%x",
++			      fadt->flush_size);
++	}
++	if (fadt->flush_stride != 0) {
++		passed = false;
++		fwts_log_warning(fw, "FLUSH_STRIDE is non-zero: 0x%x",
++			      fadt->flush_stride);
++	}
++	if (fadt->duty_offset != 0) {
++		passed = false;
++		fwts_log_warning(fw, "DUTY_OFFSET is non-zero: 0x%x",
++			      fadt->duty_offset);
++	}
++	if (fadt->duty_width != 0) {
++		passed = false;
++		fwts_log_warning(fw, "DUTY_WIDTH is non-zero: 0x%x",
++			      fadt->duty_width);
++	}
++	if (fadt->day_alrm != 0) {
++		passed = false;
++		fwts_log_warning(fw, "DAY_ALRM is non-zero: 0x%x",
++			      fadt->day_alrm);
++	}
++	if (fadt->mon_alrm != 0) {
++		passed = false;
++		fwts_log_warning(fw, "MON_ALRM is non-zero: 0x%x",
++			      fadt->mon_alrm);
++	}
++	if (fadt->century != 0) {
++		passed = false;
++		fwts_log_warning(fw, "CENTURY is non-zero: 0x%x",
++			      fadt->century);
++	}
++	if (memcmp((void *)&fadt->x_pm1a_evt_blk,
++		   (void *)&null_gas,
++		   sizeof(fwts_acpi_gas))) {
++		passed = false;
++		fwts_log_warning(fw,
++			      "X_PM1A_EVT_BLK is a non-zero general "
++			      "address structure.");
++	}
++	if (memcmp((void *)&fadt->x_pm1b_evt_blk,
++		   (void *)&null_gas,
++		   sizeof(fwts_acpi_gas))) {
++		passed = false;
++		fwts_log_warning(fw,
++			      "X_PM1B_EVT_BLK is a non-zero general "
++			      "address structure.");
++	}
++	if (memcmp((void *)&fadt->x_pm1a_cnt_blk,
++		   (void *)&null_gas,
++		   sizeof(fwts_acpi_gas))) {
++		passed = false;
++		fwts_log_warning(fw,
++			      "X_PM1A_CNT_BLK is a non-zero general "
++			      "address structure.");
++	}
++	if (memcmp((void *)&fadt->x_pm1b_cnt_blk,
++		   (void *)&null_gas,
++		   sizeof(fwts_acpi_gas))) {
++		passed = false;
++		fwts_log_warning(fw,
++			      "X_PM1B_CNT_BLK is a non-zero general "
++			      "address structure.");
++	}
++	if (memcmp((void *)&fadt->x_pm2_cnt_blk,
++		   (void *)&null_gas,
++		   sizeof(fwts_acpi_gas))) {
++		passed = false;
++		fwts_log_warning(fw,
++			      "X_PM2_CNT_BLK is a non-zero general "
++			      "address structure.");
++	}
++	if (memcmp((void *)&fadt->x_pm_tmr_blk,
++		   (void *)&null_gas,
++		   sizeof(fwts_acpi_gas))) {
++		passed = false;
++		fwts_log_warning(fw,
++			      "X_PM_TMR_BLK is a non-zero general "
++			      "address structure.");
++	}
++	if (memcmp((void *)&fadt->x_gpe0_blk,
++		   (void *)&null_gas,
++		   sizeof(fwts_acpi_gas))) {
++		passed = false;
++		fwts_log_warning(fw,
++			      "X_GPE0_BLK is a non-zero general "
++			      "address structure.");
++	}
++	if (memcmp((void *)&fadt->x_gpe1_blk,
++		   (void *)&null_gas,
++		   sizeof(fwts_acpi_gas))) {
++		passed = false;
++		fwts_log_warning(fw,
++			      "X_GPE1_BLK is a non-zero general "
++			      "address structure.");
++	}
++
++	if (passed)
++		fwts_passed(fw, "All FADT reduced hardware fields are zero.");
++	else
++		fwts_failed(fw, LOG_LEVEL_CRITICAL, "fadt_reduced_hw:",
++			    "Some FADT reduced hardware fields are non-zero, but it will be ignored by OSPM.");
++
++	/* now check all the reserved flags */
++	flag_mask = FWTS_FACP_FLAG_WBINVD_FLUSH		|
++		    FWTS_FACP_FLAG_PROC_C1		|
++		    FWTS_FACP_FLAG_P_LVL2_UP		|
++		    FWTS_FACP_FLAG_RTC_S4		|
++		    FWTS_FACP_FLAG_TMR_VAL_EXT		|
++		    FWTS_FACP_FLAG_CPU_SW_SLP		|
++		    FWTS_FACP_FLAG_PCI_EXP_WAK		|
++		    FWTS_FACP_FLAG_S4_RTC_STS_VALID	|
++		    FWTS_FACP_FLAG_REMOTE_POWER_ON_CAPABLE;
++
++	if (fadt->flags & flag_mask)
++		fwts_failed(fw, LOG_LEVEL_CRITICAL, "fadt_reduced_hw:",
++			    "Some FADT reduced hardware flags are set, but it will be ignored by OSPM.");
++	else
++		fwts_passed(fw, "All FADT reduced hardware flags are not set.");
++
++
++	if ((fadt->flags & FWTS_FACP_FLAG_FORCE_APIC_CLUSTER_MODEL) ||
++	    (fadt->flags & FWTS_FACP_FLAG_FORCE_APIC_PHYSICAL_DESTINATION_MODE))
++		fwts_failed(fw, LOG_LEVEL_CRITICAL,
++			    "fadt_reduced_hw:",
++			    "FADT APIC flags are set for reduced hardware "
++			    "mode but may be irrelevant.");
++	else
++		fwts_passed(fw,
++			    "FADT APIC flags are not set in reduced "
++			    "hardware mode.");
++
++	return FWTS_OK;
++}
++
++static int sbbr_fadt_profile_test3(fwts_framework *fw)
++{
++	const uint8_t SBBR_ENT_SERVER   = 4;
++	const uint8_t SBBR_SOHO_SERVER  = 5;
++	const uint8_t SBBR_PERF_SERVER  = 7;
++	fwts_log_info(fw, "FADT Preferred PM Profile: %hhu (%s)\n",
++		fadt->preferred_pm_profile,
++		FWTS_ACPI_FADT_PREFERRED_PM_PROFILE(fadt->preferred_pm_profile));
++
++	if ( (fadt->preferred_pm_profile == SBBR_ENT_SERVER)  ||
++		 (fadt->preferred_pm_profile == SBBR_SOHO_SERVER) ||
++		 (fadt->preferred_pm_profile == SBBR_PERF_SERVER) )
++		fwts_passed(fw, "FADT has a recommended server PM profile.");
++	else
++		fwts_failed(fw, LOG_LEVEL_MEDIUM, "fadt_profile:", "FADT preferred PM profile is not recommended.");
++
++	return FWTS_OK;
++}
++
++static int sbbr_fadt_boot_arch_psci_compliant_test4(fwts_framework *fw)
++{
++	/* ARM SBBR 4.2.1.3 FADT */
++	if (fadt->arm_boot_flags &
++		FWTS_FACP_ARM_BOOT_ARCH_PSCI_COMPLIANT)
++		  fwts_passed(fw, "PSCI_COMPLIANT is set, PSCI is implemented.");
++	else
++	  fwts_failed(fw, LOG_LEVEL_CRITICAL,
++	      "ARCH_PSCI_COMPLIANT:",
++	      "PSCI is NOT implemented.");
++
++	return FWTS_OK;
++}
++
++static fwts_framework_minor_test sbbr_fadt_tests[] = {
++	{ sbbr_fadt_revision_test1, "FADT Revision Test." },
++	{ sbbr_fadt_reduced_hw_test2, "FADT Reduced HW Test." },
++	{ sbbr_fadt_profile_test3, "FADT Server Profile Test." },
++	{ sbbr_fadt_boot_arch_psci_compliant_test4, "FADT PSCI Compliant Test." },
++	{ NULL, NULL }
++};
++
++static fwts_framework_ops sbbr_fadt_ops = {
++	.description = "SBBR FADT Fixed ACPI Description Table tests.",
++	.init        = sbbr_fadt_init,
++	.minor_tests = sbbr_fadt_tests
++};
++
++FWTS_REGISTER("sbbr_fadt", &sbbr_fadt_ops, FWTS_TEST_ANYTIME, FWTS_FLAG_TEST_SBBR)
++#endif
+\ No newline at end of file
+diff --git a/src/sbbr/gtdt/gtdt.c b/src/sbbr/gtdt/gtdt.c
+new file mode 100644
+index 0000000..9b00ee8
+--- /dev/null
++++ b/src/sbbr/gtdt/gtdt.c
+@@ -0,0 +1,253 @@
++/*
++ * Copyright (C) 2015-2017 Canonical
++ * Copyright (C) 2017 ARM Ltd
++ *
++ * Portions of this code original from the Linux-ready Firmware Developer Kit
++ *
++ * This program is free software; you can redistribute it and/or
++ * modify it under the terms of the GNU General Public License
++ * as published by the Free Software Foundation; either version 2
++ * of the License, or (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
++ *
++ */
++#include "fwts.h"
++
++#if defined(FWTS_HAS_SBBR)
++
++#include <stdlib.h>
++#include <stdio.h>
++#include <unistd.h>
++#include <inttypes.h>
++#include <string.h>
++
++static fwts_acpi_table_info *table;
++
++static int sbbr_gtdt_init(fwts_framework *fw)
++{
++	if (fwts_acpi_find_table(fw, "GTDT", 0, &table) != FWTS_OK) {
++		fwts_log_error(fw, "Cannot read ACPI tables.");
++		return FWTS_ERROR;
++	}
++	if (table == NULL || (table && table->length == 0)) {
++		fwts_log_error(fw, "ACPI GTDT table does not exist");
++		return FWTS_ERROR;
++	}
++	return FWTS_OK;
++}
++
++/*
++ *  GTDT  Generic Timer Description Table
++ */
++static int sbbr_gtdt_test1(fwts_framework *fw)
++{
++	bool passed = true;
++	uint8_t *ptr, *end_ptr;
++	uint32_t i = 0, n;
++	const fwts_acpi_table_gtdt *gtdt = (const fwts_acpi_table_gtdt *)table->data;
++
++	if (gtdt->virtual_timer_flags & ~7) {
++		passed = false;
++		fwts_failed(fw, LOG_LEVEL_LOW,
++			"GTDTFlagReservedNonZero",
++			"GTDT flag reserved bits 3 to 31 are non-zero, "
++			"instead got 0x%" PRIx32 ".", gtdt->virtual_timer_flags);
++	}
++
++	ptr = (uint8_t *)table->data + gtdt->platform_timer_offset;
++	n = gtdt->platform_timer_count;
++	end_ptr = (uint8_t *)table->data + table->length;
++
++	while ((i < n) && (ptr < end_ptr)) {
++		uint32_t len, j;
++		fwts_acpi_table_gtdt_block *block;
++		fwts_acpi_table_gtdt_block_timer *block_timer;
++		fwts_acpi_table_gtdt_watchdog *watchdog;
++
++		switch (*ptr) {
++		case 0x00:
++			/* GT Block Structure */
++			block = (fwts_acpi_table_gtdt_block *)ptr;
++			if (ptr + 20 > end_ptr) {
++				passed = false;
++				fwts_failed(fw, LOG_LEVEL_HIGH,
++					"GTDTShortBlock",
++					"GTDT block is too short");
++				goto done;
++			}
++			if (block->length < 20) {
++				passed = false;
++				fwts_failed(fw, LOG_LEVEL_HIGH,
++					"GTDTInvalidBlockLength",
++					"GTDT block %" PRIu32 " length has in "
++					"invalid length: %" PRIu32 " bytes",
++					i, block->length);
++				goto done;
++			}
++			if (block->reserved) {
++				passed = false;
++				fwts_failed(fw, LOG_LEVEL_HIGH,
++					"GTDTInvalidBlockReserved",
++					"GTDT block %" PRIu32 " reserved is "
++					"non-zero, got 0x%" PRIx8,
++					i, block->reserved);
++			}
++			if (block->block_timer_count > 8) {
++				passed = false;
++				fwts_failed(fw, LOG_LEVEL_HIGH,
++					"GTDTInvalidBlockTimerCount",
++					"GTDT block %" PRIu32 " timer count "
++					"is too large, %" PRIu32 ", must be <= 8",
++					i, block->block_timer_count);
++				break;
++			}
++			len = (block->block_timer_count * 40) + 20;
++			if (len != block->length) {
++				passed = false;
++				fwts_failed(fw, LOG_LEVEL_HIGH,
++					"GTDTInvalidTimerCountOrLength",
++					"GTDT block %" PRIu32 " timer count %"
++					PRIu32 " and block length %" PRIu32 ", "
++					"expected length of %" PRIu32,
++					i, block->block_timer_count,
++					block->length, len);
++				/* length may be inconsistent, don't trust it so stop here */
++				goto done;
++			}
++			block_timer = &block->block_timers[0];
++
++			for (j = 0; j < block->block_timer_count; j++) {
++				if (((uint8_t *)block_timer + sizeof(*block_timer)) > end_ptr)
++					break;
++				if (block_timer->frame_number > 7) {
++					passed = false;
++					fwts_failed(fw, LOG_LEVEL_HIGH,
++						"GTDTInvalidGTFrameNumber",
++						"GTDT block frame number is %" PRIu8
++						", expecting 0..7",
++						block_timer->frame_number);
++				}
++				if (block_timer->reserved[0] |
++				    block_timer->reserved[1] |
++				    block_timer->reserved[2]) {
++					passed = false;
++					fwts_failed(fw, LOG_LEVEL_HIGH,
++						"GTDTBlockTimerReservedNotZero",
++						"GTDT block %" PRIu32 " timer reserved "
++						"space is not zero, got 0x"
++						"%" PRIx8 "%" PRIx8 "%" PRIx8
++						" instead", i,
++						block_timer->reserved[0],
++						block_timer->reserved[1],
++						block_timer->reserved[2]);
++				}
++				if (block_timer->phys_timer_flags & ~0x3) {
++					passed = false;
++					fwts_failed(fw, LOG_LEVEL_LOW,
++						"GTDTFBlockPhysTimerFlagReservedNonZero",
++						"GTDT block %" PRIu32 " physical timer "
++						"flags reserved bits 2 to 31 are "
++						"non-zero, instead got 0x%" PRIx32 ".",
++						i, block_timer->phys_timer_flags);
++				}
++				if (block_timer->virt_timer_flags & ~0x3) {
++					passed = false;
++					fwts_failed(fw, LOG_LEVEL_LOW,
++						"GTDTFBlockVirtTimerFlagReservedNonZero",
++						"GTDT block %" PRIu32 " virtual timer "
++						"flags reserved bits 2 to 31 are "
++						"non-zero, instead got 0x%" PRIx32 ".",
++						i, block_timer->virt_timer_flags);
++				}
++				if (block_timer->common_flags & ~0x3) {
++					passed = false;
++					fwts_failed(fw, LOG_LEVEL_LOW,
++						"GTDTFBlockCommonFlagReservedNonZero",
++						"GTDT block %" PRIu32 " common flags "
++						"reserved bits 2 to 31 are "
++						"non-zero, instead got 0x%" PRIx32 ".",
++						i, block_timer->common_flags);
++				}
++			}
++			ptr += block->length;
++			break;
++		case 0x01:
++			/* SBSA Generic Watchdog Timer Structure */
++			watchdog = (fwts_acpi_table_gtdt_watchdog *)ptr;
++			if (ptr + 28 > end_ptr) {
++				passed = false;
++				fwts_failed(fw, LOG_LEVEL_HIGH,
++					"GTDTShortWatchDogTimer",
++					"GTDT SBSA generic watchdog timer %"
++					PRIu32 " is too short", i);
++				goto done;
++			}
++			if (watchdog->length != 28) {
++				passed = false;
++				fwts_failed(fw, LOG_LEVEL_HIGH,
++					"GTDTInvalidWatchDogTimeLength",
++					"GTDT SBSA generic watchdog timer %" PRIu32
++					" length has in invalid length: %"
++					PRIu32 " bytes", i, watchdog->length);
++				goto done;
++			}
++			if (watchdog->reserved) {
++				passed = false;
++				fwts_failed(fw, LOG_LEVEL_HIGH,
++					"GTDTInvalidWatchDogReserved",
++					"GTDT SBSA generic watchdog timer %" PRIu32
++					" reserved is non-zero, got 0x%" PRIx8,
++					i, watchdog->reserved);
++			}
++			if (watchdog->watchdog_timer_flags & ~0x7) {
++				passed = false;
++				fwts_failed(fw, LOG_LEVEL_LOW,
++					"GTDTWatchDogTimerFlagReservedNonZero",
++					"GTDT SBSA generic watchdog timer %" PRIu32
++					" flags reserved bits 3 to 31 are non-zero, "
++					"instead got 0x%" PRIx8 ".",
++					i, watchdog->watchdog_timer_flags);
++			}
++			ptr += watchdog->length;
++			break;
++		default:
++			passed = false;
++			fwts_failed(fw, LOG_LEVEL_HIGH,
++				"GTDTInvalidType",
++				"GTDT platform timer strucuture %" PRIu32
++				" has an invalid type: 0x%" PRIx8, i, *ptr);
++			/* Can't determine field length, so end of parsing */
++			goto done;
++		}
++		i++;
++	}
++
++done:
++	if (passed)
++		fwts_passed(fw, "No issues found in GTDT table.");
++
++	return FWTS_OK;
++}
++
++static fwts_framework_minor_test sbbr_gtdt_tests[] = {
++	{ sbbr_gtdt_test1, "GTDT Generic Timer Description Table test." },
++	{ NULL, NULL }
++};
++
++static fwts_framework_ops sbbr_gtdt_ops = {
++	.description = "GTDT Generic Timer Description Table test.",
++	.init        = sbbr_gtdt_init,
++	.minor_tests = sbbr_gtdt_tests
++};
++
++FWTS_REGISTER("sbbr_gtdt", &sbbr_gtdt_ops, FWTS_TEST_ANYTIME, FWTS_FLAG_TEST_SBBR)
++
++#endif
+diff --git a/src/sbbr/madt/madt.c b/src/sbbr/madt/madt.c
+new file mode 100644
+index 0000000..821ed10
+--- /dev/null
++++ b/src/sbbr/madt/madt.c
+@@ -0,0 +1,965 @@
++/*
++ * Copyright (C) 2015-2017 Canonical
++ * Copyright (C) 2017 ARM Ltd
++ * Portions added (c) 2015, Al Stone <ahs3@redhat.com>
++ *
++ * This program is free software; you can redistribute it and/or
++ * modify it under the terms of the GNU General Public License
++ * as published by the Free Software Foundation; either version 2
++ * of the License, or (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ */
++#include "fwts.h"
++
++#if defined(FWTS_HAS_SBBR)
++
++#include "fwts_acpi_object_eval.h"
++
++#include <stdlib.h>
++#include <stdio.h>
++#include <unistd.h>
++#include <inttypes.h>
++#include <string.h>
++#include <ctype.h>
++
++/*
++ * The Long, Sad, True Story of the MADT
++ *
++ * Once upon a time in ACPI 1.0, there was the MADT.  It was a nice table,
++ * and it had two subtables all of its own.  But, it was also a pretty
++ * busy table, too, so over time the MADT gathered up other nice little
++ * subtables.  By the time ACPI 6.0 came around, the MADT had 16 of the
++ * little guys.
++ *
++ * Now, the MADT kept a little counter around for the subtables.  In fact,
++ * it kept two counters: one was the revision level, which was supposed to
++ * change when new subtables came to be, or as the ones already around grew
++ * up. The second counter was a type number, because the MADT needed a unique
++ * type for each subtable so he could tell them apart.  But, sometimes the
++ * MADT got so busy, he forgot to increment the revision level when he needed
++ * to.  Fortunately, the type counter kept increasing since that's the only
++ * way the MADT could find each little subtable.  It just wouldn't do to have
++ * every subtable called Number 6.
++ *
++ * In the next valley over, a castle full of wizards was watching the MADT
++ * and made a pact to keep their own counter.  Every time the MADT found a
++ * new subtable, or a subtable grew up, the wizards promised they would
++ * increment their counter.  Well, wizards being the forgetful sort, they
++ * didn't alway do that.  And, since there quite a lot of them, they
++ * couldn't always remember who was supposed to keep track of the MADT,
++ * especially if dinner was coming up soon.  Their counter was called the
++ * spec version.
++ *
++ * Every now and then, the MADT would gather up all its little subtables
++ * and take them in to the cobbler to get new boots.  This was a very, very
++ * meticulous cobbler, so every time they came, he wrote down all the boot
++ * sizes for all of the little subtables.  The cobbler would ask each subtable
++ * for its length, check that against his careful notes, and then go get the
++ * right boots.  Sometimes, a little subtable would change a bit, and their
++ * length did not match what the cobbler had written down.  If the wizards
++ * or the MADT had incremented their counters, the cobbler would breath a
++ * sigh of relief and write down the new length as the right one.  But, if
++ * none of the counters had changed, this would make the cobbler very, very
++ * mad.  He couldn't tell if he had the right size boots or not for the
++ * little subtable.  He would have to *guess* and this really bugged him.
++ *
++ * Well, when the cobbler got mad like this, he would go into hiding.  He
++ * would not make or sell any boots.  He would not go out at all.  Pretty
++ * soon, the coffee shop would have to close because the cobbler wasn't
++ * coming by twice a day any more.  Then the grocery store would have to
++ * close because he wouldn't eat much.  After a while, everyone would panic
++ * and have to move from the village and go live with all their relatives
++ * (usually the ones they didn't like very much).
++ *
++ * Eventually, the cobbler would work his way out of his bad mood, and
++ * open up his boot business again.  Then, everyone else could move back
++ * to the village and restart their lives, too.
++ *
++ * Fortunately, we have been able to collect up all the cobbler's careful
++ * notes (and we wrote them down below).  We'll have to keep checking these
++ * notes over time, too, just as the cobbler does.  But, in the meantime,
++ * we can avoid the panic and the reboot since we can make sure that each
++ * subtable is doing okay.  And that's what our tests below check.
++ *
++ *
++ * FADT Major Version ->       1    3    4     4     5     5     6    6     6
++ * FADT Minor Version ->       x    x    x     x     x     1     0    0     1
++ * MADT revision ->            1    1    2     3     3     3     3    4     4
++ * Spec Version ->            1.0  2.0  3.0b  4.0a  5.0b  5.1a  6.0  6.0a  6.1
++ * Subtable Name	Type  Expected Length ->
++ * Processor Local APIC  0x0    8    8    8     8     8     8     8    8     8
++ * IO APIC               0x1   12   12   12    12    12    12    12   12    12
++ * Int Src Override      0x2   10   10   10    10    10    10    10   10    10
++ * NMI Src               0x3    8    8    8     8     8     8     8    8     8
++ * Local APIC NMI Struct 0x4    6    6    6     6     6     6     6    6     6
++ * Local APIC Addr Ovrrd 0x5        16   12    12    12    12    12   12    12
++ * IO SAPIC              0x6        20   16    16    16    16    16   16    16
++ * Local SAPIC           0x7         8  >16   >16   >16   >16   >16  >16   >16
++ * Platform Int Src      0x8        16   16    16    16    16    16   16    16
++ * Proc Local x2APIC     0x9                   16    16    16    16   16    16
++ * Local x2APIC NMI      0xa                   12    12    12    12   12    12
++ * GICC CPU I/F          0xb                         40    76    80   80    80
++ * GICD                  0xc                         24    24    24   24    24
++ * GICv2m MSI            0xd                               24    24   24    24
++ * GICR                  0xe                               16    16   16    16
++ * GIC ITS               0xf                                     20   20    20
++ *
++ * In the table, each length entry is what should be in the length
++ * field of the subtable, and -- in general -- it should match the
++ * size of the struct for the subtable.  Any value that is not set
++ * (i.e., is zero) indicates that the subtable is not defined for
++ * that version of the ACPI spec.
++ *
++ */
++
++#define FADT_MAX_MAJOR_REVISION	((uint8_t)6)
++#define FADT_MAX_MINOR_REVISION	((uint8_t)1)
++#define MADT_MAX_REVISION	((uint8_t)4)
++
++#define SUBTABLE_VARIABLE	0xff
++#define NUM_SUBTABLE_TYPES	16
++
++
++struct acpi_madt_subtable_lengths {
++	unsigned short major_version;	/* from revision in FADT header */
++	unsigned short minor_version;	/* FADT field starting with 5.1 */
++	unsigned short madt_version;	/* MADT revision */
++	unsigned short num_types;	/* types possible for this version */
++	unsigned short lengths[NUM_SUBTABLE_TYPES];
++					/* subtable lengths, indexed by type */
++};
++
++/* SBBR starts with ACPI v6.0 */
++static struct acpi_madt_subtable_lengths spec_info[] = {
++	{ /* for ACPI 6.0 */
++		.major_version = 6,
++		.minor_version = 0,
++		.madt_version = 3,
++		.num_types = 16,
++		.lengths = { 8, 12, 10, 8, 6, 12, 16, SUBTABLE_VARIABLE,
++			     16, 16, 12, 80, 24, 24, 16, 20 }
++		/*
++		 * The spec technically defines the GIC ITS node length to be
++		 * 16, but this is a clear mistake as the fields add up to be
++		 * length 20, and the length was corrected in the next revision.
++		 * Test for 20, as that is what is expected to be used in real,
++		 * implementations and using length 20 ensures that the test can
++		 * correctly find the start of any following nodes.
++		 */
++	},
++	{ /* for ACPI 6.0a */
++		.major_version = 6,
++		.minor_version = 0,
++		.madt_version = 4,
++		.num_types = 16,
++		.lengths = { 8, 12, 10, 8, 6, 12, 16, SUBTABLE_VARIABLE,
++			     16, 16, 12, 80, 24, 24, 16, 20 }
++	},
++	{ /* for ACPI 6.1 */
++		.major_version = 6,
++		.minor_version = 1,
++		.madt_version = 4,
++		.num_types = 16,
++		.lengths = { 8, 12, 10, 8, 6, 12, 16, SUBTABLE_VARIABLE,
++			     16, 16, 12, 80, 24, 24, 16, 20 }
++	},
++	{ /* terminator */
++		.major_version = 0,
++		.minor_version = 0,
++		.madt_version = 0,
++		.num_types = 0,
++		.lengths = { 0 }
++	}
++};
++
++static struct acpi_madt_subtable_lengths *spec_data;
++static uint8_t fadt_major;
++static uint8_t fadt_minor;
++
++static fwts_acpi_table_info *mtable;
++static fwts_acpi_table_info *ftable;
++
++static fwts_list msi_frame_ids;
++static fwts_list its_ids;
++static fwts_list processor_uids;
++
++struct acpi_integer {
++	ACPI_OBJECT_TYPE type;
++	uint64_t value;
++};
++
++static ACPI_STATUS sbbr_madt_processor_handler(ACPI_HANDLE ObjHandle, uint32_t level,
++					  void *context, void **returnvalue)
++{
++	ACPI_OBJECT_TYPE acpi_type;
++	ACPI_STATUS status;
++	ACPI_OBJECT obj;
++	struct acpi_buffer buf = {sizeof(ACPI_OBJECT), &obj};
++	struct acpi_integer *listint;
++
++	/* Prevent -Werror=unused-parameter from complaining */
++	FWTS_UNUSED(level);
++	FWTS_UNUSED(context);
++	FWTS_UNUSED(returnvalue);
++
++	listint = malloc(sizeof(struct acpi_integer));
++	if (!listint)
++		return (!AE_OK);
++
++	status = AcpiGetType(ObjHandle, &acpi_type);
++	if (ACPI_FAILURE(status)) {
++		free(listint);
++		return (!AE_OK);
++	}
++
++	switch(acpi_type) {
++	case ACPI_TYPE_PROCESSOR:
++		status = AcpiEvaluateObject(ObjHandle, NULL, NULL, &buf);
++		if (ACPI_FAILURE(status)) {
++			free(listint);
++			return status;
++		}
++		listint->value = obj.Processor.ProcId;
++		break;
++	case ACPI_TYPE_DEVICE:
++		status = AcpiEvaluateObject(ObjHandle, "_UID", NULL, &buf);
++		if (ACPI_FAILURE(status)) {
++			free(listint);
++			return status;
++		}
++		listint->value = obj.Integer.Value;
++		break;
++	default:
++		free(listint);
++		return (!AE_OK);
++	}
++	listint->type = acpi_type;
++	fwts_list_append(&processor_uids, listint);
++
++	return (AE_OK);
++}
++
++static ACPI_OBJECT_TYPE sbbr_madt_find_processor_uid(fwts_framework *fw,
++						uint64_t uid,
++						char *table_name)
++{
++	char table_label[64];
++	fwts_list_link *item;
++
++	fwts_list_foreach(item, &processor_uids) {
++		struct acpi_integer *listint = fwts_list_data(struct acpi_integer *, item);
++		if (uid == listint->value) {
++			fwts_passed(fw, "MADT %s has matching processor "
++				    "UID %" PRIu64 ".", table_name, uid);
++			return listint->type;
++		}
++	}
++
++	sprintf(table_label, "MADT%sUidMismatch", table_name);
++	fwts_failed(fw, LOG_LEVEL_MEDIUM,
++		    table_label, "%s has no matching processor UID %" PRIu64,
++		    table_name, uid);
++	return ACPI_NUM_TYPES;
++}
++
++static int sbbr_madt_init(fwts_framework *fw)
++{
++	fwts_acpi_table_madt *madt;
++	fwts_acpi_table_fadt *fadt;
++	struct acpi_madt_subtable_lengths *ms = spec_info;
++
++	/* find the ACPI tables needed */
++	if (fwts_acpi_find_table(fw, "APIC", 0, &mtable) != FWTS_OK) {
++		fwts_log_error(fw, "Cannot find ACPI MADT tables.");
++		return FWTS_ERROR;
++	}
++	if (!mtable) {
++		fwts_log_error(fw, "Cannot read ACPI MADT tables.");
++		return FWTS_ERROR;
++	}
++
++	if (fwts_acpi_find_table(fw, "FACP", 0, &ftable) != FWTS_OK) {
++		fwts_log_error(fw, "Cannot find ACPI FADT tables.");
++		return FWTS_ERROR;
++	}
++	if (!ftable) {
++		fwts_log_error(fw, "Cannot read ACPI FADT tables.");
++		return FWTS_ERROR;
++	}
++
++	if (!mtable || mtable->length == 0) {
++		fwts_log_error(fw, "Required ACPI MADT (APIC) table not found");
++		return FWTS_ERROR;
++	}
++	if (!ftable || ftable->length == 0) {
++		fwts_log_error(fw, "Required ACPI FADT (FACP) table not found");
++		return FWTS_ERROR;
++	}
++
++	/* determine the reference data needed */
++	madt = (fwts_acpi_table_madt *)mtable->data;
++	fadt = (fwts_acpi_table_fadt *)ftable->data;
++
++	fadt_major = fadt->header.revision;
++	fadt_minor = 0;
++	if (fadt_major >= 5 && fadt->header.length >= 268)
++		fadt_minor = fadt->minor_version;   /* field added ACPI 5.1 */
++
++	/* find the first occurrence for this version of MADT */
++	while (ms->num_types != 0) {
++		if (ms->madt_version == madt->header.revision)
++			break;
++		ms++;
++	}
++
++	/* now, find the largest FADT version supported */
++	spec_data = NULL;
++	while (ms->num_types && ms->madt_version == madt->header.revision) {
++		if (ms->major_version <= fadt_major &&
++		    ms->minor_version <= fadt_minor) {
++			spec_data = ms;
++		}
++		ms++;
++	}
++
++	/*
++	 * Initialize the MSI frame ID and ITS ID lists should we need
++	 * them later
++	 */
++	fwts_list_init(&msi_frame_ids);
++	fwts_list_init(&its_ids);
++	fwts_list_init(&processor_uids);
++
++	if (fwts_acpica_init(fw) != FWTS_OK)
++		return FWTS_ERROR;
++
++	AcpiWalkNamespace(0x0c, ACPI_ROOT_OBJECT, ACPI_UINT32_MAX,
++			  sbbr_madt_processor_handler, NULL, NULL, NULL);
++	AcpiGetDevices("ACPI0007", sbbr_madt_processor_handler, NULL, NULL);
++
++	return (spec_data) ? FWTS_OK : FWTS_ERROR;
++}
++
++static int sbbr_madt_checksum(fwts_framework *fw)
++{
++	const uint8_t *data = mtable->data;
++	ssize_t length = mtable->length;
++	uint8_t checksum = 0;
++
++	/* verify the table checksum */
++	checksum = fwts_checksum(data, length);
++	if (checksum == 0)
++		fwts_passed(fw, "MADT checksum is correct");
++	else
++		fwts_failed(fw, LOG_LEVEL_MEDIUM,
++			    "SPECMADTChecksum",
++			    "MADT checksum is incorrect: 0x%x", checksum);
++
++	return FWTS_OK;
++}
++
++static int sbbr_madt_revision(fwts_framework *fw)
++{
++	fwts_acpi_table_madt *madt = (fwts_acpi_table_madt *)mtable->data;
++	struct acpi_madt_subtable_lengths *ms = spec_data;
++
++	/* check the table revision */
++	fwts_log_advice(fw, "Most recent FADT revision is %d.%d.",
++			FADT_MAX_MAJOR_REVISION, FADT_MAX_MINOR_REVISION);
++	fwts_log_advice(fw, "Most recent MADT revision is %d.",
++			MADT_MAX_REVISION);
++
++	/* is the madt revision defined at all? */
++	if (!ms->num_types) {
++		fwts_failed(fw, LOG_LEVEL_MEDIUM,
++			    "SPECMADTRevision",
++			    "Undefined MADT revision being used: %d",
++			    madt->header.revision);
++	} else {
++			fwts_passed(fw, "MADT revision %d is defined.",
++				    madt->header.revision);
++	}
++
++	/* is the madt revision in sync with the fadt revision? */
++	if (ms->major_version != fadt_major ||
++	    ms->minor_version != fadt_minor) {
++		fwts_failed(fw, LOG_LEVEL_MEDIUM,
++			    "SPECMADTFADTRevisions",
++			    "MADT revision is not in sync with "
++			    "the FADT revision;\n"
++			    "MADT %d expects FADT %d.%d "
++			    "but found %d.%d instead.",
++			    madt->header.revision,
++			    ms->major_version, ms->minor_version,
++			    fadt_major, fadt_minor);
++	} else {
++		fwts_passed(fw, "MADT revision %d is in sync "
++				"with FADT revision %d.%d.",
++			madt->header.revision, fadt_major, fadt_minor);
++	}
++
++	return FWTS_OK;
++}
++
++static int sbbr_madt_arch_revision(fwts_framework *fw)
++{
++	fwts_acpi_table_madt *madt = (fwts_acpi_table_madt *)mtable->data;
++	uint8_t minrev;
++	const char *arch;
++
++	/* initialize starting assumptions */
++	minrev = 3;
++	arch = "aarch64";
++
++
++	/* check the supported revision for this architecture */
++	if (madt->header.revision >= minrev)
++		fwts_passed(fw, "MADT revision %d meets the minimum needed "
++			    "(%d) for the %s architecture.",
++			    madt->header.revision, minrev, arch);
++	else
++		fwts_failed(fw, LOG_LEVEL_MEDIUM,
++			    "SPECMADTArchRevision",
++			    "MADT revision is %d, must be >= %d "
++			"when running on %s",
++			madt->header.revision, minrev, arch);
++
++	return FWTS_OK;
++}
++
++static int sbbr_madt_flags(fwts_framework *fw)
++{
++	fwts_acpi_table_madt *madt = (fwts_acpi_table_madt *)mtable->data;
++
++	/* make sure the reserved bits in the flag field are zero */
++	if (madt->flags & 0xfffffffe)
++		fwts_failed(fw, LOG_LEVEL_MEDIUM,
++			"MADTFlagsNonZero",
++			"MADT flags field, bits 1..31 are reserved and "
++			"should be zero, but are set as: %" PRIx32 ".\n",
++			madt->flags);
++	else
++		fwts_passed(fw, "MADT flags reserved bits are not set.");
++
++	return FWTS_OK;
++}
++
++static const char *madt_sub_names[] = {
++	/* 0x00 */ "Processor Local APIC",
++	/* 0x01 */ "I/O APIC",
++	/* 0x02 */ "Interrupt Source Override",
++	/* 0x03 */ "Non-maskable Interrupt Source (NMI)",
++	/* 0x04 */ "Local APIC NMI",
++	/* 0x05 */ "Local APIC Address Override",
++	/* 0x06 */ "I/O SAPIC",
++	/* 0x07 */ "Local SAPIC",
++	/* 0x08 */ "Platform Interrupt Sources",
++	/* 0x09 */ "Processor Local x2APIC",
++	/* 0x0a */ "Local x2APIC NMI",
++	/* 0x0b */ "GICC CPU Interface",
++	/* 0x0c */ "GICD GIC Distributor",
++	/* 0x0d */ "GICv2m MSI Frame",
++	/* 0x0e */ "GICR Redistributor",
++	/* 0x0f */ "GIC Interrupt Translation Service (ITS)",
++	/* 0x10 - 0x7f */ "Reserved. OSPM skips structures of the reserved type.",
++	/* 0x80 - 0xff */ "Reserved for OEM use",
++	NULL
++};
++
++static int sbbr_madt_gicc(fwts_framework *fw,
++		     fwts_acpi_madt_sub_table_header *hdr,
++		     const uint8_t *data)
++{
++	/* specific checks for subtable type 0xb: GICC */
++	fwts_acpi_madt_gic *gic = (fwts_acpi_madt_gic *)data;
++	uint32_t mask;
++	int start;
++
++	if (gic->reserved)
++		fwts_failed(fw, LOG_LEVEL_LOW,
++			    "MADTGICCReservedNonZero",
++			    "MADT %s reserved field should be zero, but is "
++			    "instead 0x%" PRIx32 ".",
++			    madt_sub_names[hdr->type], gic->reserved);
++	else
++		fwts_passed(fw,
++			    "MADT %s reserved field properly set to zero.",
++			    madt_sub_names[hdr->type]);
++
++	sbbr_madt_find_processor_uid(fw, gic->processor_uid, "GICC");
++
++	mask = 0xfffffffc;
++	start = 2;
++	if (hdr->length == 80) {	/* ACPI 6.0 */
++		mask = 0xfffffff8;
++		start = 3;
++	}
++	if (gic->flags & mask)
++		fwts_failed(fw, LOG_LEVEL_MEDIUM,
++			    "MADTGICFLags",
++			    "MADT %s, flags, bits %d..31 are reserved "
++			    "and should be zero, but are set as: %" PRIx32 ".",
++			    madt_sub_names[hdr->type], start, gic->flags);
++	else
++		fwts_passed(fw,
++			    "MADT %s, flags, bits %d..31 are reserved and "
++			    "properly set to zero.",
++			    madt_sub_names[hdr->type], start);
++
++	if (gic->parking_protocol_version != 0 &&
++	    gic->parking_protocol_version != 1)
++		fwts_failed(fw, LOG_LEVEL_MEDIUM,
++			    "SPECMADTGICCParkingVersion",
++			    "MADT %s, protocol versions defined are 0..1 but "
++			    "%d is being used.",
++			    madt_sub_names[hdr->type],
++			    gic->parking_protocol_version);
++	else
++		fwts_passed(fw,
++			    "MADT %s, is using a defined parking protocol "
++			    "version.",
++			    madt_sub_names[hdr->type]);
++
++	/*
++	 * TODO: is it even possible to verify the MPIDR is valid?  Or,
++	 * is there sufficient variation that it is not predictable?
++	 */
++
++	if (hdr->length == 80) {	/* added in ACPI 6.0 */
++		uint8_t tmp = gic->reserved2[0] | gic->reserved2[1] |
++			      gic->reserved2[2];
++
++		if (tmp)
++			fwts_failed(fw, LOG_LEVEL_LOW,
++				    "MADTGICCReserved2NonZero",
++				    "MADT %s second reserved field must "
++				    "be zero.", madt_sub_names[hdr->type]);
++		else
++			fwts_passed(fw,
++				    "MADT %s second reserved field properly "
++				    "set to zero.",
++				    madt_sub_names[hdr->type]);
++	}
++
++	/*
++	 * TODO: the local GICC corresponding to the boot processor must
++	 * be the the first entry in the interrupt controller structure
++	 * list.
++	 */
++
++	return (hdr->length - sizeof(fwts_acpi_madt_sub_table_header));
++}
++
++static int sbbr_madt_gicd(fwts_framework *fw,
++		     fwts_acpi_madt_sub_table_header *hdr,
++		     const uint8_t *data)
++{
++	/* specific checks for subtable type 0xc: GIC Distributor */
++	fwts_acpi_madt_gicd *gicd = (fwts_acpi_madt_gicd *)data;
++
++	uint32_t gicd_reserve2 = gicd->reserved2[0] +
++				 (gicd->reserved2[1] << 4) +
++				 (gicd->reserved2[2] << 8);
++
++	if (gicd->reserved)
++		fwts_failed(fw, LOG_LEVEL_LOW,
++			    "MADTGICDReservedNonZero",
++			    "MADT %s reserved field should be zero, "
++			    "instead got 0x%" PRIx32 ".",
++			    madt_sub_names[hdr->type], gicd->reserved);
++	else
++		fwts_passed(fw,
++			    "MADT %s reserved field properly set to zero.",
++			    madt_sub_names[hdr->type]);
++
++	/* TODO: is the physical base address required to be non-zero? */
++
++	if (gicd->gic_version != 0 && gicd->gic_version > 4)
++		fwts_failed(fw, LOG_LEVEL_LOW,
++			    "SPECMADTGICDVersion",
++			    "MADT %s GIC version field should be in 0..4, "
++			    "but instead have 0x%" PRIx32 ".",
++			    madt_sub_names[hdr->type], gicd->gic_version);
++	else
++		fwts_passed(fw,
++			    "MADT %s GIC version field is in 0..4.",
++			    madt_sub_names[hdr->type]);
++
++	if (gicd_reserve2)
++		fwts_failed(fw, LOG_LEVEL_LOW,
++			    "MADTGICDReserved2NonZero",
++			    "MADT %s second reserved field should be zero, "
++			    "instead got 0x%" PRIx32 ".",
++			    madt_sub_names[hdr->type], gicd_reserve2);
++	else
++		fwts_passed(fw,
++			    "MADT %s second reserved field is properly set "
++			    "to zero.", madt_sub_names[hdr->type]);
++
++	return (hdr->length - sizeof(fwts_acpi_madt_sub_table_header));
++}
++
++static int sbbr_madt_gic_msi_frame(fwts_framework *fw,
++			      fwts_acpi_madt_sub_table_header *hdr,
++			      const uint8_t *data)
++{
++	/* specific checks for subtable type 0xd: GIC MSI Frame */
++	fwts_acpi_madt_gic_msi *gic_msi = (fwts_acpi_madt_gic_msi *)data;
++	fwts_list_link *item;
++	bool found;
++
++	/*
++	 * TODO: is there some way to test that the entries found are
++	 * for only non-secure MSI frames?
++	 */
++
++	if (gic_msi->reserved)
++		fwts_failed(fw, LOG_LEVEL_LOW,
++			    "MADTGICMSIReservedNonZero",
++			    "MADT %s reserved field should be zero, "
++			    "instead got 0x%" PRIx32 ".",
++			    madt_sub_names[hdr->type], gic_msi->reserved);
++	else
++		fwts_passed(fw,
++			    "MADT %s reserved field properly set to zero.",
++			    madt_sub_names[hdr->type]);
++
++	/*
++	 * Check MSI Frame ID against previously found IDs to see if it
++	 * is unique.  According to the spec, they must be.
++	 */
++	found = false;
++	fwts_list_foreach(item, &msi_frame_ids) {
++		uint32_t *frame_id = fwts_list_data(uint32_t *, item);
++
++		if (*frame_id == gic_msi->frame_id)
++			found = true;
++	}
++	if (found) {
++		fwts_failed(fw, LOG_LEVEL_MEDIUM,
++			    "MADTGICMSINonUniqueFrameId",
++			    "MADT %s Frame ID 0x%" PRIx32 " is not unique "
++			    "and has already be defined in a previous %s.",
++			    madt_sub_names[hdr->type],
++			    gic_msi->frame_id,
++			    madt_sub_names[hdr->type]);
++	} else {
++		fwts_list_append(&msi_frame_ids, &(gic_msi->frame_id));
++		fwts_passed(fw,
++			    "MADT %s Frame ID 0x%" PRIx32 " is unique "
++			    "as is required.",
++			    madt_sub_names[hdr->type],
++			    gic_msi->frame_id);
++	}
++
++	/*
++	 * TODO: can the physical base address be tested, or is zero
++	 * allowed?
++	 */
++
++	if (gic_msi->flags & 0xfffffffe)
++		fwts_failed(fw, LOG_LEVEL_MEDIUM,
++			    "MADTGICMSIFLags",
++			    "MADT %s, flags, bits 1..31 are reserved "
++			    "and should be zero, but are set as: %" PRIx32 ".",
++			    madt_sub_names[hdr->type],
++			    gic_msi->flags);
++	else
++		fwts_passed(fw,
++			    "MADT %s, flags, bits 1..31 are reserved "
++			    "and properly set to zero.",
++			    madt_sub_names[hdr->type]);
++
++	/*
++	 * TODO: can we check the SPI Count and SPI Base against the MSI_TYPER
++	 * register in the frame at this point?  Or is this something that
++	 * can only been done when running on the arch we're testing for?
++	 */
++
++	return (hdr->length - sizeof(fwts_acpi_madt_sub_table_header));
++}
++
++static int sbbr_madt_gicr(fwts_framework *fw,
++		     fwts_acpi_madt_sub_table_header *hdr,
++		     const uint8_t *data)
++{
++	/* specific checks for subtable type 0xe: GICR */
++	fwts_acpi_madt_gicr *gicr = (fwts_acpi_madt_gicr *)data;
++
++	/*
++	 * TODO: GICR structures should only be used when GICs implement
++	 * version 3 or higher.
++	 */
++
++	if (gicr->reserved)
++		fwts_failed(fw, LOG_LEVEL_LOW,
++			    "MADTGICRReservedNonZero",
++			    "MADT %s reserved field should be zero, "
++			    "instead got 0x%" PRIx32 ".",
++			    madt_sub_names[hdr->type],
++			    gicr->reserved);
++	else
++		fwts_passed(fw,
++			    "MADT %s reserved field properly set to zero.",
++			    madt_sub_names[hdr->type]);
++
++	/*
++	 * TODO: can Discovery Range Base Address ever be zero?
++	 * Or, can we assume it must be non-zero?
++	 */
++
++	if (gicr->discovery_range_length == 0)
++		fwts_failed(fw, LOG_LEVEL_LOW,
++			    "SPECMADTGICRZeroLength",
++			    "MADT %s discovery range length should be > 0.",
++			    madt_sub_names[hdr->type]);
++	else
++		fwts_passed(fw,
++			    "MADT %s discovery range length of %d > 0.",
++			    madt_sub_names[hdr->type],
++			    gicr->discovery_range_length);
++
++	return (hdr->length - sizeof(fwts_acpi_madt_sub_table_header));
++}
++
++static int sbbr_madt_gic_its(fwts_framework *fw,
++			     fwts_acpi_madt_sub_table_header *hdr,
++			     const uint8_t *data)
++{
++	/* specific checks for subtable type 0xf: GIC ITS */
++	fwts_acpi_madt_gic_its *gic_its = (fwts_acpi_madt_gic_its *)data;
++	fwts_list_link *item;
++	bool found;
++
++	if (gic_its->reserved)
++		fwts_failed(fw, LOG_LEVEL_LOW,
++			    "SPECMADTGICITSReservedNonZero",
++			    "MADT %s first reserved field should be zero, "
++			    "instead got 0x%" PRIx32 ".",
++			    madt_sub_names[hdr->type], gic_its->reserved);
++	else
++		fwts_passed(fw,
++			    "MADT %s first reserved field is properly set "
++			    "to zero.",
++			    madt_sub_names[hdr->type]);
++
++	/*
++	 * Check ITS ID against previously found IDs to see if it
++	 * is unique.  According to the spec, they must be.
++	 */
++	found = false;
++	fwts_list_foreach(item, &its_ids) {
++		uint32_t *its_id = fwts_list_data(uint32_t *, item);
++
++		if (*its_id == gic_its->its_id)
++			found = true;
++	}
++	if (found) {
++		fwts_failed(fw, LOG_LEVEL_MEDIUM,
++			    "SPECMADTGICITSNonUniqueId",
++			    "MADT %s ITS ID 0x%" PRIx32 " is not unique "
++			    "and has already be defined in a previous %s.",
++			    madt_sub_names[hdr->type],
++			    gic_its->its_id,
++			    madt_sub_names[hdr->type]);
++	} else {
++		fwts_list_append(&its_ids, &(gic_its->its_id));
++		fwts_passed(fw,
++			    "MADT %s ITS ID 0x%" PRIx32 " is unique "
++			    "as is required.",
++			    madt_sub_names[hdr->type],
++			    gic_its->its_id);
++	}
++
++	/*
++	 * TODO: can the physical base address be tested, or is zero
++	 * allowed?
++	 */
++
++	if (gic_its->reserved2)
++		fwts_failed(fw, LOG_LEVEL_LOW,
++			    "SPECMADTGICITSReserved2NonZero",
++			    "MADT %s second reserved field should be zero, "
++			    "instead got 0x%" PRIx32 ".",
++			    madt_sub_names[hdr->type], gic_its->reserved2);
++	else
++		fwts_passed(fw,
++			    "MADT %s second reserved field is properly set "
++			    "to zero.",
++			    madt_sub_names[hdr->type]);
++
++	return (hdr->length - sizeof(fwts_acpi_madt_sub_table_header));
++}
++
++static int sbbr_madt_subtables(fwts_framework *fw)
++{
++	fwts_acpi_table_madt *madt = (fwts_acpi_table_madt *)mtable->data;
++	fwts_acpi_madt_sub_table_header *hdr;
++	struct acpi_madt_subtable_lengths *ms = spec_data;
++	const uint8_t *data = mtable->data;
++	ssize_t length = mtable->length;
++	int ii = 0;
++
++	/*
++	 * check the correctness of each subtable type, and whether or
++	 * not the subtable is allowed for this revision of the MADT
++	 */
++
++	data += sizeof(fwts_acpi_table_madt);
++	length -= sizeof(fwts_acpi_table_madt);
++
++	if (!ms->num_types) {
++		fwts_failed(fw, LOG_LEVEL_MEDIUM,
++			    "SPECMADTRevision",
++			    "Undefined MADT revision being used: %d",
++			    madt->header.revision);
++	} else {
++		fwts_passed(fw, "MADT revision %d is defined.",
++			    madt->header.revision);
++	}
++
++	while (length > (ssize_t)sizeof(fwts_acpi_madt_sub_table_header)) {
++		ssize_t skip = 0;
++		int len = 0;
++		int type;
++		int offset = 0;
++
++		hdr = (fwts_acpi_madt_sub_table_header *)data;
++		ii++;
++
++		data += sizeof(fwts_acpi_madt_sub_table_header);
++		offset = (int)(mtable->length - length);
++		length -= sizeof(fwts_acpi_madt_sub_table_header);
++
++		/* set initial type value, will be overriden for OEM and
++		 * reserved entries */
++		type = hdr->type;
++
++		/* check for OEM and reserved entries */
++		if (hdr->type >= NUM_SUBTABLE_TYPES) {
++			if (hdr->type < 0x80)
++				type = FWTS_ACPI_MADT_RESERVED;
++			else
++				type = FWTS_ACPI_MADT_OEM;
++			len = hdr->length;
++		} else {
++			/* this subtable is defined */
++			len = ms->lengths[hdr->type];
++		}
++
++		if (!len) {
++			fwts_failed(fw, LOG_LEVEL_MEDIUM,
++				    "SPECMADTSubType",
++				    "Undefined MADT subtable type for this "
++				    "version of the MADT: %d (%s)",
++				    hdr->type, madt_sub_names[type]);
++		} else {
++			fwts_passed(fw,
++				    "MADT subtable type %d (%s) is defined.",
++				    hdr->type, madt_sub_names[type]);
++		}
++
++		/* perform checks specific to subtable types */
++		switch (type) {
++
++		case FWTS_ACPI_MADT_GIC_C_CPU_INTERFACE:
++			skip = sbbr_madt_gicc(fw, hdr, data);
++			break;
++
++		case FWTS_ACPI_MADT_GIC_D_GOC_DISTRIBUTOR:
++			skip = sbbr_madt_gicd(fw, hdr, data);
++			break;
++
++		case FWTS_ACPI_MADT_GIC_V2M_MSI_FRAME:
++			skip = sbbr_madt_gic_msi_frame(fw, hdr, data);
++			break;
++
++		case FWTS_ACPI_MADT_GIC_R_REDISTRIBUTOR:
++			skip = sbbr_madt_gicr(fw, hdr, data);
++			break;
++
++		case FWTS_ACPI_MADT_GIC_ITS:
++			skip = sbbr_madt_gic_its(fw, hdr, data);
++			break;
++
++		case FWTS_ACPI_MADT_RESERVED:
++			fwts_failed(fw, LOG_LEVEL_MEDIUM,
++				    "SPECMADTSubReservedID",
++				    "MADT subtable %d (offset 0x%x) is "
++				    "using the reserved value 0x%x for a "
++				    "type.  Subtable type values 0x10..0x7f "
++				    "are reserved; 0x80..0xff can be "
++				    "used by OEMs.",
++				    ii, offset, hdr->type);
++			skip = (hdr->length -
++				sizeof(fwts_acpi_madt_sub_table_header));
++			break;
++		case FWTS_ACPI_MADT_OEM:
++			/* OEM entries must be assumed to be valid */
++			skip = (hdr->length -
++				sizeof(fwts_acpi_madt_sub_table_header));
++			break;
++		default:
++			fwts_failed(fw, LOG_LEVEL_MEDIUM,
++				    "SPECMADTSubReservedID",
++				    "MADT subtable %d (offset 0x%x) is "
++				    "using value 0x%x for a type.  This "
++				    "value is out of the expected range "
++				    "of 0x00 .. 0xff.",
++				    ii, offset, hdr->type);
++			skip = (hdr->length -
++				sizeof(fwts_acpi_madt_sub_table_header));
++			break;
++		}
++
++		if (hdr->length == 0) {
++			fwts_log_error(fw, "INTERNAL ERROR: "
++				       "zero length subtable means something "
++				       "is seriously broken. Subtable %d "
++				       "(offset 0x%0x) has the problem.",
++				       ii, offset);
++			break;
++		}
++		data   += skip;
++		length -= skip;
++	}
++
++	return FWTS_OK;
++}
++
++static int sbbr_madt_deinit(fwts_framework *fw)
++{
++	fwts_acpica_deinit();
++
++	/* only minor clean up needed */
++	fwts_list_free_items(&msi_frame_ids, NULL);
++	fwts_list_free_items(&its_ids, NULL);
++	fwts_list_free_items(&processor_uids, NULL);
++
++	return (fw) ? FWTS_ERROR : FWTS_OK;
++}
++
++static fwts_framework_minor_test sbbr_madt_tests[] = {
++	{ sbbr_madt_checksum, "MADT checksum test." },
++	{ sbbr_madt_revision, "MADT revision test." },
++	{ sbbr_madt_arch_revision, "MADT architecture minimum revision test." },
++	{ sbbr_madt_flags, "MADT flags field reserved bits test." },
++	{ sbbr_madt_subtables, "MADT subtable tests related to GIC." },
++	{ NULL, NULL }
++};
++
++static fwts_framework_ops sbbr_madt_ops = {
++	.description = "MADT Multiple APIC Description Table (spec compliant).",
++	.init        = sbbr_madt_init,
++	.deinit      = sbbr_madt_deinit,
++	.minor_tests = sbbr_madt_tests
++};
++
++FWTS_REGISTER("sbbr_madt", &sbbr_madt_ops, FWTS_TEST_ANYTIME, FWTS_FLAG_TEST_SBBR)
++
++#endif
+diff --git a/src/sbbr/method/method.c b/src/sbbr/method/method.c
+new file mode 100644
+index 0000000..107c425
+--- /dev/null
++++ b/src/sbbr/method/method.c
+@@ -0,0 +1,7321 @@
++/*
++ * Copyright (C) 2010-2017 Canonical
++ * Copyright (C) 2017      ARM Ltd
++ *
++ * This program is free software; you can redistribute it and/or
++ * modify it under the terms of the GNU General Public License
++ * as published by the Free Software Foundation; either version 2
++ * of the License, or (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
++ *
++ */
++#include "fwts.h"
++
++#if defined(FWTS_HAS_SBBR)
++
++#include <stdio.h>
++#include <stdlib.h>
++#include <string.h>
++#include <signal.h>
++#include <unistd.h>
++#include <ctype.h>
++#include <inttypes.h>
++#include "fwts_acpi_object_eval.h"
++
++/*
++ * ACPI methods + objects used in Linux ACPI driver:
++ *
++ * Name 	 Tested
++ * _ACx 	 Y
++ * _ADR 	 Y
++ * _AEI 	 Y
++ * _ALC 	 Y
++ * _ALI 	 Y
++ * _ALP 	 Y
++ * _ALR 	 Y
++ * _ALT 	 Y
++ * _ALx 	 N
++ * _ART 	 Y
++ * _BBN 	 Y
++ * _BCL 	 Y
++ * _BCM 	 Y
++ * _BCT 	 Y
++ * _BDN 	 Y
++ * _BFS 	 deprecated
++ * _BIF 	 Y
++ * _BIX 	 Y
++ * _BLT 	 N not easily tested
++ * _BMA 	 Y
++ * _BMC 	 Y
++ * _BMD 	 Y
++ * _BMS 	 Y
++ * _BQC 	 Y
++ * _BST 	 Y
++ * _BTH 	 Y
++ * _BTM 	 Y
++ * _BTP 	 Y
++ * _CBA 	 Y
++ * _CCA 	 Y
++ * _CDM 	 Y
++ * _CID 	 Y
++ * _CLS 	 N requires PCI SIG class info
++ * _CPC 	 Y
++ * _CR3 	 Y
++ * _CRS 	 Y
++ * _CRT 	 Y
++ * _CSD 	 Y
++ * _CST 	 Y
++ * _CWS 	 Y
++ * _DCK 	 Y
++ * _DCS 	 Y
++ * _DDC 	 Y
++ * _DDN 	 Y
++ * _DEP 	 Y
++ * _DGS 	 Y
++ * _DIS 	 Y
++ * _DLM 	 Y
++ * _DMA 	 Y
++ * _DOD 	 Y
++ * _DOS 	 Y
++ * _DSD 	 Y
++ * _DSM 	 N
++ * _DSS 	 Y
++ * _DSW 	 Y
++ * _DTI 	 Y
++ * _Exx 	 n/a
++ * _EC_ 	 Y
++ * _EDL 	 Y
++ * _EJD 	 Y
++ * _EJx 	 Y
++ * _EVT 	 Y
++ * _FDE 	 N (floppy controller, ignore)
++ * _FDI 	 N (floppy controller, ignore)
++ * _FDM 	 N (floppy controller, ignore)
++ * _FIF 	 Y
++ * _FIT 	 Y
++ * _FIX 	 Y
++ * _FPS 	 Y
++ * _FSL 	 Y
++ * _FST 	 Y
++ * _GAI 	 Y
++ * _GCP 	 Y
++ * _GHL 	 Y
++ * _GL	 	 n/a
++ * _GLK 	 Y
++ * _GPD 	 Y
++ * _GPE 	 Y
++ * _GRT 	 Y
++ * _GSB 	 Y
++ * _GTF 	 Y
++ * _GTM 	 Y
++ * _GTS 	 deprecated
++ * _GWS 	 Y
++ * _HID 	 Y
++ * _HOT 	 Y
++ * _HPP 	 Y
++ * _HPX 	 N
++ * _HRV 	 Y
++ * _IFT 	 Y
++ * _INI 	 Y
++ * _IRC 	 Y
++ * _Lxx 	 n/a
++ * _LCK 	 Y
++ * _LID 	 Y
++ * _LPI 	 Y
++ * _MAT 	 N
++ * _MBM 	 Y
++ * _MLS 	 Y
++ * _MSG 	 Y
++ * _MSM 	 N
++ * _MTL 	 Y
++ * _NTT 	 Y
++ * _OFF 	 Y
++ * _ON_ 	 Y
++ * _OSC 	 n/a
++ * _OST 	 n/a
++ * _PAI 	 n/a
++ * _PCL 	 Y
++ * _PCT 	 Y
++ * _PDC 	 deprecated
++ * _PDL 	 Y
++ * _PIC 	 Y
++ * _PIF 	 Y
++ * _PLD 	 Y
++ * _PMC 	 Y
++ * _PMD 	 Y
++ * _PMM 	 Y
++ * _PPC 	 Y
++ * _PPE 	 Y
++ * _PR0 	 Y
++ * _PR1 	 Y
++ * _PR2 	 Y
++ * _PR3 	 Y
++ * _PRE 	 Y
++ * _PRL 	 Y
++ * _PRR 	 Y
++ * _PRS 	 Y
++ * _PRT 	 Y
++ * _PRW 	 Y
++ * _PS0 	 Y
++ * _PS1 	 Y
++ * _PS2 	 Y
++ * _PS3 	 Y
++ * _PSC 	 Y
++ * _PSD 	 Y
++ * _PSE 	 Y
++ * _PSL 	 Y
++ * _PSR 	 Y
++ * _PSS 	 Y
++ * _PSV 	 Y
++ * _PSW 	 Y
++ * _PTC 	 Y
++ * _PTP 	 n/a
++ * _PTS 	 Y
++ * _PUR 	 Y
++ * _PXM 	 Y
++ * _Qxx 	 n/a
++ * _RDI 	 Y
++ * _REG 	 n/a
++ * _RMV 	 Y
++ * _ROM 	 Y
++ * _RST 	 Y
++ * _RTV 	 Y
++ * _S0_ 	 Y
++ * _S1_ 	 Y
++ * _S2_ 	 Y
++ * _S3_ 	 Y
++ * _S4_ 	 Y
++ * _S5_ 	 Y
++ * _S1D 	 Y
++ * _S2D 	 Y
++ * _S3D 	 Y
++ * _S4D 	 Y
++ * _S0W 	 Y
++ * _S1W 	 Y
++ * _S2W 	 Y
++ * _S3W 	 Y
++ * _S4W 	 Y
++ * _SBS 	 Y
++ * _SCP 	 Y
++ * _SDD 	 n/a
++ * _SEG 	 Y
++ * _SHL 	 n/a
++ * _SLI 	 N
++ * _SPD 	 Y
++ * _SRS 	 n/a
++ * _SRT 	 Y
++ * _SRV 	 Y
++ * _SST 	 Y
++ * _STA 	 Y
++ * _STM 	 n/a
++ * _STP 	 Y
++ * _STR 	 Y
++ * _STV 	 Y
++ * _SUB 	 Y
++ * _SUN 	 Y
++ * _SWS 	 Y
++ * _T_x 	 n/a
++ * _TC1 	 Y
++ * _TC2 	 Y
++ * _TDL 	 Y
++ * _TFP 	 Y
++ * _TIP 	 Y
++ * _TIV 	 Y
++ * _TMP 	 Y
++ * _TPC 	 Y
++ * _TPT 	 Y
++ * _TRT 	 Y
++ * _TSD 	 Y
++ * _TSN 	 Y
++ * _TSP 	 Y
++ * _TSS 	 Y
++ * _TST 	 Y
++ * _TTS 	 Y
++ * _TZD 	 Y
++ * _TZM 	 Y
++ * _TZP 	 Y
++ * _UID 	 Y
++ * _UPC 	 Y
++ * _UPD 	 Y
++ * _UPP 	 Y
++ * _VPO 	 Y
++ * _WAK 	 Y
++ * _WPC 	 Y
++ * _WPP 	 Y
++ * _Wxx 	 n/a
++ * _WDG 	 N
++ * _WED 	 N
++ */
++
++/* Test types */
++#define	METHOD_MANDATORY	1
++#define METHOD_OPTIONAL		2
++#define METHOD_MOBILE		4
++#define METHOD_SILENT		8
++
++#define ACPI_TYPE_INTBUF	(ACPI_TYPE_INVALID + 1)
++
++#define method_check_type(fw, name, buf, type) 			\
++	method_check_type__(fw, name, buf, type, #type)
++
++static bool fadt_mobile_platform;	/* True if a mobile platform */
++
++#define method_test_integer(name, type)				\
++static int method_test ## name(fwts_framework *fw)		\
++{ 								\
++	return method_evaluate_method(fw, type, # name,		\
++		NULL, 0, method_test_integer_return, # name); 	\
++}
++
++typedef void (*method_test_return)(fwts_framework *fw, char *name,
++	ACPI_BUFFER *ret_buff, ACPI_OBJECT *ret_obj, void *private);
++
++/*
++ * Helper functions to facilitate the evaluations
++ */
++
++/****************************************************************************/
++
++static bool method_type_matches(ACPI_OBJECT_TYPE t1, ACPI_OBJECT_TYPE t2)
++{
++	if (t1 == ACPI_TYPE_INTBUF &&
++	    (t2 == ACPI_TYPE_INTEGER || t2 == ACPI_TYPE_BUFFER))
++		return true;
++
++	if (t2 == ACPI_TYPE_INTBUF &&
++	    (t1 == ACPI_TYPE_INTEGER || t1 == ACPI_TYPE_BUFFER))
++		return true;
++
++	return t1 == t2;
++}
++
++/*
++ *  method_passed_sane()
++ *	helper function to report often used passed messages
++ */
++static void method_passed_sane(
++	fwts_framework *fw,
++	const char *name,
++	const char *type)
++{
++	fwts_passed(fw, "%s correctly returned a sane looking %s.", name, type);
++}
++
++/*
++ *  method_passed_sane_uint64()
++ *	helper function to report often used passed uint64 values
++ */
++static void method_passed_sane_uint64(
++	fwts_framework *fw,
++	const char *name,
++	const uint64_t value)
++{
++	fwts_passed(fw, "%s correctly returned sane looking "
++		"value 0x%8.8" PRIx64 ".", name, value);
++}
++
++/*
++ *  method_failed_null_return()
++ *	helper function to report often used failed NULL object return
++ */
++static void method_failed_null_object(
++	fwts_framework *fw,
++	const char *name,
++	const char *type)
++{
++	fwts_failed(fw, LOG_LEVEL_MEDIUM, "MethodReturnNullObj",
++		"%s returned a NULL object, and did not "
++		"return %s.", name, type);
++}
++
++/*
++ *  method_package_count_min()
++ *	check that an ACPI package has at least 'min' elements
++ */
++static int method_package_count_min(
++	fwts_framework *fw,
++	const char *name,
++	const char *objname,
++	const ACPI_OBJECT *obj,
++	const uint32_t min)
++{
++	if (obj->Package.Count < min) {
++		char tmp[128];
++
++		snprintf(tmp, sizeof(tmp), "Method%sElementCount", objname);
++		fwts_failed(fw, LOG_LEVEL_MEDIUM, tmp,
++			"%s should return package of at least %" PRIu32
++			" element%s, got %" PRIu32 " element%s instead.",
++			name, min, min == 1 ? "" : "s",
++			obj->Package.Count, obj->Package.Count == 1 ? "" : "s");
++		return FWTS_ERROR;
++	}
++	return FWTS_OK;
++}
++
++/*
++ *  method_package_count_equal()
++ *	check that an ACPI package has exactly 'count' elements
++ */
++static int method_package_count_equal(
++	fwts_framework *fw,
++	const char *name,
++	const char *objname,
++	const ACPI_OBJECT *obj,
++	const uint32_t count)
++{
++	if (obj->Package.Count != count) {
++		char tmp[128];
++
++		snprintf(tmp, sizeof(tmp), "Method%sElementCount", objname);
++		fwts_failed(fw, LOG_LEVEL_MEDIUM, tmp,
++			"%s should return package of %" PRIu32
++			" element%s, got %" PRIu32 " element%s instead.",
++			name, count, count == 1 ? "" : "s",
++			obj->Package.Count, obj->Package.Count == 1 ? "" : "s");
++		return FWTS_ERROR;
++	}
++	return FWTS_OK;
++}
++
++/*
++ *  method_init()
++ *	initialize ACPI
++ */
++static int sbbr_method_init(fwts_framework *fw)
++{
++	fwts_acpi_table_info *info;
++	int i;
++	bool got_fadt = false;
++
++	fadt_mobile_platform = false;
++
++	/* Some systems have multiple FADTs, sigh */
++	for (i = 0; i < 256; i++) {
++		fwts_acpi_table_fadt *fadt;
++		int ret = fwts_acpi_find_table(fw, "FACP", i, &info);
++		if (ret == FWTS_NULL_POINTER || info == NULL)
++			break;
++		fadt = (fwts_acpi_table_fadt*)info->data;
++		got_fadt = true;
++		if (fadt->preferred_pm_profile == 2) {
++			fadt_mobile_platform = true;
++			break;
++		}
++	}
++
++	if (got_fadt && !fadt_mobile_platform) {
++		fwts_log_info(fw,
++			"FADT Preferred PM profile indicates this is not "
++			"a Mobile Platform.");
++	}
++
++	if (fwts_acpi_init(fw) != FWTS_OK) {
++		fwts_log_error(fw, "Cannot initialise ACPI.");
++		return FWTS_ERROR;
++	}
++
++	return FWTS_OK;
++}
++
++/*
++ *  method_deinit
++ *	de-intialize ACPI
++ */
++static int sbbr_method_deinit(fwts_framework *fw)
++{
++	return fwts_acpi_deinit(fw);
++}
++
++/*
++ *  method_evaluate_found_method
++ *	find a given object name and evaluate it
++ */
++static void method_evaluate_found_method(
++	fwts_framework *fw,
++	char *name,
++	method_test_return check_func,
++	void *private,
++	ACPI_OBJECT_LIST *arg_list)
++{
++	ACPI_BUFFER       buf;
++	ACPI_STATUS	  ret;
++	int sem_acquired;
++	int sem_released;
++
++	fwts_acpica_sem_count_clear();
++
++	ret = fwts_acpi_object_evaluate(fw, name, arg_list, &buf);
++
++	if (ACPI_FAILURE(ret) != AE_OK) {
++		fwts_acpi_object_evaluate_report_error(fw, name, ret);
++	} else {
++		if (check_func != NULL) {
++			ACPI_OBJECT *obj = buf.Pointer;
++			check_func(fw, name, &buf, obj, private);
++		}
++	}
++	free(buf.Pointer);
++
++	fwts_acpica_sem_count_get(&sem_acquired, &sem_released);
++	if (sem_acquired != sem_released) {
++		fwts_failed(fw, LOG_LEVEL_MEDIUM, "AMLLocksAcquired",
++			"%s left %d locks in an acquired state.",
++			name, sem_acquired - sem_released);
++		fwts_advice(fw,
++			"Locks left in an acquired state generally indicates "
++			"that the AML code is not releasing a lock. This can "
++			"sometimes occur when a method hits an error "
++			"condition and exits prematurely without releasing an "
++			"acquired lock. It may be occurring in the method "
++			"being tested or other methods used while evaluating "
++			"the method.");
++	}
++}
++
++/*
++ *  method_evaluate_method
++ *	find all matching object names and evaluate them,
++ *	also run the callback check_func to sanity check
++ *	any returned values
++ */
++static int method_evaluate_method(fwts_framework *fw,
++	int test_type,  /* Manditory or optional */
++	char *name,
++	ACPI_OBJECT *args,
++	int num_args,
++	method_test_return check_func,
++	void *private)
++{
++	fwts_list *methods;
++	size_t name_len = strlen(name);
++	bool found = false;
++
++
++	if ((methods = fwts_acpi_object_get_names()) != NULL) {
++		fwts_list_link	*item;
++
++		fwts_list_foreach(item, methods) {
++			char *method_name = fwts_list_data(char*, item);
++			ACPI_HANDLE method_handle;
++			ACPI_OBJECT_TYPE type;
++			ACPI_STATUS status;
++
++			size_t len = strlen(method_name);
++			if (strncmp(name, method_name + len - name_len, name_len) == 0) {
++				ACPI_OBJECT_LIST  arg_list;
++
++				status = AcpiGetHandle (NULL, method_name, &method_handle);
++				if (ACPI_FAILURE(status)) {
++					fwts_warning(fw, "Failed to get handle for object %s.", name);
++				}
++				status = AcpiGetType(method_handle, &type);
++				if (ACPI_FAILURE(status)) {
++					fwts_warning(fw, "Failed to get object type for %s.",name);
++				}
++
++				if (type == ACPI_TYPE_LOCAL_SCOPE)
++					continue;
++
++				found = true;
++				arg_list.Count   = num_args;
++				arg_list.Pointer = args;
++				method_evaluate_found_method(fw, method_name,
++					check_func, private, &arg_list);
++			}
++		}
++	}
++
++	if (found) {
++		if ((test_type & METHOD_MOBILE) && (!fadt_mobile_platform)) {
++			fwts_warning(fw,
++				"The FADT indictates that this machine is not "
++				"a mobile platform, however it has a mobile "
++				"platform specific object %s defined. "
++				"Either the FADT referred PM profile is "
++				"incorrect or this machine has mobile "
++				"platform objects defined when it should not.",
++				name);
++		}
++		return FWTS_OK;
++	} else {
++		if (!(test_type & METHOD_SILENT)) {
++			/* Mandatory not-found test are a failure */
++			if (test_type & METHOD_MANDATORY) {
++				fwts_failed(fw, LOG_LEVEL_MEDIUM, "MethodNotExist",
++					"Object %s did not exist.", name);
++			}
++
++			/* Mobile specific tests on non-mobile platform? */
++			if ((test_type & METHOD_MOBILE) && (!fadt_mobile_platform)) {
++				fwts_skipped(fw,
++					"Machine is not a mobile platform, skipping "
++					"test for non-existent mobile platform "
++					"related object %s.", name);
++			} else {
++				fwts_skipped(fw,
++					"Skipping test for non-existent object %s.",
++					name);
++			}
++		}
++		return FWTS_NOT_EXIST;
++
++	}
++}
++
++/*
++ *  method_name_check
++ *	sanity check object name conforms to ACPI specification
++ */
++static int method_name_check(fwts_framework *fw)
++{
++	fwts_list *methods;
++
++ 	if ((methods = fwts_acpi_object_get_names()) != NULL) {
++		fwts_list_link	*item;
++		bool failed = false;
++
++		fwts_log_info(fw, "Found %d Objects\n", methods->len);
++
++		fwts_list_foreach(item, methods) {
++			char *ptr;
++
++			for (ptr = fwts_list_data(char *, item); *ptr; ptr++) {
++				if (!((*ptr == '\\') ||
++				     (*ptr == '.') ||
++				     (*ptr == '_') ||
++				     (isdigit(*ptr)) ||
++				     (isupper(*ptr))) ) {
++					fwts_failed(fw, LOG_LEVEL_HIGH,
++						"MethodIllegalName",
++						"Method %s contains an illegal "
++						"character: '%c'. This should "
++						"be corrected.",
++						fwts_list_data(char *, item),
++						*ptr);
++					failed = true;
++					break;
++				}
++			}
++		}
++		if (!failed)
++			fwts_passed(fw, "Method names contain legal characters.");
++	}
++
++	return FWTS_OK;
++}
++
++/*
++ *  method_check_type__
++ *	check returned object type
++ */
++static int method_check_type__(
++	fwts_framework *fw,
++	char *name,
++	ACPI_BUFFER *buf,
++	ACPI_OBJECT_TYPE type,
++	char *type_name)
++{
++	ACPI_OBJECT *obj;
++
++	if ((buf == NULL) || (buf->Pointer == NULL)) {
++		method_failed_null_object(fw, name, type_name);
++		return FWTS_ERROR;
++	}
++
++	obj = buf->Pointer;
++
++	if (!method_type_matches(obj->Type, type)) {
++		fwts_failed(fw, LOG_LEVEL_MEDIUM, "MethodReturnBadType",
++			"Method %s did not return %s.", name, type_name);
++		return FWTS_ERROR;
++	}
++	return FWTS_OK;
++}
++
++/*
++ *  method_test_buffer_return
++ *	check if a buffer object was returned
++ */
++static void method_test_buffer_return(
++	fwts_framework *fw,
++	char *name,
++	ACPI_BUFFER *buf,
++	ACPI_OBJECT *obj,
++	void *private)
++{
++	FWTS_UNUSED(private);
++
++	if (method_check_type(fw, name, buf, ACPI_TYPE_BUFFER) == FWTS_OK)
++		fwts_passed(fw, "%s correctly returned a buffer of %" PRIu32 " elements.",
++			name, obj->Buffer.Length);
++}
++
++/*
++ *  method_test_integer_return
++ *	check if an integer object was returned
++ */
++static void method_test_integer_return(
++	fwts_framework *fw,
++	char *name,
++	ACPI_BUFFER *buf,
++	ACPI_OBJECT *obj,
++	void *private)
++{
++	FWTS_UNUSED(obj);
++	FWTS_UNUSED(private);
++
++	if (method_check_type(fw, name, buf, ACPI_TYPE_INTEGER) == FWTS_OK)
++		fwts_passed(fw, "%s correctly returned an integer.", name);
++}
++
++/*
++ *  method_test_string_return
++ *	check if an string object was returned
++ */
++static void method_test_string_return(
++	fwts_framework *fw,
++	char *name,
++	ACPI_BUFFER *buf,
++	ACPI_OBJECT *obj,
++	void *private)
++{
++	FWTS_UNUSED(obj);
++	FWTS_UNUSED(private);
++
++	if (method_check_type(fw, name, buf, ACPI_TYPE_STRING) == FWTS_OK)
++		fwts_passed(fw, "%s correctly returned a string.", name);
++}
++
++/*
++ *  method_test_reference_return
++ *	check if a reference object was returned
++ */
++static void method_test_reference_return(
++	fwts_framework *fw,
++	char *name,
++	ACPI_BUFFER *buf,
++	ACPI_OBJECT *obj,
++	void *private)
++{
++	FWTS_UNUSED(obj);
++	FWTS_UNUSED(private);
++
++	if (method_check_type(fw, name, buf, ACPI_TYPE_LOCAL_REFERENCE) == FWTS_OK)
++		fwts_passed(fw, "%s correctly returned a reference.", name);
++}
++
++/*
++ *  method_test_NULL_return
++ *	check if no object was retuned
++ */
++static void method_test_NULL_return(
++	fwts_framework *fw,
++	char *name,
++	ACPI_BUFFER *buf,
++	ACPI_OBJECT *obj,
++	void *private)
++{
++	FWTS_UNUSED(private);
++
++	/*
++	 *  In ACPICA SLACK mode null returns can be actually
++	 *  forced to return ACPI integers. Blame an errata
++	 *  and Windows compatibility for this mess.
++	 */
++	if (fw->acpica_mode & FWTS_ACPICA_MODE_SLACK) {
++		if ((buf != NULL) && (buf->Pointer != NULL)) {
++			ACPI_OBJECT *objtmp = buf->Pointer;
++			if (method_type_matches(objtmp->Type, ACPI_TYPE_INTEGER)) {
++				fwts_passed(fw, "%s returned an ACPI_TYPE_INTEGER as expected in slack mode.",
++					name);
++				return;
++			}
++		}
++	}
++
++	if (buf && buf->Length && buf->Pointer) {
++		fwts_failed(fw, LOG_LEVEL_MEDIUM, "MethodShouldReturnNothing", "%s returned values, but was expected to return nothing.", name);
++		fwts_log_info(fw, "Object returned:");
++		fwts_acpi_object_dump(fw, obj);
++		fwts_advice(fw,
++			"This probably won't cause any errors, but it should "
++			"be fixed as the AML code is not conforming to the "
++			"expected behaviour as described in the ACPI "
++			"specification.");
++	} else
++		fwts_passed(fw, "%s returned no values as expected.", name);
++}
++
++/*
++ *  method_test_passed_failed_return
++ *	check if 0 or 1 (false/true) integer is returned
++ */
++static void method_test_passed_failed_return(
++	fwts_framework *fw,
++	char *name,
++	ACPI_BUFFER *buf,
++	ACPI_OBJECT *obj,
++	void *private)
++{
++	char *method = (char *)private;
++	if (method_check_type(fw, name, buf, ACPI_TYPE_INTEGER) == FWTS_OK) {
++		uint32_t val = (uint32_t)obj->Integer.Value;
++		if ((val == 0) || (val == 1))
++			method_passed_sane_uint64(fw, name, obj->Integer.Value);
++		else {
++			fwts_failed(fw, LOG_LEVEL_MEDIUM,
++				"MethodReturnZeroOrOne",
++				"%s returned 0x%8.8" PRIx32 ", should return 1 "
++				"(success) or 0 (failed).", method, val);
++			fwts_advice(fw,
++				"Method %s should be returning the correct "
++				"1/0 success/failed return values. "
++				"Unexpected behaviour may occur becauses of "
++				"this error, the AML code does not conform to "
++				"the ACPI specification and should be fixed.",
++				method);
++		}
++	}
++}
++
++/*
++ *  method_test_polling_return
++ *	check if a returned polling time is valid
++ */
++static void method_test_polling_return(
++	fwts_framework *fw,
++	char *name,
++	ACPI_BUFFER *buf,
++	ACPI_OBJECT *obj,
++	void *private)
++{
++	if (method_check_type(fw, name, buf, ACPI_TYPE_INTEGER) == FWTS_OK) {
++		char *method = (char *)private;
++		if (obj->Integer.Value < 36000) {
++			fwts_passed(fw,
++				"%s correctly returned sane looking value "
++				"%f seconds", method,
++				(float)obj->Integer.Value / 10.0);
++		} else {
++			fwts_failed(fw, LOG_LEVEL_MEDIUM,
++				"MethodPollTimeTooLong",
++				"%s returned a value %f seconds > (1 hour) "
++				"which is probably incorrect.",
++				method, (float)obj->Integer.Value / 10.0);
++			fwts_advice(fw,
++				"The method is returning a polling interval "
++				"which is very long and hence most probably "
++				"incorrect.");
++		}
++	}
++}
++
++
++/*
++ *  Common types that can be returned. This is not a complete
++ *  list but it does cover the types we expect to return from
++ *  an ACPI evaluation.
++ */
++static const char *method_type_name(const ACPI_OBJECT_TYPE type)
++{
++	switch (type) {
++	case ACPI_TYPE_INTEGER:
++		return "integer";
++	case ACPI_TYPE_STRING:
++		return "string";
++	case ACPI_TYPE_BUFFER:
++		return "buffer";
++	case ACPI_TYPE_PACKAGE:
++		return "package";
++	case ACPI_TYPE_BUFFER_FIELD:
++		return "buffer_field";
++	case ACPI_TYPE_LOCAL_REFERENCE:
++		return "reference";
++	case ACPI_TYPE_INTBUF:
++		return "integer or buffer";
++	default:
++		return "unknown";
++	}
++}
++
++/*
++ *  method_package_elements_all_type()
++ *	sanity check fields in a package that all have
++ *	the same type
++ */
++static int method_package_elements_all_type(
++	fwts_framework *fw,
++	const char *name,
++	const char *objname,
++	const ACPI_OBJECT *obj,
++	const ACPI_OBJECT_TYPE type)
++{
++	uint32_t i;
++	bool failed = false;
++	char tmp[128];
++
++	for (i = 0; i < obj->Package.Count; i++) {
++		if (!method_type_matches(obj->Package.Elements[i].Type, type)) {
++			snprintf(tmp, sizeof(tmp), "Method%sElementType", objname);
++			fwts_failed(fw, LOG_LEVEL_MEDIUM, tmp,
++				"%s package element %" PRIu32 " was not the expected "
++				"type '%s', was instead type '%s'.",
++				name, i,
++				method_type_name(type),
++				method_type_name(obj->Package.Elements[i].Type));
++			failed = true;
++		}
++	}
++
++	return failed ? FWTS_ERROR: FWTS_OK;
++}
++
++typedef struct {
++	ACPI_OBJECT_TYPE type;	/* Type */
++	const char 	*name;	/* Field name */
++} fwts_package_element;
++
++/*
++ *  method_package_elements_type()
++ *	sanity check fields in a package that all have
++ *	the same type
++ */
++static int method_package_elements_type(
++	fwts_framework *fw,
++	const char *name,
++	const char *objname,
++	const ACPI_OBJECT *obj,
++	const fwts_package_element *info,
++	const uint32_t count)
++{
++	uint32_t i;
++	bool failed = false;
++	char tmp[128];
++
++	if (obj->Package.Count != count)
++		return FWTS_ERROR;
++
++	for (i = 0; i < obj->Package.Count; i++) {
++		if (!method_type_matches(obj->Package.Elements[i].Type, info[i].type)) {
++			snprintf(tmp, sizeof(tmp), "Method%sElementType", objname);
++			fwts_failed(fw, LOG_LEVEL_MEDIUM, tmp,
++				"%s package element %" PRIu32 " (%s) was not the expected "
++				"type '%s', was instead type '%s'.",
++				name, i, info[i].name,
++				method_type_name(info[i].type),
++				method_type_name(obj->Package.Elements[i].Type));
++			failed = true;
++		}
++	}
++
++	return failed ? FWTS_ERROR: FWTS_OK;
++}
++
++/****************************************************************************/
++
++/*
++ * Section 5.6 ACPI Event Programming Model
++ */
++static void method_test_AEI_return(
++	fwts_framework *fw,
++	char *name,
++	ACPI_BUFFER *buf,
++	ACPI_OBJECT *obj,
++	void *private)
++{
++	ACPI_STATUS status;
++	ACPI_RESOURCE *resource;
++	ACPI_RESOURCE_GPIO* gpio;
++	bool failed = false;
++
++	FWTS_UNUSED(private);
++
++	if (method_check_type(fw, name, buf, ACPI_TYPE_BUFFER) != FWTS_OK)
++		return;
++
++	status = AcpiBufferToResource(obj->Buffer.Pointer, obj->Buffer.Length, &resource);
++	if (ACPI_FAILURE(status))
++		return;
++
++	do {
++		if (resource->Type == ACPI_RESOURCE_TYPE_GPIO) {
++			gpio = &resource->Data.Gpio;
++			if (gpio->ConnectionType != ACPI_RESOURCE_GPIO_TYPE_INT) {
++				failed = true;
++				fwts_failed(fw, LOG_LEVEL_MEDIUM,
++					"Method_AEIBadGpioElement",
++					"%s should contain only GPIO Connection Type 0, got %" PRIu32,
++					name, gpio->ConnectionType);
++			}
++		} else {
++			failed = true;
++			fwts_failed(fw, LOG_LEVEL_MEDIUM,
++				"Method_AEIBadElement",
++				"%s should contain only Resource Type 17, got%" PRIu32,
++					name, resource->Type);
++		}
++
++		resource = ACPI_NEXT_RESOURCE(resource);
++	} while (resource->Type != ACPI_RESOURCE_TYPE_END_TAG);
++
++	if (!failed)
++		method_passed_sane(fw, name, "buffer");
++}
++
++static int method_test_AEI(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_OPTIONAL,
++		"_AEI", NULL, 0, method_test_AEI_return, NULL);
++}
++
++static void check_evt_event (
++	fwts_framework *fw,
++	ACPI_RESOURCE_GPIO *gpio)
++{
++	ACPI_OBJECT arg[1];
++	ACPI_HANDLE evt_handle;
++	ACPI_STATUS status;
++	char path[256];
++	uint16_t i;
++
++	/* Skip the leading spaces in ResourceSource. */
++	for (i = 0; i < gpio->ResourceSource.StringLength; i++) {
++		if (gpio->ResourceSource.StringPtr[i] != ' ')
++			break;
++	}
++
++	if (i == gpio->ResourceSource.StringLength) {
++		fwts_log_warning(fw, "Invalid ResourceSource");
++		return;
++	}
++
++	/* Get the handle of return;the _EVT method. */
++	snprintf (path, 251, "%s._EVT", &gpio->ResourceSource.StringPtr[i]);
++
++	status = AcpiGetHandle (NULL, path, &evt_handle);
++	if (ACPI_FAILURE(status)) {
++		fwts_log_warning(fw, "Failed to find valid handle for _EVT method (0x%x), %s",	status, path);
++		return;
++	}
++
++	/* Call the _EVT method with all the pins defined for the GpioInt */
++	for (i = 0; i < gpio->PinTableLength; i++) {
++		ACPI_OBJECT_LIST arg_list;
++
++		arg[0].Type = ACPI_TYPE_INTEGER;
++		arg[0].Integer.Value = gpio->PinTable[i];
++		arg_list.Count = 1;
++		arg_list.Pointer = arg;
++
++		method_evaluate_found_method(fw, path, method_test_NULL_return, NULL, &arg_list);
++	}
++}
++
++static void method_test_EVT_return (
++	fwts_framework *fw,
++	char *name,
++	ACPI_BUFFER *buf,
++	ACPI_OBJECT *obj,
++	void *private)
++{
++	ACPI_RESOURCE *resource;
++	ACPI_STATUS   status;
++
++	FWTS_UNUSED(private);
++
++	if (method_check_type(fw, name, buf, ACPI_TYPE_BUFFER) != FWTS_OK)
++		return;
++
++	status = AcpiBufferToResource(obj->Buffer.Pointer, obj->Buffer.Length, &resource);
++	if (ACPI_FAILURE(status))
++		return;
++
++	do {
++		if (!resource->Length) {
++			fwts_log_warning(fw, "Invalid zero length descriptor in resource list\n");
++			break;
++		}
++
++		if (resource->Type == ACPI_RESOURCE_TYPE_GPIO &&
++				resource->Data.Gpio.ConnectionType == ACPI_RESOURCE_GPIO_TYPE_INT)
++				check_evt_event(fw, &resource->Data.Gpio);
++
++		resource = ACPI_NEXT_RESOURCE(resource);
++	} while (resource->Type != ACPI_RESOURCE_TYPE_END_TAG);
++}
++
++static int method_test_EVT(fwts_framework *fw)
++{
++	int ret;
++
++	/* Only test the _EVT method with pins defined in AEI. */
++	ret = method_evaluate_method(fw, METHOD_OPTIONAL | METHOD_SILENT,
++		"_AEI", NULL, 0, method_test_EVT_return, NULL);
++
++	if (ret == FWTS_NOT_EXIST)
++		fwts_skipped(fw, "Skipping test for non-existant object _EVT.");
++
++	return ret;
++}
++
++/*
++ * Section 5.7 Predefined Objects
++ */
++
++static void method_test_DLM_return(
++	fwts_framework *fw,
++	char *name,
++	ACPI_BUFFER *buf,
++	ACPI_OBJECT *obj,
++	void *private)
++{
++	uint32_t i;
++	bool failed = false;
++
++	FWTS_UNUSED(private);
++
++	if (method_check_type(fw, name, buf, ACPI_TYPE_PACKAGE) != FWTS_OK)
++		return;
++
++	if (method_package_elements_all_type(fw, name, "_DLM", obj, ACPI_TYPE_PACKAGE) != FWTS_OK)
++		return;
++
++	/* Could be one or more packages */
++	for (i = 0; i < obj->Package.Count; i++) {
++		ACPI_OBJECT *pkg = &obj->Package.Elements[i];
++
++		if (pkg->Package.Count != 2) {
++			fwts_failed(fw, LOG_LEVEL_MEDIUM,
++				"Method_DLMSubPackageElementCount",
++				"%s sub-package %" PRIu32 " was expected to "
++				"have 2 elements, got %" PRIu32 " elements instead.",
++				name, i, pkg->Package.Count);
++			failed = true;
++			continue;
++		}
++
++		if (pkg->Package.Elements[0].Type != ACPI_TYPE_LOCAL_REFERENCE) {
++			fwts_failed(fw, LOG_LEVEL_MEDIUM,
++				"Method_DLMBadSubPackageReturnType",
++				"%s sub-package %" PRIu32
++				" element 0 is not a reference.",
++				name, i);
++			failed = true;
++		}
++
++		if (pkg->Package.Elements[1].Type != ACPI_TYPE_LOCAL_REFERENCE &&
++		    pkg->Package.Elements[1].Type != ACPI_TYPE_BUFFER) {
++			fwts_failed(fw, LOG_LEVEL_MEDIUM,
++				"Method_DLMBadSubPackageReturnType",
++				"%s sub-package %" PRIu32
++				" element 1 is not a reference or a buffer.",
++				name, i);
++			failed = true;
++		}
++	}
++
++	if (!failed)
++		method_passed_sane(fw, name, "package");
++}
++
++static int method_test_DLM(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_OPTIONAL,
++		"_DLM", NULL, 0, method_test_DLM_return, NULL);
++}
++
++/*
++ * Section 5.8 System Configuration Objects
++ */
++static int method_test_PIC(fwts_framework *fw)
++{
++	ACPI_OBJECT arg[1];
++	int i, ret;
++	arg[0].Type = ACPI_TYPE_INTEGER;
++
++	for (i = 0; i < 3; i++) {
++		arg[0].Integer.Value = i;
++		ret = method_evaluate_method(fw, METHOD_OPTIONAL,
++			"_PIC", arg, 1, method_test_NULL_return, NULL);
++
++		if (ret != FWTS_OK)
++			break;
++	}
++	return ret;
++}
++
++
++/*
++ * Section 6.1 Device Identification Objects
++ */
++static int method_test_DDN(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_OPTIONAL,
++		"_DDN", NULL, 0, method_test_string_return, NULL);
++}
++
++static bool method_valid_HID_string(char *str)
++{
++	if (strlen(str) == 7) {
++		/* PNP ID, must be 3 capitals followed by 4 hex */
++		if (!isupper(str[0]) ||
++		    !isupper(str[1]) ||
++		    !isupper(str[2])) return false;
++		if (!isxdigit(str[3]) ||
++		    !isxdigit(str[4]) ||
++		    !isxdigit(str[5]) ||
++		    !isxdigit(str[6])) return false;
++		return true;
++	}
++
++	if (strlen(str) == 8) {
++		/* ACPI ID, must be 4 capitals or digits followed by 4 hex */
++		if ((!isupper(str[0]) && !isdigit(str[0])) ||
++		    (!isupper(str[1]) && !isdigit(str[1])) ||
++		    (!isupper(str[2]) && !isdigit(str[2])) ||
++		    (!isupper(str[3]) && !isdigit(str[3]))) return false;
++		if (!isxdigit(str[4]) ||
++		    !isxdigit(str[5]) ||
++		    !isxdigit(str[6]) ||
++		    !isxdigit(str[7])) return false;
++		return true;
++	}
++
++	return false;
++}
++
++static bool method_valid_EISA_ID(uint32_t id, char *buf, size_t buf_len)
++{
++	snprintf(buf, buf_len, "%c%c%c%02" PRIX32 "%02" PRIX32,
++		0x40 + ((id >> 2) & 0x1f),
++		0x40 + ((id & 0x3) << 3) + ((id >> 13) & 0x7),
++		0x40 + ((id >> 8) & 0x1f),
++		(id >> 16) & 0xff, (id >> 24) & 0xff);
++
++	/* 3 chars in EISA ID must be upper case */
++	if (!isupper(buf[0]) ||
++	    !isupper(buf[1]) ||
++	    !isupper(buf[2])) return false;
++
++	/* Last 4 digits are always going to be hex, so pass */
++	return true;
++}
++
++static void method_test_HID_return(
++	fwts_framework *fw,
++	char *name,
++	ACPI_BUFFER *buf,
++	ACPI_OBJECT *obj,
++	void *private)
++{
++	char tmp[8];
++
++	FWTS_UNUSED(buf);
++	FWTS_UNUSED(private);
++
++	if (obj == NULL) {
++		method_failed_null_object(fw, name, "a buffer or integer");
++		return;
++	}
++
++	switch (obj->Type) {
++	case ACPI_TYPE_STRING:
++		if (obj->String.Pointer) {
++			if (method_valid_HID_string(obj->String.Pointer))
++				fwts_passed(fw,
++					"%s returned a string '%s' "
++					"as expected.",
++					name, obj->String.Pointer);
++			else
++				fwts_failed(fw, LOG_LEVEL_MEDIUM,
++					"MethodHIDInvalidString",
++					"%s returned a string '%s' "
++					"but it was not a valid PNP ID or a "
++					"valid ACPI ID.",
++					name, obj->String.Pointer);
++		} else {
++			fwts_failed(fw, LOG_LEVEL_MEDIUM,
++				"Method_HIDNullString",
++				"%s returned a NULL string.", name);
++		}
++		break;
++	case ACPI_TYPE_INTEGER:
++		if (method_valid_EISA_ID((uint32_t)obj->Integer.Value,
++			tmp, sizeof(tmp)))
++			fwts_passed(fw, "%s returned an integer "
++				"0x%8.8" PRIx64 " (EISA ID %s).",
++				name, (uint64_t)obj->Integer.Value, tmp);
++		else
++			fwts_failed(fw, LOG_LEVEL_MEDIUM,
++				"MethodHIDInvalidInteger",
++				"%s returned a integer 0x%8.8" PRIx64 " "
++				"(EISA ID %s) but the this is not a valid "
++				"EISA ID encoded PNP ID.",
++				name, (uint64_t)obj->Integer.Value, tmp);
++		break;
++	default:
++		fwts_failed(fw, LOG_LEVEL_MEDIUM, "Method_HIDBadReturnType",
++			"%s did not return a string or an integer.", name);
++		break;
++	}
++}
++
++static int method_test_HID(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_OPTIONAL,
++		"_HID", NULL, 0, method_test_HID_return, NULL);
++}
++
++static void method_valid_CID_Type(
++	fwts_framework *fw,
++	char *name,
++	ACPI_OBJECT *obj)
++{
++	char tmp[8];
++
++	switch (obj->Type) {
++	case ACPI_TYPE_STRING:
++		if (obj->String.Pointer) {
++			if (method_valid_HID_string(obj->String.Pointer))
++				fwts_passed(fw,
++					"%s returned a string '%s' "
++					"as expected.",
++					name, obj->String.Pointer);
++			else
++				fwts_failed(fw, LOG_LEVEL_MEDIUM,
++					"MethodCIDInvalidString",
++					"%s returned a string '%s' "
++					"but it was not a valid PNP ID or a "
++					"valid ACPI ID.",
++					name, obj->String.Pointer);
++		} else {
++			fwts_failed(fw, LOG_LEVEL_MEDIUM,
++				"Method_CIDNullString",
++				"%s returned a NULL string.", name);
++		}
++		break;
++	case ACPI_TYPE_INTEGER:
++		if (method_valid_EISA_ID((uint32_t)obj->Integer.Value,
++			tmp, sizeof(tmp)))
++			fwts_passed(fw, "%s returned an integer "
++				"0x%8.8" PRIx64 " (EISA ID %s).",
++				name, (uint64_t)obj->Integer.Value, tmp);
++		else
++			fwts_failed(fw, LOG_LEVEL_MEDIUM,
++				"MethodCIDInvalidInteger",
++				"%s returned a integer 0x%8.8" PRIx64 " "
++				"(EISA ID %s) but the this is not a valid "
++				"EISA ID encoded PNP ID.",
++				name, (uint64_t)obj->Integer.Value, tmp);
++		break;
++	}
++}
++
++static void method_test_CID_return(
++	fwts_framework *fw,
++	char *name,
++	ACPI_BUFFER *buf,
++	ACPI_OBJECT *obj,
++	void *private)
++{
++	uint32_t i;
++
++	FWTS_UNUSED(buf);
++	FWTS_UNUSED(private);
++
++	if (obj == NULL) {
++		method_failed_null_object(fw, name, "a buffer or integer");
++		return;
++	}
++
++	switch (obj->Type) {
++	case ACPI_TYPE_STRING:
++	case ACPI_TYPE_INTEGER:
++		method_valid_CID_Type(fw, name, obj);
++		break;
++	case ACPI_TYPE_PACKAGE:
++		if (method_package_count_min(fw, name, "_CID", obj, 1) != FWTS_OK)
++			return;
++
++		for (i = 0; i < obj->Package.Count; i++){
++			ACPI_OBJECT *pkg = &obj->Package.Elements[i];
++			method_valid_CID_Type(fw, name, pkg);
++		}
++		break;
++	default:
++		fwts_failed(fw, LOG_LEVEL_MEDIUM, "Method_CIDBadReturnType",
++			"%s did not return a string or an integer.", name);
++		break;
++	}
++}
++
++static int method_test_CID(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_OPTIONAL,
++		"_CID", NULL, 0, method_test_CID_return, NULL);
++}
++
++static void method_test_MLS_return(
++	fwts_framework *fw,
++	char *name,
++	ACPI_BUFFER *buf,
++	ACPI_OBJECT *obj,
++	void *private)
++{
++	uint32_t i;
++	bool failed = false;
++
++	FWTS_UNUSED(private);
++
++	if (method_check_type(fw, name, buf, ACPI_TYPE_PACKAGE) != FWTS_OK)
++		return;
++
++	if (method_package_elements_all_type(fw, name, "_MLS", obj, ACPI_TYPE_PACKAGE) != FWTS_OK)
++		return;
++
++	/* Could be one or more packages */
++	for (i = 0; i < obj->Package.Count; i++) {
++		ACPI_OBJECT *pkg = &obj->Package.Elements[i];
++
++		if (pkg->Package.Count != 2) {
++			fwts_failed(fw, LOG_LEVEL_MEDIUM,
++				"Method_MLSSubPackageElementCount",
++				"%s sub-package %" PRIu32 " was expected to "
++				"have 2 elements, got %" PRIu32 " elements instead.",
++				name, i, pkg->Package.Count);
++			failed = true;
++			continue;
++		}
++
++		if (pkg->Package.Elements[0].Type != ACPI_TYPE_STRING) {
++			fwts_failed(fw, LOG_LEVEL_MEDIUM,
++				"Method_MLSBadSubPackageReturnType",
++				"%s sub-package %" PRIu32
++				" element 0 is not a string.",
++				name, i);
++			failed = true;
++		}
++
++		if (pkg->Package.Elements[1].Type != ACPI_TYPE_BUFFER) {
++			fwts_failed(fw, LOG_LEVEL_MEDIUM,
++				"Method_MLSBadSubPackageReturnType",
++				"%s sub-package %" PRIu32
++				" element 1 is not a buffer.",
++				name, i);
++			failed = true;
++		}
++	}
++
++	if (!failed)
++		method_passed_sane(fw, name, "package");
++}
++
++static int method_test_MLS(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_OPTIONAL,
++		"_MLS", NULL, 0, method_test_MLS_return, NULL);
++}
++static int method_test_HRV(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_OPTIONAL,
++		"_HRV", NULL, 0, method_test_integer_return, NULL);
++}
++
++static int method_test_STR(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_OPTIONAL,
++		"_STR", NULL, 0, method_test_buffer_return, NULL);
++}
++
++static void method_test_PLD_return(
++	fwts_framework *fw,
++	char *name,
++	ACPI_BUFFER *buf,
++	ACPI_OBJECT *obj,
++	void *private)
++{
++	FWTS_UNUSED(private);
++
++	if (method_check_type(fw, name, buf, ACPI_TYPE_PACKAGE) != FWTS_OK)
++		return;
++
++	/* All elements in the package must be buffers */
++	if (method_package_elements_all_type(fw, name, "_PLD", obj, ACPI_TYPE_BUFFER) != FWTS_OK)
++		return;
++
++	method_passed_sane(fw, name, "package");
++}
++
++static int method_test_PLD(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_OPTIONAL,
++		"_PLD", NULL, 0, method_test_PLD_return, NULL);
++}
++
++static void method_test_SUB_return(
++	fwts_framework *fw,
++	char *name,
++	ACPI_BUFFER *buf,
++	ACPI_OBJECT *obj,
++	void *private)
++{
++	FWTS_UNUSED(buf);
++	FWTS_UNUSED(private);
++
++	if (obj == NULL) {
++		method_failed_null_object(fw, name, "a buffer or integer");
++		return;
++	}
++
++	if (obj->Type == ACPI_TYPE_STRING)
++		if (obj->String.Pointer) {
++			if (method_valid_HID_string(obj->String.Pointer))
++				fwts_passed(fw,
++					"%s returned a string '%s' "
++					"as expected.",
++					name, obj->String.Pointer);
++			else
++				fwts_failed(fw, LOG_LEVEL_MEDIUM,
++					"MethodSUBInvalidString",
++					"%s returned a string '%s' "
++					"but it was not a valid PNP ID or a "
++					"valid ACPI ID.",
++					name, obj->String.Pointer);
++		} else {
++			fwts_failed(fw, LOG_LEVEL_MEDIUM,
++				"Method_SUBNullString",
++				"%s returned a NULL string.", name);
++		}
++	else {
++		fwts_failed(fw, LOG_LEVEL_MEDIUM, "Method_UIDBadReturnType",
++			"Method _SUB did not return a string or an integer.");
++	}
++}
++
++
++static int method_test_SUB(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_OPTIONAL,
++		"_SUB", NULL, 0, method_test_SUB_return, NULL);
++}
++
++static int method_test_SUN(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_OPTIONAL,
++		"_SUN", NULL, 0, method_test_integer_return, NULL);
++}
++
++static void method_test_UID_return(
++	fwts_framework *fw,
++	char *name,
++	ACPI_BUFFER *buf,
++	ACPI_OBJECT *obj,
++	void *private)
++{
++	FWTS_UNUSED(buf);
++	FWTS_UNUSED(private);
++
++	if (obj == NULL) {
++		method_failed_null_object(fw, name, "a buffer or integer");
++		return;
++	}
++
++	switch (obj->Type) {
++	case ACPI_TYPE_STRING:
++		if (obj->String.Pointer)
++			fwts_passed(fw,
++				"%s returned a string '%s' as expected.",
++				name, obj->String.Pointer);
++		else
++			fwts_failed(fw, LOG_LEVEL_MEDIUM,
++				"Method_UIDNullString",
++				"%s returned a NULL string.", name);
++		break;
++	case ACPI_TYPE_INTEGER:
++		method_passed_sane_uint64(fw, name, obj->Integer.Value);
++		break;
++	default:
++		fwts_failed(fw, LOG_LEVEL_MEDIUM, "Method_UIDBadReturnType",
++			"Method %s did not return a string or an integer.", name);
++		break;
++	}
++}
++
++static int method_test_UID(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_OPTIONAL,
++		"_UID", NULL, 0, method_test_UID_return, NULL);
++}
++
++/*
++ *  Section 6.2 Device Configurations Objects
++ */
++static void method_test_CRS_size(
++	fwts_framework *fw,
++	const char *name,		/* full _CRS or _PRS path name */
++	const char *objname,		/* name of _CRS or _PRS object */
++	const char *tag,		/* error log tag */
++	const size_t crs_length,	/* size of _CRS buffer */
++	const size_t hdr_length,	/* size of _CRS header */
++	const size_t data_length,	/* length of _CRS data w/o header */
++	const size_t min,		/* minimum allowed _CRS data size */
++	const size_t max,		/* maximum allowed _CRS data size */
++	bool *passed)			/* pass/fail flag */
++{
++	if (crs_length < data_length + hdr_length) {
++		fwts_failed(fw, LOG_LEVEL_HIGH, tag,
++			"%s Resource size is %zd bytes long but "
++			"the size stated in the %s buffer header  "
++			"is %zd and hence is longer. The resource "
++			"buffer is too short.",
++			name, crs_length, objname, data_length);
++		*passed = false;
++		return;
++	}
++
++	if ((data_length < min) || (data_length > max)) {
++		if (min != max) {
++			fwts_failed(fw, LOG_LEVEL_MEDIUM, tag,
++				"%s Resource data size was %zd bytes long, "
++				"expected it to be between %zd and %zd bytes",
++				name, data_length, min, max);
++			*passed = false;
++		} else {
++			fwts_failed(fw, LOG_LEVEL_MEDIUM, tag,
++				"%s Resource data size was %zd bytes long, "
++				"expected it to be %zd bytes",
++				name, data_length, min);
++			*passed = false;
++		}
++	}
++}
++
++static void method_test_CRS_small_size(
++	fwts_framework *fw,
++	const char *name,
++	const char *objname,
++	const uint8_t *data,
++	const size_t crs_length,
++	const size_t min,
++	const size_t max,
++	bool *passed)
++{
++	size_t data_length = data[0] & 7;
++	char tmp[128];
++
++	snprintf(tmp, sizeof(tmp), "Method%sSmallResourceSize", objname);
++
++	method_test_CRS_size(fw, name, objname, tmp,
++		crs_length, 1, data_length, min, max, passed);
++}
++
++
++/*
++ *  CRS small resource checks, simple checking
++ */
++static void method_test_CRS_small_resource_items(
++	fwts_framework *fw,
++	const char *name,
++	const char *objname,
++	const uint8_t *data,
++	const size_t length,
++	bool *passed,
++	const char **tag)
++{
++	uint8_t tag_item = (data[0] >> 3) & 0xf;
++	char tmp[128];
++
++	static const char *types[] = {
++		"Reserved",
++		"Reserved",
++		"Reserved",
++		"Reserved",
++		"IRQ Descriptor",
++		"DMA Descriptor",
++		"Start Dependent Functions Descriptor",
++		"End Dependent Functions Descriptor",
++		"I/O Port Descriptor",
++		"Fixed Location I/O Port Descriptor",
++		"Fixed DMA Descriptor",
++		"Reserved",
++		"Reserved",
++		"Reserved",
++		"Vendor Defined Descriptor",
++		"End Tag Descriptor"
++	};
++
++	switch (tag_item) {
++	case 0x4: /* 6.4.2.1 IRQ Descriptor */
++		method_test_CRS_small_size(fw, name, objname, data, length, 2, 3, passed);
++		break;
++	case 0x5: /* 6.4.2.2 DMA Descriptor */
++		method_test_CRS_small_size(fw, name, objname, data, length, 2, 2, passed);
++		if (!*passed)	/* Too short, abort */
++			break;
++		if ((data[2] & 3) == 3) {
++			snprintf(tmp, sizeof(tmp), "Method%sDmaDescriptor", objname);
++			fwts_failed(fw, LOG_LEVEL_HIGH, tmp,
++				"%s DMA transfer type preference is 0x%" PRIx8
++				" which is reserved and invalid. See "
++				"Section 6.4.2.2 of the ACPI specification.",
++				name, data[2] & 3);
++			*passed = false;
++		}
++		break;
++	case 0x6: /* 6.4.2.3 Start Dependent Functions Descriptor */
++		method_test_CRS_small_size(fw, name, objname, data, length, 0, 1, passed);
++		break;
++	case 0x7: /* 6.4.2.4 End Dependent Functions Descriptor */
++		method_test_CRS_small_size(fw, name, objname, data, length, 0, 0, passed);
++		break;
++	case 0x8: /* 6.4.2.5 I/O Port Descriptor */
++		method_test_CRS_small_size(fw, name, objname, data, length, 7, 7, passed);
++		if (!*passed)	/* Too short, abort */
++			break;
++		if (data[1] & 0xfe) {
++			snprintf(tmp, sizeof(tmp), "Method%sIoPortInfoReservedNonZero", objname);
++			fwts_failed(fw, LOG_LEVEL_LOW, tmp,
++				"%s I/O Port Descriptor Information field "
++				"has reserved bits that are non-zero, got "
++				"0x%" PRIx8 " and expected 0 or 1 for this "
++				"field. ", name, data[1]);
++			*passed = false;
++		}
++		if (((data[1] & 1) == 0) && (data[3] > 3)) {
++			snprintf(tmp, sizeof(tmp), "Method%sIoPortInfoMinBase10BitAddr", objname);
++			fwts_failed(fw, LOG_LEVEL_LOW, tmp,
++				"%s I/O Port Descriptor range minimum "
++				"base address is more than 10 bits however "
++				"the Information field indicates that only "
++				"a 10 bit address is being used.", name);
++			*passed = false;
++		}
++		if (((data[1] & 1) == 0) && (data[5] > 3)) {
++			snprintf(tmp, sizeof(tmp), "Method%sIoPortInfoMaxBase10BitAddr", objname);
++			fwts_failed(fw, LOG_LEVEL_LOW, tmp,
++				"%s I/O Port Descriptor range maximum "
++				"base address is more than 10 bits however "
++				"the Information field indicates that only "
++				"a 10 bit address is being used.", name);
++			*passed = false;
++		}
++		break;
++	case 0x9: /* 6.4.2.6 Fixed Location I/O Port Descriptor */
++		method_test_CRS_small_size(fw, name, objname, data, length, 3, 3, passed);
++		break;
++	case 0xa: /* 6.4.2.7 Fixed DMA Descriptor */
++		method_test_CRS_small_size(fw, name, objname, data, length, 5, 5, passed);
++		if (!*passed)	/* Too short, abort */
++			break;
++		if (data[5] > 5) {
++			snprintf(tmp, sizeof(tmp), "Method%sFixedDmaTransferWidth", objname);
++			fwts_failed(fw, LOG_LEVEL_HIGH, tmp,
++				"%s DMA transfer width is 0x%" PRIx8
++				" which is reserved and invalid. See "
++				"Section 6.4.2.7 of the ACPI specification.",
++				name, data[5]);
++			*passed = false;
++		}
++		break;
++	case 0xe: /* 6.4.2.8 Vendor-Defined Descriptor */
++		method_test_CRS_small_size(fw, name, objname, data, length, 1, 7, passed);
++		break;
++	case 0xf: /* 6.4.2.9 End Tag */
++		method_test_CRS_small_size(fw, name, objname, data, length, 1, 1, passed);
++		break;
++	default:
++		snprintf(tmp, sizeof(tmp), "Method%sUnkownSmallResourceItem", objname);
++		fwts_failed(fw, LOG_LEVEL_LOW, tmp,
++			"%s tag bits 6:3 is an undefined "
++			"small tag item name, value 0x%" PRIx8 ".",
++			name, tag_item);
++		fwts_advice(fw,
++			"A small resource data type tag (byte 0, "
++			"bits 6:3 of the %s buffer) contains "
++			"an undefined small tag item 'name'. "
++			"The %s buffer is therefore undefined "
++			"and can't be used.  See section "
++			"'6.4.2 Small Resource Data Type' of the ACPI "
++			"specification, and also table 6-161.",
++			objname, objname);
++		*passed = false;
++		break;
++	}
++
++	*tag = types[tag_item];
++}
++
++static void method_test_CRS_large_size(
++	fwts_framework *fw,
++	const char *name,
++	const char *objname,
++	const uint8_t *data,
++	const size_t crs_length,
++	const size_t min,
++	const size_t max,
++	bool *passed)
++{
++	size_t data_length;
++	char tmp[128];
++
++	/* Small _CRS resources have a 3 byte header */
++	if (crs_length < 3) {
++		snprintf(tmp, sizeof(tmp), "Method%sBufferTooSmall", objname);
++		fwts_failed(fw, LOG_LEVEL_MEDIUM, tmp,
++			"%s should return a buffer of at least three bytes in length.", name);
++		*passed = false;
++		return;
++	}
++
++	data_length = (size_t)data[1] + ((size_t)data[2] << 8);
++
++	snprintf(tmp, sizeof(tmp), "Method%sLargeResourceSize",objname);
++	method_test_CRS_size(fw, name, objname, tmp,
++		crs_length, 3, data_length, min, max, passed);
++}
++
++/*
++ * Some CRS value fetching helper functions.  We handle all the
++ * addresses and lengths in 64 bits to make life easier
++ */
++static uint64_t method_CRS_val64(const uint8_t *data)
++{
++	uint64_t val =
++		((uint64_t)data[7] << 56) | ((uint64_t)data[6] << 48) |
++		((uint64_t)data[5] << 40) | ((uint64_t)data[4] << 32) |
++		((uint64_t)data[3] << 24) | ((uint64_t)data[2] << 16) |
++		((uint64_t)data[1] << 8)  | (uint64_t)data[0];
++
++	return val;
++}
++
++static uint64_t method_CRS_val32(const uint8_t *data)
++{
++	uint64_t val =
++		((uint64_t)data[3] << 24) | ((uint64_t)data[2] << 16) |
++		((uint64_t)data[1] << 8)  | (uint64_t)data[0];
++
++	return val;
++}
++
++static uint64_t method_CRS_val24(const uint8_t *data)
++{
++	/* 24 bit values assume lower 8 bits are zero */
++	uint64_t val =
++		((uint64_t)data[1] << 16) | ((uint64_t)data[0] << 8);
++
++	return val;
++}
++
++static uint64_t method_CRS_val16(const uint8_t *data)
++{
++	uint64_t val =
++		((uint64_t)data[1] << 8) | (uint64_t)data[0];
++
++	return val;
++}
++
++/*
++ *  Sanity check addresses according to table 6-179 of ACPI spec
++ */
++static void method_test_CRS_mif_maf(
++	fwts_framework *fw,
++	const char *name,		/* Full _CRS or _PRS path name */
++	const char *objname,		/* _CRS or _PRS name */
++	const uint8_t flag,		/* _MIF _MAF flag field */
++	const uint64_t min,		/* Min address */
++	const uint64_t max,		/* Max address */
++	const uint64_t len,		/* Range length */
++	const uint64_t granularity,	/* Address granularity */
++	const char *tag,		/* failed error tag */
++	const char *type,		/* Resource type */
++	bool *passed)
++{
++	char tmp[128];
++	uint8_t mif = (flag >> 2) & 1;
++	uint8_t maf = (flag >> 3) & 1;
++
++	static char *mif_maf_advice =
++		"See section '6.4.3.5 Address Space Resource Descriptors' "
++		"table 6-179 of the ACPI specification for more details "
++		"about how the _MIF, _MAF and memory range and granularity "
++		"rules apply. Typically the kernel does not care about these "
++		"being correct, so this is a minor issue.";
++
++	/* Table 6-179 Valid combination of Address Space Descriptors fields */
++	if (len == 0) {
++		if ((mif == 1) && (maf == 1)) {
++			snprintf(tmp, sizeof(tmp), "Method%s%sMifMafBothOne", objname, tag);
++			fwts_failed(fw, LOG_LEVEL_MEDIUM,
++				tmp,
++				"%s %s _MIF and _MAF flags are both "
++				"set to one which is invalid when "
++				"the length field is 0.",
++				name, type);
++			fwts_advice(fw, "%s", mif_maf_advice);
++			*passed = false;
++		}
++		if ((mif == 1) && (min % (granularity + 1) != 0)) {
++			snprintf(tmp, sizeof(tmp), "Method%s%sMinNotMultipleOfGran", objname, tag);
++			fwts_failed(fw, LOG_LEVEL_MEDIUM,
++				tmp,
++				"%s %s _MIN address is not a multiple "
++				"of the granularity when _MIF is 1.",
++				name, type);
++			fwts_advice(fw, "%s", mif_maf_advice);
++			*passed = false;
++		}
++		if ((maf == 1) && (max % (granularity - 1) != 0)) {
++			snprintf(tmp, sizeof(tmp), "Method%s%sMaxNotMultipleOfGran", objname, tag);
++			fwts_failed(fw, LOG_LEVEL_MEDIUM,
++				tmp,
++				"%s %s _MAX address is not a multiple "
++				"of the granularity when _MAF is 1.",
++				name, type);
++			fwts_advice(fw, "%s", mif_maf_advice);
++			*passed = false;
++		}
++	} else {
++		if ((mif == 0) && (maf == 0) &&
++		    (len % (granularity + 1) != 0)) {
++			snprintf(tmp, sizeof(tmp), "Method%s%sLenNotMultipleOfGran", objname, tag);
++			fwts_failed(fw, LOG_LEVEL_MEDIUM,
++				tmp,
++				"%s %s length is not a multiple "
++				"of the granularity when _MIF "
++				"and _MIF are 0.",
++				name, type);
++			fwts_advice(fw, "%s", mif_maf_advice);
++			*passed = false;
++		}
++		if (((mif == 0) && (maf == 1)) ||
++ 		    ((mif == 1) && (maf == 0))) {
++			snprintf(tmp, sizeof(tmp), "Method%s%sMifMafInvalid", objname, tag);
++			fwts_failed(fw, LOG_LEVEL_MEDIUM,
++				tmp,
++				"%s %s _MIF and _MAF flags are either "
++				"0 and 1 or 1 and 0 which is invalid when "
++				"the length field is non-zero.",
++				name, type);
++			fwts_advice(fw, "%s", mif_maf_advice);
++			*passed = false;
++		}
++		if ((mif == 1) && (maf == 1)) {
++			if (granularity != 0) {
++				snprintf(tmp, sizeof(tmp), "Method%s%sGranularityNotZero", objname, tag);
++				fwts_failed(fw, LOG_LEVEL_MEDIUM,
++					tmp,
++					"%s %s granularity 0x%" PRIx64
++					" is not zero as expected when "
++					"_MIF and _MAF are both 1.",
++					name, type, granularity);
++				fwts_advice(fw, "%s", mif_maf_advice);
++				*passed = false;
++			}
++			if (min > max) {
++				snprintf(tmp, sizeof(tmp), "Method%s%sMaxLessThanMin", objname, tag);
++				fwts_failed(fw, LOG_LEVEL_MEDIUM,
++					tmp,
++					"%s %s minimum address range 0x%" PRIx64
++					" is greater than the maximum address "
++					"range 0x%" PRIx64 ".",
++					name, type, min, max);
++				fwts_advice(fw, "%s", mif_maf_advice);
++				*passed = false;
++			}
++			if (max - min + 1 != len) {
++				snprintf(tmp, sizeof(tmp), "Method%s%sLengthInvalid", objname, tag);
++				fwts_failed(fw, LOG_LEVEL_MEDIUM,
++					tmp,
++					"%s %s length 0x%" PRIx64
++					" does not match the difference between "
++					"the minimum and maximum address ranges "
++					"0x%" PRIx64 "-0x%" PRIx64 ".",
++					name, type, len, min, max);
++				fwts_advice(fw, "%s", mif_maf_advice);
++				*passed = false;
++			}
++		}
++	}
++}
++
++/*
++ *  CRS large resource checks, simple checking
++ */
++static void method_test_CRS_large_resource_items(
++	fwts_framework *fw,
++	const char *name,
++	const char *objname,
++	const uint8_t *data,
++	const uint64_t length,
++	bool *passed,
++	const char **tag)
++{
++	uint64_t min, max, len, gra;
++	uint8_t tag_item = data[0] & 0x7f;
++	char tmp[128];
++
++	static const char *types[] = {
++		"Reserved",
++		"24-bit Memory Range Descriptor",
++		"Generic Register Descriptor",
++		"Reserved",
++		"Vendor Defined Descriptor",
++		"32-bit Memory Range Descriptor",
++		"32-bit Fixed Location Memory Range Descriptor",
++		"DWORD Address Space Descriptor",
++		"WORD Address Space Descriptor",
++		"Extended IRQ Descriptor",
++		"QWORD Address Space Descriptor",
++		"Extended Addresss Space Descriptor",
++		"GPIO Connection Descriptor",
++		"Reserved",
++		"Generic Serial Bus Connection Descriptor",
++		"Reserved",
++	};
++
++	switch (tag_item) {
++	case 0x1: /* 6.4.3.1 24-Bit Memory Range Descriptor */
++		method_test_CRS_large_size(fw, name, objname, data, length, 9, 9, passed);
++		if (!*passed)	/* Too short, abort */
++			break;
++		min = method_CRS_val24(&data[4]);
++		max = method_CRS_val24(&data[6]);
++		len = method_CRS_val16(&data[10]);
++		if (max < min) {
++			snprintf(tmp, sizeof(tmp), "Method%s24BitMemRangeMaxLessThanMin", objname);
++			fwts_failed(fw, LOG_LEVEL_MEDIUM, tmp,
++				"%s 24-Bit Memory Range Descriptor minimum "
++				"address range 0x%" PRIx64 " is greater than "
++				"the maximum address range 0x%" PRIx64 ".",
++				name, min, max);
++			*passed = false;
++		}
++		if (len > max + 1 - min) {
++			snprintf(tmp, sizeof(tmp), "Method%s24BitMemRangeLengthTooLarge", objname);
++			fwts_failed(fw, LOG_LEVEL_MEDIUM, tmp,
++				"%s 24-Bit Memory Range Descriptor length "
++				"0x%" PRIx64 " is greater than size between the "
++				"the minimum and maximum address ranges "
++				"0x%" PRIx64 "-0x%" PRIx64 ".",
++				name, len, min, max);
++			*passed = false;
++		}
++		break;
++	case 0x2: /* 6.4.3.7 Generic Register Descriptor */
++		method_test_CRS_large_size(fw, name, objname, data, length, 12, 12, passed);
++		if (!*passed)
++			break;
++		switch (data[3]) {
++		case 0x00 ... 0x04:
++		case 0x0a:
++		case 0x7f:
++			/* Valid values */
++			break;
++		default:
++			snprintf(tmp, sizeof(tmp), "Method%sGenericRegAddrSpaceIdInvalid", objname);
++			fwts_failed(fw, LOG_LEVEL_HIGH, tmp,
++				"%s Generic Register Descriptor has an invalid "
++				"Address Space ID 0x%" PRIx8 ".",
++				name, data[3]);
++			*passed = false;
++		}
++		if (data[6] > 4) {
++			snprintf(tmp, sizeof(tmp), "Method%sGenericRegAddrSizeInvalid", objname);
++			fwts_failed(fw, LOG_LEVEL_HIGH, tmp,
++				"%s Generic Register Descriptor has an invalid "
++				"Address Access Size 0x%" PRIx8 ".",
++				name, data[6]);
++			*passed = false;
++		}
++		break;
++	case 0x4: /* 6.4.3.2 Vendor-Defined Descriptor */
++		method_test_CRS_large_size(fw, name, objname, data, length, 0, 65535, passed);
++		break;
++	case 0x5: /* 6.4.3.3 32-Bit Memory Range Descriptor */
++		method_test_CRS_large_size(fw, name, objname, data, length, 17, 17, passed);
++		if (!*passed)
++			break;
++		min = method_CRS_val32(&data[4]);
++		max = method_CRS_val32(&data[8]);
++		len = method_CRS_val32(&data[16]);
++		if (max < min) {
++			snprintf(tmp, sizeof(tmp), "Method%s32BitMemRangeMaxLessThanMin", objname);
++			fwts_failed(fw, LOG_LEVEL_MEDIUM, tmp,
++				"%s 32-Bit Memory Range Descriptor minimum "
++				"address range 0x%" PRIx64 " is greater than "
++				"the maximum address range 0x%" PRIx64 ".",
++				name, min, max);
++			*passed = false;
++		}
++		if (len > max + 1 - min) {
++			snprintf(tmp, sizeof(tmp), "Method%s32BitMemRangeLengthTooLarge", objname);
++			fwts_failed(fw, LOG_LEVEL_MEDIUM, tmp,
++				"%s 32-Bit Memory Range Descriptor length "
++				"0x%" PRIx64 " is greater than size between the "
++				"the minimum and maximum address ranges "
++				"0x%" PRIx64 "-0x%" PRIx64 ".",
++				name, len, min, max);
++			*passed = false;
++		}
++		break;
++	case 0x6: /* 6.4.3.4 32-Bit Fixed Memory Range Descriptor */
++		method_test_CRS_large_size(fw, name, objname, data, length, 9, 9, passed);
++		/* Not much can be checked for this descriptor */
++		break;
++	case 0x7: /* 6.4.3.5.2 DWord Address Space Descriptor */
++		method_test_CRS_large_size(fw, name, objname, data, length, 23, 65535, passed);
++		if (!*passed)	/* Too short, abort */
++			break;
++		gra = method_CRS_val32(&data[6]);
++		min = method_CRS_val32(&data[10]);
++		max = method_CRS_val32(&data[14]);
++		len = method_CRS_val32(&data[22]);
++
++		method_test_CRS_mif_maf(fw, name, objname, data[4],
++			min, max, len, gra,
++			"64BitDWordAddrSpace",
++			types[0x7], passed);
++		break;
++	case 0x8: /* 6.4.3.5.3 Word Address Space Descriptor */
++		method_test_CRS_large_size(fw, name, objname, data, length, 13, 65535, passed);
++		if (!*passed)	/* Too short, abort */
++			break;
++		gra = method_CRS_val16(&data[6]);
++		min = method_CRS_val16(&data[8]);
++		max = method_CRS_val16(&data[10]);
++		len = method_CRS_val16(&data[14]);
++
++		method_test_CRS_mif_maf(fw, name, objname, data[4],
++			min, max, len, gra,
++			"64BitWordAddrSpace",
++			types[0x8], passed);
++		break;
++	case 0x9: /* 6.4.3.6 Extended Interrupt Descriptor */
++		method_test_CRS_large_size(fw, name, objname, data, length, 6, 65535, passed);
++		/* Not much can be checked for this descriptor */
++		break;
++	case 0xa: /* 6.4.3.5.1 QWord Address Space Descriptor */
++		method_test_CRS_large_size(fw, name, objname, data, length, 43, 65535, passed);
++		if (!*passed)	/* Too short, abort */
++			break;
++		gra = method_CRS_val64(&data[6]);
++		min = method_CRS_val64(&data[14]);
++		max = method_CRS_val64(&data[22]);
++		len = method_CRS_val64(&data[38]);
++
++		method_test_CRS_mif_maf(fw, name, objname, data[4],
++			min, max, len, gra,
++			"64BitQWordAddrSpace",
++			types[0xa], passed);
++		break;
++	case 0xb: /* 6.4.3.5.4 Extended Address Space Descriptor */
++		method_test_CRS_large_size(fw, name, objname, data, length, 53, 53, passed);
++		if (!*passed)	/* Too short, abort */
++			break;
++		gra = method_CRS_val64(&data[8]);
++		min = method_CRS_val64(&data[16]);
++		max = method_CRS_val64(&data[24]);
++		len = method_CRS_val64(&data[40]);
++
++		method_test_CRS_mif_maf(fw, name, objname, data[4],
++			min, max, len, gra,
++			"64BitExtAddrSpace",
++			types[0xb], passed);
++		break;
++	case 0xc: /* 6.4.3.8.1 GPIO Connection Descriptor */
++		method_test_CRS_large_size(fw, name, objname, data, length, 22, 65535, passed);
++		if (!*passed)	/* Too short, abort */
++			break;
++		if (data[4] > 2) {
++			snprintf(tmp, sizeof(tmp), "Method%sGpioConnTypeInvalid", objname);
++			fwts_failed(fw, LOG_LEVEL_MEDIUM, tmp,
++				"%s GPIO Connection Descriptor has an invalid "
++				"Connection Type 0x%" PRIx8 ".",
++				name, data[2]);
++			*passed = false;
++			fwts_advice(fw,
++				"The GPIO pin connection type is "
++				"not recognised. It should be either "
++				"0x00 (interrupt connection) or "
++				"0x01 (I/O connection). See table "
++				"6-189 in section 6.4.3.8.1 of the ACPI "
++                                "specification.");
++		}
++		if ((data[9] > 0x03) && (data[9] < 0x80)) {
++			snprintf(tmp, sizeof(tmp), "Method%sGpioConnTypeInvalid", objname);
++			fwts_failed(fw, LOG_LEVEL_LOW, tmp,
++				"%s GPIO Connection Descriptor has an invalid "
++				"Pin Configuration Type 0x%" PRIx8 ".",
++				name, data[9]);
++			*passed = false;
++			fwts_advice(fw,
++				"The GPIO pin configuration type "
++				"is not recognised. It should be one of:"
++				"0x00 (default), 0x01 (pull-up), "
++				"0x02 (pull-down), 0x03 (no-pull), "
++				"0x80-0xff (vendor defined). See table "
++				"6-189 in section 6.4.3.8.1 of the ACPI "
++				"specification.");
++		}
++		break;
++	case 0xe: /* 6.4.3.8.2 Serial Bus Connection Descriptors */
++		method_test_CRS_large_size(fw, name, objname, data, length, 11, 65535, passed);
++		/* Don't care */
++		break;
++	default:
++		snprintf(tmp, sizeof(tmp), "Method%sUnkownLargeResourceItem", objname);
++		fwts_failed(fw, LOG_LEVEL_LOW, tmp,
++			"%s tag bits 6:0 is an undefined "
++			"large tag item name, value 0x%" PRIx8 ".",
++			name, tag_item);
++		fwts_advice(fw,
++			"A large resource data type tag (byte 0 of the "
++			"%s buffer) contains an undefined large tag "
++			"item 'name'. The %s buffer is therefore "
++			"undefined and can't be used.  See section "
++			"'6.4.3 Large Resource Data Type' of the ACPI "
++			"specification, and also table 6-173.",
++			objname, objname);
++		*passed = false;
++		break;
++	}
++
++	*tag = types[tag_item < 16 ? tag_item : 0];
++}
++
++static void method_test_CRS_return(
++	fwts_framework *fw,
++	char *name,
++	ACPI_BUFFER *buf,
++	ACPI_OBJECT *obj,
++	void *private)
++{
++	uint8_t *data;
++	bool passed = true;
++	const char *tag = "Unknown";
++	char *objname = (char*)private;
++	char tmp[128];
++
++	FWTS_UNUSED(private);
++
++	if (method_check_type(fw, name, buf, ACPI_TYPE_BUFFER) != FWTS_OK)
++		return;
++	if (obj->Buffer.Pointer == NULL) {
++		snprintf(tmp, sizeof(tmp), "Method%sNullBuffer", objname);
++		fwts_failed(fw, LOG_LEVEL_MEDIUM, tmp,
++			"%s returned a NULL buffer pointer.", name);
++		return;
++	}
++	if (obj->Buffer.Length < 1) {
++		snprintf(tmp, sizeof(tmp), "Method%sBufferTooSmall", objname);
++		fwts_failed(fw, LOG_LEVEL_MEDIUM, tmp,
++			"%s should return a buffer of at least one byte in length.", name);
++		return;
++	}
++
++	data = (uint8_t*)obj->Buffer.Pointer;
++
++	if (data[0] & 128)
++		method_test_CRS_large_resource_items(fw, name, objname, data, obj->Buffer.Length, &passed, &tag);
++	else
++		method_test_CRS_small_resource_items(fw, name, objname, data, obj->Buffer.Length, &passed, &tag);
++
++	if (passed)
++		fwts_passed(fw, "%s (%s) looks sane.", name, tag);
++}
++
++static int method_test_CRS(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_MANDATORY,
++		"_CRS", NULL, 0, method_test_CRS_return, "_CRS");
++}
++
++static int method_test_PRS(fwts_framework *fw)
++{
++	/* Re-use the _CRS checking on the returned buffer */
++	return method_evaluate_method(fw, METHOD_OPTIONAL,
++		"_PRS", NULL, 0, method_test_CRS_return, "_PRS");
++}
++
++static void method_test_PRT_return(
++	fwts_framework *fw,
++	char *name,
++	ACPI_BUFFER *buf,
++	ACPI_OBJECT *obj,
++	void *private)
++{
++	uint32_t i, j;
++	bool failed = false;
++
++	FWTS_UNUSED(private);
++
++	if (method_check_type(fw, name, buf, ACPI_TYPE_PACKAGE) != FWTS_OK)
++		return;
++
++	if (method_package_elements_all_type(fw, name, "_PRT", obj, ACPI_TYPE_PACKAGE) != FWTS_OK)
++		return;
++
++	for (i = 0; i < obj->Package.Count; i++) {
++		ACPI_OBJECT *pkg;
++		ACPI_OBJECT *element;
++		pkg = &obj->Package.Elements[i];
++
++		/* check size of sub-packages */
++		if (pkg->Package.Count != 4) {
++			fwts_failed(fw, LOG_LEVEL_CRITICAL,
++				"Method_PRTSubPackageElementCount",
++				"%s sub-package %" PRIu32 " was expected to have 4"
++				"elements, got %" PRIu32 " elements instead.",
++				name, i, pkg->Package.Count);
++			failed = true;
++			continue;
++		}
++
++		/* check types of sub-packages' elements */
++		for (j = 0; j < 4; j++) {
++			element = &pkg->Package.Elements[j];
++
++			if (j == 2) {
++				if (element->Type != ACPI_TYPE_INTEGER && element->Type != ACPI_TYPE_LOCAL_REFERENCE) {
++					fwts_failed(fw, LOG_LEVEL_CRITICAL,
++						"Method_PRTBadSubElementType",
++						"%s element %" PRIu32 " is not an integer or a NamePath.", name, j);
++					failed = true;
++				}
++				continue;
++			}
++
++			if (element->Type != ACPI_TYPE_INTEGER) {
++				fwts_failed(fw, LOG_LEVEL_CRITICAL,
++					"Method_PRTBadSubElementType",
++					"%s element %" PRIu32 " is not an integer.", name, j);
++				failed = true;
++			}
++		}
++
++		/* check sub-packages's PCI address */
++		element = &pkg->Package.Elements[0];
++		if ((element->Integer.Value & 0xFFFF) != 0xFFFF) {
++			fwts_failed(fw, LOG_LEVEL_CRITICAL,
++				"Method_PRTBadSubElement",
++				"%s element 0 is expected to end with 0xFFFF, got 0x%" PRIx32 ".",
++				name, (uint32_t) element->Integer.Value);
++			failed = true;
++		}
++
++		/* check sub-packages's PCI pin number */
++		element = &pkg->Package.Elements[1];
++		if (element->Integer.Value > 3) {
++			fwts_failed(fw, LOG_LEVEL_CRITICAL,
++				"Method_PRTBadSubElement",
++				"%s element 1 is expected to be 0..3, got 0x%" PRIx32 ".",
++				name, (uint32_t) element->Integer.Value);
++			failed = true;
++		}
++	}
++
++	if (!failed)
++		method_passed_sane(fw, name, "package");
++}
++
++static int method_test_PRT(fwts_framework *fw)
++{
++	/* Re-use the _CRS checking on the returned buffer */
++	return method_evaluate_method(fw, METHOD_OPTIONAL,
++		"_PRT", NULL, 0, method_test_PRT_return, "_PRT");
++}
++
++static int method_test_DMA(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_OPTIONAL,
++		"_DMA", NULL, 0, method_test_buffer_return, NULL);
++}
++
++static void method_test_FIX_return(
++	fwts_framework *fw,
++	char *name,
++	ACPI_BUFFER *buf,
++	ACPI_OBJECT *obj,
++	void *private)
++{
++	uint32_t i;
++	char tmp[8];
++	bool failed = false;
++
++	FWTS_UNUSED(private);
++
++	if (method_check_type(fw, name, buf, ACPI_TYPE_PACKAGE) != FWTS_OK)
++		return;
++
++	/* All elements in the package must be integers */
++	if (method_package_elements_all_type(fw, name, "_FIX", obj, ACPI_TYPE_INTEGER) != FWTS_OK)
++		return;
++
++	/* And they need to be valid IDs */
++	for (i = 0; i < obj->Package.Count; i++) {
++		if (!method_valid_EISA_ID(
++			(uint32_t)obj->Package.Elements[i].Integer.Value,
++			tmp, sizeof(tmp))) {
++			fwts_failed(fw, LOG_LEVEL_MEDIUM,
++				"Method_FIXInvalidElementValue",
++				"%s returned an integer "
++				"0x%8.8" PRIx64 " in package element "
++				"%" PRIu32 " that is not a valid "
++				"EISA ID.", name,
++				(uint64_t)obj->Integer.Value, i);
++			failed = true;
++		}
++	}
++
++	if (!failed)
++		method_passed_sane(fw, name, "package");
++}
++
++static int method_test_FIX(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_OPTIONAL,
++		"_FIX", NULL, 0, method_test_FIX_return, NULL);
++}
++
++/*
++ *  Section 6.2.5 _DSD Device Specific Data, ACPI 5.1
++ */
++static void method_test_DSD_return(
++	fwts_framework *fw,
++	char *name,
++	ACPI_BUFFER *buf,
++	ACPI_OBJECT *obj,
++	void *private)
++{
++	uint32_t i;
++
++	FWTS_UNUSED(private);
++
++	if (method_check_type(fw, name, buf, ACPI_TYPE_PACKAGE) != FWTS_OK)
++		return;
++
++	/* Must be an even number of items in package */
++	if (obj->Package.Count & 1) {
++		fwts_failed(fw, LOG_LEVEL_HIGH, "Method_DSDElementCount",
++			"There must be an even number of items in the %s "
++			"package, instead, got %" PRIu32 " elements.",
++			name, obj->Package.Count);
++		return;
++	}
++	for (i = 0; i < obj->Package.Count; i += 2) {
++		/* UUID should be a buffer */
++		if (!method_type_matches(obj->Package.Elements[i].Type, ACPI_TYPE_BUFFER)) {
++			fwts_failed(fw, LOG_LEVEL_MEDIUM, "Method_DSDElementBuffer",
++				"%s package element %" PRIu32 " was not the expected "
++				"type '%s', was instead type '%s'.",
++				name, i,
++				method_type_name(ACPI_TYPE_BUFFER),
++				method_type_name(obj->Package.Elements[i].Type));
++		}
++
++		/* Data should be a package */
++		if (!method_type_matches(obj->Package.Elements[i + 1].Type, ACPI_TYPE_PACKAGE)) {
++			fwts_failed(fw, LOG_LEVEL_MEDIUM, "Method_DSDElementPackage",
++				"%s package element %" PRIu32 " was not the expected "
++				"type '%s', was instead type '%s'.",
++				name, i + 1,
++				method_type_name(ACPI_TYPE_PACKAGE),
++				method_type_name(obj->Package.Elements[i + 1].Type));
++		}
++	}
++}
++
++static int method_test_DSD(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_OPTIONAL,
++		"_DSD", NULL, 0, method_test_DSD_return, NULL);
++}
++
++static int method_test_DIS(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_OPTIONAL,
++		"_DIS", NULL, 0, method_test_NULL_return, NULL);
++}
++
++static int method_test_GSB(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_OPTIONAL,
++		"_GSB", NULL, 0, method_test_integer_return, NULL);
++}
++
++static void method_test_HPP_return(
++	fwts_framework *fw,
++	char *name,
++	ACPI_BUFFER *buf,
++	ACPI_OBJECT *obj,
++	void *private)
++{
++	FWTS_UNUSED(private);
++
++	if (method_check_type(fw, name, buf, ACPI_TYPE_PACKAGE) != FWTS_OK)
++		return;
++
++	/* Must be 4 elements in the package */
++	if (method_package_count_equal(fw, name, "_HPP", obj, 4) != FWTS_OK)
++		return;
++
++	/* All 4 elements in the package must be integers */
++	if (method_package_elements_all_type(fw, name, "_HPP", obj, ACPI_TYPE_INTEGER) != FWTS_OK)
++		return;
++
++	method_passed_sane(fw, name, "package");
++}
++
++static int method_test_HPP(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_OPTIONAL,
++		"_HPP", NULL, 0, method_test_HPP_return, NULL);
++}
++
++static int method_test_PXM(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_OPTIONAL,
++		"_PXM", NULL, 0, method_test_integer_return, NULL);
++}
++
++/* Section 6.2.17 _CCA */
++static int method_test_CCA(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_OPTIONAL,
++		"_CCA", NULL, 0, method_test_integer_return, NULL);
++}
++
++/*
++ * Section 6.3 Device Insertion, Removal and Status Objects
++ */
++static void method_test_EDL_return(
++	fwts_framework *fw,
++	char *name,
++	ACPI_BUFFER *buf,
++	ACPI_OBJECT *obj,
++	void *private)
++{
++	FWTS_UNUSED(private);
++
++	if (method_check_type(fw, name, buf, ACPI_TYPE_PACKAGE) != FWTS_OK)
++		return;
++
++	if (method_package_elements_all_type(fw, name, "_EDL",
++		obj, ACPI_TYPE_LOCAL_REFERENCE) != FWTS_OK)
++		return;
++
++	method_passed_sane(fw, name, "package");
++}
++
++static int method_test_EDL(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_OPTIONAL,
++		"_EDL", NULL, 0, method_test_EDL_return, NULL);
++}
++
++static int method_test_EJD(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_OPTIONAL,
++		"_EJD", NULL, 0, method_test_string_return, NULL);
++}
++
++#define method_test_EJx(name)					\
++static int method_test ## name(fwts_framework *fw)		\
++{								\
++	ACPI_OBJECT arg[1];					\
++								\
++	arg[0].Type = ACPI_TYPE_INTEGER;			\
++	arg[0].Integer.Value = 1;				\
++								\
++	return method_evaluate_method(fw, METHOD_OPTIONAL,	\
++		# name, arg, 1, method_test_NULL_return, # name); \
++}
++
++method_test_EJx(_EJ0)
++method_test_EJx(_EJ1)
++method_test_EJx(_EJ2)
++method_test_EJx(_EJ3)
++method_test_EJx(_EJ4)
++
++static int method_test_LCK(fwts_framework *fw)
++{
++	ACPI_OBJECT arg[1];
++
++	arg[0].Type = ACPI_TYPE_INTEGER;
++	arg[0].Integer.Value = 1;
++
++	return method_evaluate_method(fw, METHOD_OPTIONAL,
++		"_LCK", arg, 1, method_test_NULL_return, NULL);
++}
++
++static int method_test_RMV(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_OPTIONAL, "_RMV",
++		NULL, 0, method_test_passed_failed_return, "_RMV");
++}
++
++static void method_test_STA_return(
++	fwts_framework *fw,
++	char *name,
++	ACPI_BUFFER *buf,
++	ACPI_OBJECT *obj,
++	void *private)
++{
++	bool failed = false;
++
++	FWTS_UNUSED(private);
++
++	if (method_check_type(fw, name, buf, ACPI_TYPE_INTEGER) != FWTS_OK)
++		return;
++
++	if ((obj->Integer.Value & 3) == 2) {
++		fwts_failed(fw, LOG_LEVEL_MEDIUM,
++			"Method_STAEnabledNotPresent",
++			"%s indicates that the device is enabled "
++			"but not present, which is impossible.", name);
++		failed = true;
++	}
++	if ((obj->Integer.Value & ~0x1f) != 0) {
++		fwts_failed(fw, LOG_LEVEL_MEDIUM,
++			"Method_STAReservedBitsSet",
++			"%s is returning non-zero reserved "
++			"bits 5-31. These should be zero.", name);
++		failed = true;
++	}
++
++	if (!failed)
++		method_passed_sane_uint64(fw, name, obj->Integer.Value);
++}
++
++static int method_test_STA(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_OPTIONAL, "_STA",
++		NULL, 0, method_test_STA_return, "_STA");
++}
++
++
++/*
++ * Section 6.5 Other Objects and Controls
++ */
++static int method_test_BBN(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_OPTIONAL, "_BBN",
++		NULL, 0, method_test_integer_return, "_BBN");
++}
++
++static int method_test_BDN(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_MOBILE, "_BDN",
++		NULL, 0, method_test_integer_return, "_BDN");
++}
++
++static void method_test_DEP_return(
++	fwts_framework *fw,
++	char *name,
++	ACPI_BUFFER *buf,
++	ACPI_OBJECT *obj,
++	void *private)
++{
++	FWTS_UNUSED(private);
++
++	if (method_check_type(fw, name, buf, ACPI_TYPE_PACKAGE) != FWTS_OK)
++		return;
++
++	if (method_package_elements_all_type(fw, name, "_DEP", obj, ACPI_TYPE_LOCAL_REFERENCE) != FWTS_OK)
++		return;
++
++	method_passed_sane(fw, name, "package");
++}
++
++static int method_test_DEP(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_OPTIONAL,
++		"_DEP", NULL, 0, method_test_DEP_return, NULL);
++}
++
++static int method_test_FIT(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_OPTIONAL,
++		"_FIT", NULL, 0, method_test_buffer_return, NULL);
++}
++
++static int method_test_DCK(fwts_framework *fw)
++{
++	int i;
++
++	for (i = 0; i <= 1; i++) {	/* Undock, Dock */
++		ACPI_OBJECT arg[1];
++		arg[0].Type = ACPI_TYPE_INTEGER;
++		arg[0].Integer.Value = i;
++		if (method_evaluate_method(fw, METHOD_MOBILE, "_DCK", arg,
++			1, method_test_passed_failed_return, "_DCK") != FWTS_OK)
++			break;
++		fwts_log_nl(fw);
++	}
++	return FWTS_OK;
++}
++
++static int method_test_INI(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_OPTIONAL,
++		"_INI", NULL, 0, method_test_NULL_return, NULL);
++}
++
++static void method_test_SEG_return(
++	fwts_framework *fw,
++	char *name,
++	ACPI_BUFFER *buf,
++	ACPI_OBJECT *obj,
++	void *private)
++{
++	FWTS_UNUSED(private);
++
++	if (method_check_type(fw, name, buf, ACPI_TYPE_INTEGER) != FWTS_OK)
++		return;
++
++	if ((obj->Integer.Value & 0xffff0000)) {
++		fwts_failed(fw, LOG_LEVEL_MEDIUM,
++			"Method_SEGIllegalReserved",
++			"%s returned value 0x%8.8" PRIx64 " and some of the "
++			"upper 16 reserved bits are set when they "
++			"should in fact be zero.",
++			name, (uint64_t)obj->Integer.Value);
++	} else
++		method_passed_sane_uint64(fw, name, obj->Integer.Value);
++}
++
++static int method_test_SEG(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_OPTIONAL, "_SEG",
++		NULL, 0, method_test_SEG_return, "_SEG");
++}
++
++static void method_test_GLK_return(
++	fwts_framework *fw,
++	char *name,
++	ACPI_BUFFER *buf,
++	ACPI_OBJECT *obj,
++	void *private)
++{
++	FWTS_UNUSED(buf);
++	FWTS_UNUSED(private);
++
++	switch (obj->Type) {
++	case ACPI_TYPE_INTEGER:
++		if (obj->Integer.Value == 0 || obj->Integer.Value == 1)
++			fwts_passed(fw, "%s returned an integer 0x%8.8" PRIx64,
++				name, (uint64_t)obj->Integer.Value);
++		else
++			fwts_failed(fw, LOG_LEVEL_HIGH,
++				"MethodGLKInvalidInteger",
++				"%s returned an invalid integer 0x%8.8" PRIx64,
++				name, (uint64_t)obj->Integer.Value);
++		break;
++	default:
++		fwts_failed(fw, LOG_LEVEL_HIGH, "Method_GLKBadReturnType",
++			"%s did not return an integer.", name);
++		break;
++	}
++}
++
++static int method_test_GLK(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_OPTIONAL, "_GLK",
++		NULL, 0, method_test_GLK_return, "_GLK");
++}
++
++/*
++ * Section 7.1 Declaring a Power Resource Object
++ */
++static int method_test_ON_(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_OPTIONAL,
++		"_ON_", NULL, 0, method_test_NULL_return, NULL);
++}
++
++static int method_test_OFF(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_OPTIONAL,
++		"_OFF", NULL, 0, method_test_NULL_return, NULL);
++}
++
++
++/*
++ * Section 7.2  Device Power Management Objects
++ */
++static int method_test_DSW(fwts_framework *fw)
++{
++	ACPI_OBJECT arg[3];
++
++	arg[0].Type = ACPI_TYPE_INTEGER;
++	arg[0].Integer.Value = 1;
++	arg[1].Type = ACPI_TYPE_INTEGER;
++	arg[1].Integer.Value = 0;
++	arg[2].Type = ACPI_TYPE_INTEGER;
++	arg[2].Integer.Value = 3;
++
++	return method_evaluate_method(fw, METHOD_OPTIONAL, "_DSW",
++		arg, 3, method_test_NULL_return, NULL);
++}
++
++static int method_test_PSx(fwts_framework *fw, char *name)
++{
++	/*
++	 *  iASL (ACPICA commit 6922796cfdfca041fdb96dc9e3918cbc7f43d830)
++	 *  checks that _PS0 must exist if we have _PS1, _PS2, _PS3
++	 *  so check this here too.
++	 */
++	if ((fwts_acpi_object_exists(name) != NULL) &&
++            (fwts_acpi_object_exists("_PS0") == NULL)) {
++		fwts_failed(fw, LOG_LEVEL_HIGH, "Method_PSx",
++			"%s requires that the _PS0 "
++			"control method must also exist, however, "
++			"it was not found.", name);
++	}
++	return method_evaluate_method(fw, METHOD_OPTIONAL,
++		name, NULL, 0, method_test_NULL_return, name);
++}
++
++static void method_test_PRW_return(
++	fwts_framework *fw,
++	char *name,
++	ACPI_BUFFER *buf,
++	ACPI_OBJECT *obj,
++	void *private)
++{
++	uint32_t i;
++	bool failed = false;
++
++	FWTS_UNUSED(private);
++
++	if (method_check_type(fw, name, buf, ACPI_TYPE_PACKAGE) != FWTS_OK)
++		return;
++
++	if (method_package_count_min(fw, name, "_PRW", obj, 2) != FWTS_OK)
++		return;
++
++	if (obj->Package.Elements[0].Type != ACPI_TYPE_INTEGER &&
++	    obj->Package.Elements[0].Type != ACPI_TYPE_PACKAGE) {
++		fwts_failed(fw, LOG_LEVEL_MEDIUM,
++			"Method_PRWBadPackageReturnType",
++			"%s element 0 is not an integer or an package.", name);
++		failed = true;
++	}
++
++	if (obj->Package.Elements[0].Type == ACPI_TYPE_PACKAGE) {
++		ACPI_OBJECT *pkg;
++		pkg = &obj->Package.Elements[0];
++		if (pkg->Package.Count != 2) {
++			fwts_failed(fw, LOG_LEVEL_MEDIUM,
++				"Method_PRWSubPackageElementCount",
++				"%s sub-package 0  was expected to have 2"
++				"elements, got %" PRIu32 " elements instead.",
++				name, pkg->Package.Count);
++			failed = true;
++		}
++
++		if (pkg->Package.Elements[0].Type != ACPI_TYPE_LOCAL_REFERENCE) {
++			fwts_failed(fw, LOG_LEVEL_MEDIUM,
++				"Method_PRWBadSubPackageElementType",
++				"%s sub-package 0 element 0 is not "
++				"a reference.",name);
++			failed = true;
++		}
++
++		if (pkg->Package.Elements[1].Type != ACPI_TYPE_INTEGER) {
++			fwts_failed(fw, LOG_LEVEL_MEDIUM,
++				"Method_PRWBadSubPackageElementType",
++				"%s sub-package 0 element 0 is not "
++				"an integer.",name);
++			failed = true;
++		}
++	}
++
++	if (obj->Package.Elements[1].Type != ACPI_TYPE_INTEGER) {
++		fwts_failed(fw, LOG_LEVEL_MEDIUM,
++			"Method_PRWBadPackageReturnType",
++			"%s element 1 is not an integer.", name);
++		failed = true;
++	}
++
++	for (i = 2; i < obj->Package.Count - 1; i++) {
++		if (obj->Package.Elements[i].Type != ACPI_TYPE_LOCAL_REFERENCE) {
++			fwts_failed(fw, LOG_LEVEL_MEDIUM,
++				"Method_PRWBadPackageReturnType",
++				"%s package %" PRIu32
++				" element 0 is not a reference.",
++				name, i);
++			failed = true;
++		}
++	}
++
++	if (!failed)
++		method_passed_sane(fw, name, "package");
++}
++
++static int method_test_PRW(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_OPTIONAL,
++		"_PRW", NULL, 0, method_test_PRW_return, NULL);
++}
++
++static int method_test_PS0(fwts_framework *fw)
++{
++	/*
++	 *  iASL (ACPICA commit 6922796cfdfca041fdb96dc9e3918cbc7f43d830)
++	 *  checks that one of _PS1, _PS2, _PS3 must exist if _PS0 exists.
++	 */
++	if (fwts_acpi_object_exists("_PS0") != NULL) {
++		bool ok = false;
++		int i;
++
++		for (i = 1; i < 4; i++) {
++			char name[5];
++
++			snprintf(name, sizeof(name), "_PS%1d", i);
++			if (fwts_acpi_object_exists(name) != NULL) {
++				ok = true;
++				break;
++			}
++		}
++		if (!ok) {
++			fwts_failed(fw, LOG_LEVEL_HIGH, "Method_PS0",
++				"_PS0 requires that one of the _PS1, _PS2, _PS3 "
++				"control methods must also exist, however, "
++				"none were found.");
++		}
++	}
++	return method_evaluate_method(fw, METHOD_OPTIONAL, "_PS0",
++		 NULL, 0, method_test_NULL_return, "_PS0");
++}
++
++static int method_test_PS1(fwts_framework *fw)
++{
++	return method_test_PSx(fw, "_PS1");
++}
++
++static int method_test_PS2(fwts_framework *fw)
++{
++	return method_test_PSx(fw, "_PS2");
++}
++
++static int method_test_PS3(fwts_framework *fw)
++{
++	return method_test_PSx(fw, "_PS3");
++}
++
++static int method_test_PSC(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_OPTIONAL,
++		"_PSC", NULL, 0, method_test_integer_return, NULL);
++}
++
++static int method_test_PSE(fwts_framework *fw)
++{
++	ACPI_OBJECT arg[1];
++
++	arg[0].Type = ACPI_TYPE_INTEGER;
++	arg[0].Integer.Value = 1;
++
++	return method_evaluate_method(fw, METHOD_OPTIONAL,
++		"_PSE", arg, 1, method_test_NULL_return, NULL);
++}
++
++static void method_test_power_resources_return(
++	fwts_framework *fw,
++	char *name,
++	ACPI_BUFFER *buf,
++	ACPI_OBJECT *obj,
++	void *private)
++{
++	char *objname = (char *)private;
++
++	FWTS_UNUSED(private);
++
++	if (method_check_type(fw, name, buf, ACPI_TYPE_PACKAGE) != FWTS_OK)
++		return;
++
++	if (method_package_elements_all_type(fw, name, objname,
++		obj, ACPI_TYPE_LOCAL_REFERENCE) != FWTS_OK)
++		return;
++
++	method_passed_sane(fw, name, "package");
++}
++
++#define method_test_POWER(name)						\
++static int method_test ## name(fwts_framework *fw)			\
++{									\
++	return method_evaluate_method(fw, METHOD_OPTIONAL,		\
++		# name, NULL, 0, method_test_power_resources_return, # name);\
++}
++
++method_test_POWER(_PR0)
++method_test_POWER(_PR1)
++method_test_POWER(_PR2)
++method_test_POWER(_PR3)
++method_test_POWER(_PRE)
++
++static int method_test_PSW(fwts_framework *fw)
++{
++	ACPI_OBJECT arg[1];
++
++	arg[0].Type = ACPI_TYPE_INTEGER;
++	arg[0].Integer.Value = 1;
++
++	return method_evaluate_method(fw, METHOD_OPTIONAL,
++		"_PSW", arg, 1, method_test_NULL_return, NULL);
++}
++
++#define method_test_SxD(name)						\
++static int method_test ## name(fwts_framework *fw)			\
++{									\
++	return method_evaluate_method(fw, METHOD_OPTIONAL,		\
++		# name, NULL, 0, method_test_integer_return, # name);	\
++}
++
++method_test_SxD(_S1D)
++method_test_SxD(_S2D)
++method_test_SxD(_S3D)
++method_test_SxD(_S4D)
++
++#define method_test_SxW(name)						\
++static int method_test ## name(fwts_framework *fw)			\
++{									\
++	return method_evaluate_method(fw, METHOD_OPTIONAL,		\
++		# name, NULL, 0, method_test_integer_return, # name);	\
++}
++
++method_test_SxW(_S0W)
++method_test_SxW(_S1W)
++method_test_SxW(_S2W)
++method_test_SxW(_S3W)
++method_test_SxW(_S4W)
++
++static int method_test_RST(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_OPTIONAL,
++		"_RST", NULL, 0, method_test_NULL_return, NULL);
++}
++
++static void method_test_PRR_return(
++	fwts_framework *fw,
++	char *name,
++	ACPI_BUFFER *buf,
++	ACPI_OBJECT *obj,
++	void *private)
++{
++	FWTS_UNUSED(private);
++
++	if (method_check_type(fw, name, buf, ACPI_TYPE_PACKAGE) != FWTS_OK)
++		return;
++
++	if (method_package_count_equal(fw, name, "_PRR", obj, 1) != FWTS_OK)
++		return;
++
++	if (obj->Package.Elements[0].Type != ACPI_TYPE_LOCAL_REFERENCE) {
++		fwts_failed(fw, LOG_LEVEL_MEDIUM,
++			"Method_PRRElementType",
++			"%s returned a package that does not contain "
++			"a reference.", name);
++		return;
++	}
++
++	method_passed_sane(fw, name, "package");
++}
++
++static int method_test_PRR(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_OPTIONAL,
++		"_PRR", NULL, 0, method_test_PRR_return, NULL);
++}
++
++static int method_test_IRC(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_OPTIONAL,
++		"_IRC", NULL, 0, method_test_NULL_return, NULL);
++}
++
++/*
++ * Section 7.3 OEM Supplied System-Level Control Methods
++ */
++static void method_test_Sx__return(
++	fwts_framework *fw,
++	char *name,
++	ACPI_BUFFER *buf,
++	ACPI_OBJECT *obj,
++	void *private)
++{
++	bool failed = false;
++
++	FWTS_UNUSED(private);
++
++	if (method_check_type(fw, name, buf, ACPI_TYPE_PACKAGE) != FWTS_OK)
++		return;
++
++	/*
++	 * The ACPI spec states it should have 1 integer, with the
++	 * values packed into each byte. However, nearly all BIOS
++	 * vendors don't do this, instead they return a package of
++	 * 2 or more integers with each integer lower byte containing
++	 * the data we are interested in. The kernel handles this
++	 * the non-compliant way. Doh. See drivers/acpi/acpica/hwxface.c
++	 * for the kernel implementation and also
++	 * source/components/hardware/hwxface.c in the reference ACPICA
++	 * sources.
++ 	 */
++
++	/* Something is really wrong if we don't have any elements in _Sx_ */
++	if (obj->Package.Count < 1) {
++		fwts_failed(fw, LOG_LEVEL_HIGH, "Method_SxElementCount",
++			"The kernel expects a package of at least two "
++			"integers, and %s only returned %" PRIu32
++			" elements in the package.",
++			name, obj->Package.Count);
++		return;
++	}
++
++	/*
++	 * Oh dear, BIOS is conforming to the spec but won't work in
++	 * Linux
++	 */
++	if (obj->Package.Count == 1) {
++		fwts_failed(fw, LOG_LEVEL_MEDIUM, "Method_SxElementCount",
++			"The ACPI specification states that %s should "
++			"return a package of a single integer which "
++			"this firmware does do. However, nearly all of the "
++			"BIOS vendors return the values in the low 8 bits "
++			"in a package of 2 to 4 integers which is not "
++			"compliant with the specification BUT is the way "
++			"that the ACPICA reference engine and the kernel "
++			"expect. So, while this is conforming to the ACPI "
++			"specification it will in fact not work in the "
++			"Linux kernel.", name);
++		return;
++	}
++
++	/* Yes, we really want integers! */
++	if ((obj->Package.Elements[0].Type != ACPI_TYPE_INTEGER) ||
++	    (obj->Package.Elements[1].Type != ACPI_TYPE_INTEGER)) {
++		fwts_failed(fw, LOG_LEVEL_MEDIUM,
++			"Method_SxElementType",
++			"%s returned a package that did not contain "
++			"an integer.", name);
++		return;
++	}
++
++	if (obj->Package.Elements[0].Integer.Value & 0xffffff00) {
++		fwts_failed(fw, LOG_LEVEL_MEDIUM,
++			"Method_SxElementValue",
++			"%s package element 0 had upper 24 bits "
++			"of bits that were non-zero.", name);
++		failed = true;
++	}
++
++	if (obj->Package.Elements[1].Integer.Value & 0xffffff00) {
++		fwts_failed(fw, LOG_LEVEL_MEDIUM,
++			"Method_SxElementValue",
++			"%s package element 1 had upper 24 bits "
++			"of bits that were non-zero.", name);
++		failed = true;
++	}
++
++	fwts_log_info(fw, "%s PM1a_CNT.SLP_TYP value: 0x%8.8" PRIx64, name,
++		(uint64_t)obj->Package.Elements[0].Integer.Value);
++	fwts_log_info(fw, "%s PM1b_CNT.SLP_TYP value: 0x%8.8" PRIx64, name,
++		(uint64_t)obj->Package.Elements[1].Integer.Value);
++
++	if (!failed)
++		method_passed_sane(fw, name, "package");
++}
++
++#define method_test_Sx_(name)						\
++static int method_test ## name(fwts_framework *fw)			\
++{									\
++	return method_evaluate_method(fw, METHOD_OPTIONAL,		\
++		# name, NULL, 0, method_test_Sx__return, # name);	\
++}
++
++method_test_Sx_(_S0_)
++method_test_Sx_(_S1_)
++method_test_Sx_(_S2_)
++method_test_Sx_(_S3_)
++method_test_Sx_(_S4_)
++method_test_Sx_(_S5_)
++
++static int method_test_SWS(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_OPTIONAL,
++		"_SWS", NULL, 0, method_test_integer_return, NULL);
++}
++
++/*
++ * Section 8.4 Declaring Processors
++ */
++static void method_test_CPC_return(
++	fwts_framework *fw,
++	char *name,
++	ACPI_BUFFER *buf,
++	ACPI_OBJECT *obj,
++	void *private)
++{
++	uint8_t revision;
++
++	static fwts_package_element elementsv1[] = {
++		{ ACPI_TYPE_INTEGER,	"Number of Entries" },
++		{ ACPI_TYPE_INTEGER,	"Revision" },
++		{ ACPI_TYPE_INTBUF,	"Highest Performance" },
++		{ ACPI_TYPE_INTBUF,	"Nominal Performance" },
++		{ ACPI_TYPE_INTBUF,	"Lowest Non Linear Performance" },
++		{ ACPI_TYPE_INTBUF,	"Lowest Performance" },
++		{ ACPI_TYPE_BUFFER,	"Guaranteed Performance Register" },
++		{ ACPI_TYPE_BUFFER,	"Desired Performance Register" },
++		{ ACPI_TYPE_BUFFER,	"Minimum Performance Register" },
++		{ ACPI_TYPE_BUFFER,	"Maximum Performance Register" },
++		{ ACPI_TYPE_BUFFER,	"Performance Reduction Tolerance Register" },
++		{ ACPI_TYPE_BUFFER,	"Timed Window Register" },
++		{ ACPI_TYPE_INTBUF,	"Counter Wraparound Time" },
++		{ ACPI_TYPE_BUFFER,	"Nominal Counter Register" },
++		{ ACPI_TYPE_BUFFER,	"Delivered Counter Register" },
++		{ ACPI_TYPE_BUFFER,	"Performance Limited Register" },
++		{ ACPI_TYPE_BUFFER,	"Enable Register" }
++	};
++
++	static fwts_package_element elementsv2[] = {
++		{ ACPI_TYPE_INTEGER,	"Number of Entries" },
++		{ ACPI_TYPE_INTEGER,	"Revision" },
++		{ ACPI_TYPE_INTBUF,	"Highest Performance" },
++		{ ACPI_TYPE_INTBUF,	"Nominal Performance" },
++		{ ACPI_TYPE_INTBUF,	"Lowest Non Linear Performance" },
++		{ ACPI_TYPE_INTBUF,	"Lowest Performance" },
++		{ ACPI_TYPE_BUFFER,	"Guaranteed Performance Register" },
++		{ ACPI_TYPE_BUFFER,	"Desired Performance Register" },
++		{ ACPI_TYPE_BUFFER,	"Minimum Performance Register" },
++		{ ACPI_TYPE_BUFFER,	"Maximum Performance Register" },
++		{ ACPI_TYPE_BUFFER,	"Performance Reduction Tolerance Register" },
++		{ ACPI_TYPE_BUFFER,	"Timed Window Register" },
++		{ ACPI_TYPE_INTBUF,	"Counter Wraparound Time" },
++		{ ACPI_TYPE_BUFFER,	"Reference Performance Counter Register" },
++		{ ACPI_TYPE_BUFFER,	"Delivered Performance Counter Register" },
++		{ ACPI_TYPE_BUFFER,	"Performance Limited Register" },
++		{ ACPI_TYPE_BUFFER,	"CPPC Enable Register" },
++		{ ACPI_TYPE_INTBUF,	"Autonomous Selection Enable" },
++		{ ACPI_TYPE_BUFFER,	"Autonomous Activity Window Register" },
++		{ ACPI_TYPE_BUFFER,	"Energy Performance Preference Register" },
++		{ ACPI_TYPE_INTBUF,	"Reference Performance" }
++	};
++
++	FWTS_UNUSED(private);
++
++	if (method_check_type(fw, name, buf, ACPI_TYPE_PACKAGE) != FWTS_OK)
++		return;
++
++	revision = obj->Package.Elements[1].Integer.Value;
++
++	if (revision == 1) {		// acpi 5.0
++		/* Something is really wrong if we don't have any elements in _CPC */
++		if (method_package_count_equal(fw, name, "_CPC", obj, 17) != FWTS_OK)
++			return;
++
++		/* For now, just check types */
++		if (method_package_elements_type(fw, name, "_CPC", obj, elementsv1, 17) != FWTS_OK)
++			return;
++	} else if (revision == 2) {	// acpi 5.1 and later
++		/* Something is really wrong if we don't have any elements in _CPC */
++		if (method_package_count_equal(fw, name, "_CPC", obj, 21) != FWTS_OK)
++			return;
++
++		/* For now, just check types */
++		if (method_package_elements_type(fw, name, "_CPC", obj, elementsv2, 21) != FWTS_OK)
++			return;
++	} else {
++		fwts_failed(fw, LOG_LEVEL_HIGH,
++			"Method_CPCBadRevision",
++			"_CPC's _REV is incorrect, "
++			"expecting 1 or 2, got 0x%" PRIx8 , revision);
++
++		return;
++	}
++
++	method_passed_sane(fw, name, "package");
++}
++
++static int method_test_CPC(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_OPTIONAL, "_CPC", NULL,
++		0, method_test_CPC_return, NULL);
++}
++
++static void method_test_CSD_return(
++	fwts_framework *fw,
++	char *name,
++	ACPI_BUFFER *buf,
++	ACPI_OBJECT *obj,
++	void *private)
++{
++	uint32_t i;
++	bool failed = false;
++
++	FWTS_UNUSED(private);
++
++	if (method_check_type(fw, name, buf, ACPI_TYPE_PACKAGE) != FWTS_OK)
++		return;
++
++	/* Something is really wrong if we don't have any elements in _CSD */
++	if (method_package_count_min(fw, name, "_CSD", obj, 1) != FWTS_OK)
++		return;
++
++	/* Could be one or more packages */
++	for (i = 0; i < obj->Package.Count; i++) {
++		ACPI_OBJECT *pkg;
++		uint32_t j;
++		bool elements_ok = true;
++
++		if (method_package_elements_all_type(fw, name, "_CSD",
++			obj, ACPI_TYPE_PACKAGE) != FWTS_OK) {
++			failed = true;
++			continue;	/* Skip processing sub-package */
++		}
++
++		pkg = &obj->Package.Elements[i];
++		/*
++		 *  Currently we expect a package of 6 integers.
++		 */
++		if (pkg->Package.Count != 6) {
++			fwts_failed(fw, LOG_LEVEL_MEDIUM,
++				"Method_CSDSubPackageElementCount",
++				"%s sub-package %" PRIu32 " was expected to "
++				"have 5 elements, got %" PRIu32 " elements instead.",
++				name, i, pkg->Package.Count);
++			failed = true;
++			continue;
++		}
++
++		for (j = 0; j < 6; j++) {
++			if (pkg->Package.Elements[j].Type != ACPI_TYPE_INTEGER) {
++				fwts_failed(fw, LOG_LEVEL_MEDIUM,
++					"Method_CSDSubPackageElementCount",
++					"%s sub-package %" PRIu32
++					" element %" PRIu32 " is not "
++					"an integer.",
++					name, i, j);
++				elements_ok = false;
++			}
++		}
++
++		if (!elements_ok) {
++			failed = true;
++			continue;
++		}
++
++		/* Element 0 must equal the number elements in the package */
++		if (pkg->Package.Elements[0].Integer.Value != pkg->Package.Count) {
++			fwts_failed(fw, LOG_LEVEL_MEDIUM,
++				"Method_CSDSubPackageElement0",
++				"%s sub-package %d element 0 (NumEntries) "
++				"was expected to have value 0x%" PRIx64 ".",
++				name, i,
++				(uint64_t)pkg->Package.Elements[0].Integer.Value);
++			failed = true;
++		}
++		/* Element 1 should contain zero */
++		if (pkg->Package.Elements[1].Integer.Value != 0) {
++			fwts_failed(fw, LOG_LEVEL_MEDIUM,
++				"Method_CSDSubPackageElement1",
++				"%s sub-package %d element 1 (Revision) "
++				"was expected to have value 1, instead it "
++				"was 0x%" PRIx64 ".",
++				name, i,
++				(uint64_t)pkg->Package.Elements[1].Integer.Value);
++			failed = true;
++		}
++		/* Element 3 should contain 0xfc..0xfe */
++		if ((pkg->Package.Elements[3].Integer.Value != 0xfc) &&
++		    (pkg->Package.Elements[3].Integer.Value != 0xfd) &&
++		    (pkg->Package.Elements[3].Integer.Value != 0xfe)) {
++			fwts_failed(fw, LOG_LEVEL_MEDIUM,
++				"Method_CSDSubPackageElement1",
++				"%s sub-package %d element 3 (CoordType) "
++				"was expected to have value 0xfc (SW_ALL), "
++				"0xfd (SW_ANY) or 0xfe (HW_ALL), instead it "
++				"was 0x%" PRIx64 ".",
++				name, i,
++				(uint64_t)pkg->Package.Elements[3].Integer.Value);
++			failed = true;
++		}
++		/* Element 4 number of processors, skip check */
++		/* Element 5 index, check */
++	}
++
++	if (!failed)
++		method_passed_sane(fw, name, "package");
++}
++
++static int method_test_CSD(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_OPTIONAL,
++		"_CSD", NULL, 0, method_test_CSD_return, NULL);
++}
++
++static void method_test_CST_return(
++	fwts_framework *fw,
++	char *name,
++	ACPI_BUFFER *buf,
++	ACPI_OBJECT *obj,
++	void *private)
++{
++	uint32_t i, j;
++	bool failed = false;
++	bool *cst_elements_ok;
++	bool an_element_ok = false;
++
++	typedef struct {
++		const uint32_t	type;
++		const char 	*name;
++	} cstate_info;
++
++	static const cstate_info cstate_types[] = {
++		{ ACPI_TYPE_BUFFER,	"buffer" },
++		{ ACPI_TYPE_INTEGER,	"integer" },
++		{ ACPI_TYPE_INTEGER,	"integer" },
++		{ ACPI_TYPE_INTEGER,	"integer" },
++	};
++
++	FWTS_UNUSED(private);
++
++	if (obj == NULL)
++		return;
++
++	if (method_check_type(fw, name, buf, ACPI_TYPE_PACKAGE) != FWTS_OK)
++		return;
++
++	/* _CST has at least two elements */
++	if (method_package_count_min(fw, name, "_CST", obj, 2) != FWTS_OK)
++		return;
++
++	/* Element 1 must be an integer */
++	if (obj->Package.Elements[0].Type != ACPI_TYPE_INTEGER) {
++		fwts_failed(fw, LOG_LEVEL_MEDIUM, "Method_CSTElement0NotInteger",
++			"%s should return package with element zero being an integer "
++			"count of the number of C state sub-packages.", name);
++		return;
++	}
++
++	if (obj->Package.Elements[0].Integer.Value != obj->Package.Count - 1) {
++		fwts_failed(fw, LOG_LEVEL_MEDIUM, "Method_CSTElement0CountMismatch",
++			"%s should return package with element zero containing "
++			"the number of C state sub-elements.  However, _CST has "
++			"%" PRIu32 " returned C state sub-elements yet _CST "
++			"reports it has %" PRIu64 " C states.",
++			name, obj->Package.Count - 1,
++			(uint64_t)obj->Package.Elements[0].Integer.Value);
++		return;
++	}
++
++	cst_elements_ok = calloc(obj->Package.Count, sizeof(bool));
++	if (cst_elements_ok == NULL) {
++		fwts_log_error(fw, "Cannot allocate an array. Test aborted.");
++		return;
++	}
++
++	/* Could be one or more packages */
++	for (i = 1; i < obj->Package.Count; i++) {
++		ACPI_OBJECT *pkg;
++
++		cst_elements_ok[i] = true;
++		if (obj->Package.Elements[i].Type != ACPI_TYPE_PACKAGE) {
++			fwts_failed(fw, LOG_LEVEL_MEDIUM,
++				"Method_CSTElementType",
++				"%s package element %" PRIu32 " was not a package.",
++				name, i);
++			cst_elements_ok[i] = false;
++			failed = true;
++			continue;	/* Skip processing sub-package */
++		}
++
++		pkg = &obj->Package.Elements[i];
++
++		if (pkg->Package.Count != 4) {
++			fwts_failed(fw, LOG_LEVEL_MEDIUM,
++				"Method_CSTElementPackageCountInvalid",
++				"%s package element %" PRIu32 " should have "
++				"4 elements, instead it had %" PRIu32 ".",
++				name, i, pkg->Package.Count);
++			cst_elements_ok[i] = false;
++			failed = true;
++			continue;
++		}
++
++		for (j = 0; j < 4; j++) {
++			if (pkg->Package.Elements[j].Type != cstate_types[j].type) {
++				fwts_failed(fw, LOG_LEVEL_MEDIUM,
++					"Method_CSTCStatePackageElementInvalidType",
++					"%s C-State package %" PRIu32 " element %" PRIu32
++					" was not a %s.",
++					name, i, j, cstate_types[j].name);
++				cst_elements_ok[i] = false;
++				failed = true;
++			}
++		}
++
++		/* Some very simple sanity checks on Register Resource Buffer */
++		if (pkg->Package.Elements[0].Type == ACPI_TYPE_BUFFER) {
++			if (pkg->Package.Elements[0].Buffer.Pointer == NULL) {
++				fwts_failed(fw, LOG_LEVEL_MEDIUM,
++					"Method_CSTCStateRegisterResourceBufferNull",
++					"%s C-State package %" PRIu32 " has a NULL "
++					"Register Resource Buffer", name, i);
++				failed = true;
++			} else {
++				uint8_t *data = (uint8_t *)pkg->Package.Elements[0].Buffer.Pointer;
++				size_t  length = (size_t)pkg->Package.Elements[0].Buffer.Length;
++
++				if (data[0] != 0x82) {
++					fwts_failed(fw, LOG_LEVEL_MEDIUM,
++					"Method_CSTCStateResourceBufferWrongType",
++					"%s C-State package %" PRIu32 " has a Resource "
++					"type 0x%2.2" PRIx8 ", however, was expecting a Register "
++					"Resource type 0x82.", name, i, data[0]);
++					failed = true;
++				}
++				else {
++					bool passed = true;
++					method_test_CRS_large_size(fw, name, "_CST", data, length, 12, 12, &passed);
++					if (!passed)
++						failed = true;
++				}
++			}
++		}
++
++		if (cst_elements_ok[i])
++			an_element_ok = true;
++	}
++
++	/*  Now dump out per CPU C-state information */
++	if (an_element_ok) {
++		fwts_log_info_verbatim(fw, "%s values:", name);
++		fwts_log_info_verbatim(fw, "#   C-State   Latency     Power");
++		fwts_log_info_verbatim(fw, "                (us)      (mW)");
++		for (i = 1; i < obj->Package.Count; i++){
++			if (cst_elements_ok[i]) {
++				ACPI_OBJECT *pkg = &obj->Package.Elements[i];
++				fwts_log_info_verbatim(fw,
++					"%2" PRIu32 "     C%" PRIu64 "     %6" PRIu64 "    %6" PRIu64,
++					i,
++					(uint64_t)pkg->Package.Elements[1].Integer.Value,
++					(uint64_t)pkg->Package.Elements[2].Integer.Value,
++					(uint64_t)pkg->Package.Elements[3].Integer.Value);
++			} else {
++				fwts_log_info_verbatim(fw,
++					"%2" PRIu32 "     --      -----     -----", i);
++			}
++		}
++	}
++
++	free(cst_elements_ok);
++
++	if (!failed)
++		method_passed_sane(fw, name, "values");
++}
++
++static int method_test_CST(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_OPTIONAL,
++		"_CST", NULL, 0, method_test_CST_return, NULL);
++}
++
++static void method_test_PCT_return(
++	fwts_framework *fw,
++	char *name,
++	ACPI_BUFFER *buf,
++	ACPI_OBJECT *obj,
++	void *private)
++{
++	FWTS_UNUSED(private);
++
++	if (method_check_type(fw, name, buf, ACPI_TYPE_PACKAGE) != FWTS_OK)
++		return;
++
++	/* Something is really wrong if we don't have any elements in _PCT */
++	if (method_package_count_min(fw, name, "_PCT", obj, 2) != FWTS_OK)
++		return;
++
++	if (method_package_elements_all_type(fw, name, "_PCT",
++		obj, ACPI_TYPE_BUFFER) != FWTS_OK)
++		return;
++
++	method_passed_sane(fw, name, "package");
++}
++
++static int method_test_PCT(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_OPTIONAL, "_PCT", NULL,
++		0, method_test_PCT_return, NULL);
++}
++
++static void method_test_PSS_return(
++	fwts_framework *fw,
++	char *name,
++	ACPI_BUFFER *buf,
++	ACPI_OBJECT *obj,
++	void *private)
++{
++	uint32_t i;
++	bool failed = false;
++	uint32_t max_freq = 0;
++	uint32_t prev_power = 0;
++	bool max_freq_valid = false;
++	bool dump_elements = false;
++	bool *element_ok;
++
++	FWTS_UNUSED(private);
++
++	if (method_check_type(fw, name, buf, ACPI_TYPE_PACKAGE) != FWTS_OK)
++		return;
++
++	/* Something is really wrong if we don't have any elements in _PSS */
++	if (method_package_count_min(fw, name, "_PSS", obj, 1) != FWTS_OK)
++		return;
++
++	element_ok = calloc(obj->Package.Count, sizeof(bool));
++	if (element_ok == NULL) {
++		fwts_log_error(fw, "Cannot allocate an array. Test aborted.");
++		return;
++	}
++
++	for (i = 0; i < obj->Package.Count; i++) {
++		ACPI_OBJECT *pstate;
++
++		if (obj->Package.Elements[i].Type != ACPI_TYPE_PACKAGE) {
++			fwts_failed(fw, LOG_LEVEL_MEDIUM,
++				"Method_PSSElementType",
++				"%s package element %" PRIu32
++				" was not a package.", name, i);
++			failed = true;
++			continue;	/* Skip processing sub-package */
++		}
++
++		pstate = &obj->Package.Elements[i];
++		if (pstate->Package.Count != 6) {
++			fwts_failed(fw, LOG_LEVEL_MEDIUM,
++				"Method_PSSSubPackageElementCount",
++				"%s P-State sub-package %" PRIu32
++				" was expected to "
++				"have 6 elements, got %" PRIu32 " elements instead.",
++				name, i, obj->Package.Count);
++			failed = true;
++			continue;	/* Skip processing sub-package */
++		}
++
++		/* Elements need to be all ACPI integer types */
++		if ((pstate->Package.Elements[0].Type != ACPI_TYPE_INTEGER) ||
++		    (pstate->Package.Elements[1].Type != ACPI_TYPE_INTEGER) ||
++		    (pstate->Package.Elements[2].Type != ACPI_TYPE_INTEGER) ||
++		    (pstate->Package.Elements[3].Type != ACPI_TYPE_INTEGER) ||
++		    (pstate->Package.Elements[4].Type != ACPI_TYPE_INTEGER) ||
++		    (pstate->Package.Elements[5].Type != ACPI_TYPE_INTEGER)) {
++			fwts_failed(fw, LOG_LEVEL_MEDIUM,
++				"Method_PSSSubPackageElementType",
++				"%s P-State sub-package %" PRIu32 " was expected to "
++				"have 6 Integer elements but didn't", name, i);
++			failed = true;
++			continue;
++		}
++
++		/*
++	 	 *  Parses OK, so this element can be dumped out
++		 */
++		element_ok[i] = true;
++		dump_elements = true;
++
++		/*
++		 * Collect maximum frequency.  The sub-packages are sorted in
++		 * descending power dissipation order, so one would assume that
++		 * the highest frequency is first.  However, it is not clear
++		 * from the ACPI spec that this is necessarily an assumption we
++		 * should make, so instead we should probably scan through all
++		 * the valid sub-packages and find the highest frequency.
++		 */
++		if (max_freq < pstate->Package.Elements[0].Integer.Value) {
++			max_freq = pstate->Package.Elements[0].Integer.Value;
++			max_freq_valid = true;
++		}
++
++		/* Sanity check descending power dissipation levels */
++		if ((i > 0) && (prev_power != 0) &&
++		    (pstate->Package.Elements[1].Integer.Value > prev_power)) {
++			fwts_failed(fw, LOG_LEVEL_MEDIUM,
++				"Method_PSSSubPackagePowerNotDecending",
++				"%s P-State sub-package %" PRIu32 " has a larger "
++				"power dissipation setting than the previous "
++				"sub-package.", name, i);
++			fwts_advice(fw,
++				"_PSS P-States must be ordered in decending "
++				"order of power dissipation, so that the "
++				"zero'th entry has the highest power "
++				"dissipation level and the Nth has the "
++				"lowest.");
++			failed = true;
++		}
++		prev_power = pstate->Package.Elements[1].Integer.Value;
++	}
++
++	/*
++	 *  If we have some valid data then dump it out, it is useful to see
++	 */
++	if (dump_elements) {
++		fwts_log_info_verbatim(fw, "%s values:", name);
++		fwts_log_info_verbatim(fw, "P-State  Freq     Power  Latency   Bus Master");
++		fwts_log_info_verbatim(fw, "         (MHz)    (mW)    (us)    Latency (us)");
++		for (i = 0; i < obj->Package.Count; i++) {
++			ACPI_OBJECT *pstate = &obj->Package.Elements[i];
++			if (element_ok[i]) {
++				fwts_log_info_verbatim(fw, " %3d   %7" PRIu64 " %8" PRIu64
++					" %5" PRIu64 "     %5" PRIu64,
++					i,
++					(uint64_t)pstate->Package.Elements[0].Integer.Value,
++					(uint64_t)pstate->Package.Elements[1].Integer.Value,
++					(uint64_t)pstate->Package.Elements[2].Integer.Value,
++					(uint64_t)pstate->Package.Elements[3].Integer.Value);
++			} else {
++				fwts_log_info_verbatim(fw,
++					" %3d      ----    -----    --        -- (invalid)", i);
++			}
++		}
++	}
++
++	free(element_ok);
++
++	/*
++	 * Sanity check maximum frequency.  We could also check the DMI data
++	 * for a BIOS date (but this can be wrong) or check the CPU identity
++	 * (which requires adding in new CPU identity checks) to make a decision
++	 * on when it is reasonable to assume a CPU is modern and hence clocked
++	 * incorrectly.  For now, just flag up a low level error that the
++	 * frequency looks rather low rather than try to be intelligent (and
++	 * possibly make a mistake).  I'd rather flag up a few false positives
++	 * on older machines than miss flagging up bad _PSS settings on new
++	 * machines.
++	 */
++	if (max_freq_valid && max_freq < 1000) {
++		fwts_failed(fw, LOG_LEVEL_LOW, "Method_PSSSubPackageLowFreq",
++			"Maximum CPU frequency is %dHz and this is low for "
++			"a modern processor. This may indicate the _PSS "
++			"P-States are incorrect\n", max_freq);
++		fwts_advice(fw,
++			"The _PSS P-States are used by the Linux CPU frequency "
++			"driver to set the CPU frequencies according to system "
++			"load.  Sometimes the firmware sets these incorrectly "
++			"and the machine runs at a sub-optimal speed.  One can "
++			"view the firmware defined CPU frequencies via "
++			"/sys/devices/system/cpu/cpu*/cpufreq/"
++			"scaling_available_frequencies");
++		failed = true;
++	}
++
++	if (!failed)
++		method_passed_sane(fw, name, "package");
++}
++
++static int method_test_PSS(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_OPTIONAL, "_PSS", NULL, 0, method_test_PSS_return, NULL);
++}
++
++static int method_test_PPC(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_OPTIONAL,
++		"_PPC", NULL, 0, method_test_integer_return, NULL);
++}
++
++static int method_test_PPE(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_OPTIONAL,
++		"_PPE", NULL, 0, method_test_integer_return, NULL);
++}
++
++static void method_test_PSD_return(
++	fwts_framework *fw,
++	char *name,
++	ACPI_BUFFER *buf,
++	ACPI_OBJECT *obj,
++	void *private)
++{
++	uint32_t i;
++	bool failed = false;
++
++	FWTS_UNUSED(private);
++
++	if (method_check_type(fw, name, buf, ACPI_TYPE_PACKAGE) != FWTS_OK)
++		return;
++
++	if (method_package_elements_all_type(fw, name, "_PSD", obj, ACPI_TYPE_PACKAGE) != FWTS_OK)
++		return;
++
++	/* Could be one or more packages */
++	for (i = 0; i < obj->Package.Count; i++) {
++		ACPI_OBJECT *pkg;
++		uint32_t j;
++		bool elements_ok = true;
++
++		pkg = &obj->Package.Elements[i];
++		if (pkg->Package.Count != 5) {
++			fwts_failed(fw, LOG_LEVEL_MEDIUM,
++				"Method_PSDSubPackageElementCount",
++				"%s sub-package %" PRIu32 " was expected to "
++				"have 5 elements, got %" PRIu32 " elements instead.",
++				name, i, pkg->Package.Count);
++			failed = true;
++			continue;
++		}
++
++		/* Elements in Sub-packages are integers */
++		for (j = 0; j < 5; j++) {
++			if (pkg->Package.Elements[j].Type != ACPI_TYPE_INTEGER) {
++				fwts_failed(fw, LOG_LEVEL_MEDIUM,
++					"Method_PSDBadSubPackageReturnType",
++					"%s sub-package %" PRIu32
++					" element %" PRIu32 " is not "
++					"an integer.",
++					name, i, j);
++				elements_ok = false;
++			}
++		}
++
++		if (!elements_ok) {
++			failed = true;
++			continue;
++		}
++	}
++
++	if (!failed)
++		method_passed_sane(fw, name, "package");
++}
++
++static int method_test_PSD(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_OPTIONAL,
++		"_PSD", NULL, 0, method_test_PSD_return, NULL);
++}
++
++static int method_test_PDL(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_OPTIONAL,
++		"_PDL", NULL, 0, method_test_integer_return, NULL);
++}
++
++
++static void method_test_PTC_return(
++	fwts_framework *fw,
++	char *name,
++	ACPI_BUFFER *buf,
++	ACPI_OBJECT *obj,
++	void *private)
++{
++	uint32_t i;
++	bool failed = false;
++
++	FWTS_UNUSED(private);
++
++	if (method_check_type(fw, name, buf, ACPI_TYPE_PACKAGE) != FWTS_OK)
++		return;
++
++	if (method_package_elements_all_type(fw, name, "_PTC", obj, ACPI_TYPE_BUFFER) != FWTS_OK)
++		return;
++
++	if (method_package_count_equal(fw, name, "_PTC", obj, 2) != FWTS_OK)
++		return;
++
++	for (i = 0; i < obj->Package.Count; i++) {
++		ACPI_RESOURCE *resource;
++		ACPI_STATUS   status;
++		ACPI_OBJECT *element_buf = &obj->Package.Elements[i];
++
++		status = AcpiBufferToResource(element_buf->Buffer.Pointer, element_buf->Buffer.Length, &resource);
++		if (ACPI_FAILURE(status)) {
++			failed = true;
++			fwts_failed(fw, LOG_LEVEL_HIGH,
++				"Method_PTCBadElement",
++				"%s should contain only Resource Descriptors", name);
++			continue;
++		}
++
++		if (resource->Type != ACPI_RESOURCE_TYPE_GENERIC_REGISTER) {
++			failed = true;
++			fwts_failed(fw, LOG_LEVEL_HIGH,
++				"Method_PTCBadElement",
++				"%s should contain only Resource Type 16, got %" PRIu32 "\n",
++					name, resource->Type);
++		}
++	}
++
++	if (!failed)
++		method_passed_sane(fw, name, "package");
++}
++
++static int method_test_PTC(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_OPTIONAL,
++		"_PTC", NULL, 0, method_test_PTC_return, NULL);
++}
++
++static int method_test_TDL(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_OPTIONAL,
++		"_TDL", NULL, 0, method_test_integer_return, NULL);
++}
++
++static int method_test_TPC(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_OPTIONAL,
++		"_TPC", NULL, 0, method_test_integer_return, NULL);
++}
++
++static void method_test_TSD_return(
++	fwts_framework *fw,
++	char *name,
++	ACPI_BUFFER *buf,
++	ACPI_OBJECT *obj,
++	void *private)
++{
++	uint32_t i;
++	bool failed = false;
++
++	FWTS_UNUSED(private);
++
++	if (method_check_type(fw, name, buf, ACPI_TYPE_PACKAGE) != FWTS_OK)
++		return;
++
++	/* Something is really wrong if we don't have any elements in _TSD */
++	if (method_package_count_min(fw, name, "_TSD", obj, 1) != FWTS_OK)
++		return;
++
++	/* Could be one or more packages */
++	for (i = 0; i < obj->Package.Count; i++) {
++		ACPI_OBJECT *pkg;
++		uint32_t j;
++		bool elements_ok = true;
++
++		if (obj->Package.Elements[i].Type != ACPI_TYPE_PACKAGE) {
++			fwts_failed(fw, LOG_LEVEL_MEDIUM,
++				"Method_TSDElementType",
++				"%s package element %" PRIu32
++				" was not a package.", name, i);
++			failed = true;
++			continue;	/* Skip processing sub-package */
++		}
++
++		pkg = &obj->Package.Elements[i];
++		/*
++		 *  Currently we expect a package of 5 integers.
++		 */
++		if (pkg->Package.Count != 5) {
++			fwts_failed(fw, LOG_LEVEL_MEDIUM,
++				"Method_TSDSubPackageElementCount",
++				"%s sub-package %" PRIu32 " was expected to "
++				"have 5 elements, got %" PRIu32 " elements instead.",
++				name, i, pkg->Package.Count);
++			failed = true;
++			continue;
++		}
++
++		for (j = 0; j < 5; j++) {
++			if (pkg->Package.Elements[j].Type != ACPI_TYPE_INTEGER) {
++				fwts_failed(fw, LOG_LEVEL_MEDIUM,
++					"Method_TSDSubPackageElementCount",
++					"%s sub-package %" PRIu32
++					" element %" PRIu32 " is not "
++					"an integer.", name, i, j);
++				elements_ok = false;
++			}
++		}
++
++		if (!elements_ok) {
++			failed = true;
++			continue;
++		}
++
++		/* Element 0 must equal the number elements in the package */
++		if (pkg->Package.Elements[0].Integer.Value != pkg->Package.Count) {
++			fwts_failed(fw, LOG_LEVEL_MEDIUM,
++				"Method_TSDSubPackageElement0",
++				"%s sub-package %" PRIu32
++				" element 0 (NumEntries) "
++				"was expected to have value 0x%" PRIx64 ".",
++				name, i,
++				(uint64_t)pkg->Package.Elements[0].Integer.Value);
++			failed = true;
++		}
++		/* Element 1 should contain zero */
++		if (pkg->Package.Elements[1].Integer.Value != 0) {
++			fwts_failed(fw, LOG_LEVEL_MEDIUM,
++				"Method_TSDSubPackageElement1",
++				"%s sub-package %" PRIu32
++				" element 1 (Revision) "
++				"was expected to have value 1, instead it "
++				"was 0x%" PRIx64 ".",
++				name, i,
++				(uint64_t)pkg->Package.Elements[1].Integer.Value);
++			failed = true;
++		}
++		/* Element 3 should contain 0xfc..0xfe */
++		if ((pkg->Package.Elements[3].Integer.Value != 0xfc) &&
++		    (pkg->Package.Elements[3].Integer.Value != 0xfd) &&
++		    (pkg->Package.Elements[3].Integer.Value != 0xfe)) {
++			fwts_failed(fw, LOG_LEVEL_MEDIUM,
++				"Method_TSDSubPackageElement1",
++				"%s sub-package %" PRIu32
++				" element 3 (CoordType) "
++				"was expected to have value 0xfc (SW_ALL), "
++				"0xfd (SW_ANY) or 0xfe (HW_ALL), instead it "
++				"was 0x%" PRIx64 ".",
++				name, i,
++				(uint64_t)pkg->Package.Elements[3].Integer.Value);
++			failed = true;
++		}
++		/* Element 4 number of processors, skip check */
++	}
++
++	if (!failed)
++		method_passed_sane(fw, name, "package");
++}
++
++static int method_test_TSD(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_OPTIONAL,
++		"_TSD", NULL, 0, method_test_TSD_return, NULL);
++}
++
++static void method_test_TSS_return(
++	fwts_framework *fw,
++	char *name,
++	ACPI_BUFFER *buf,
++	ACPI_OBJECT *obj,
++	void *private)
++{
++	uint32_t i;
++	bool failed = false;
++	bool *tss_elements_ok;
++	bool an_element_ok = false;
++
++	FWTS_UNUSED(private);
++
++	if (method_check_type(fw, name, buf, ACPI_TYPE_PACKAGE) != FWTS_OK)
++		return;
++
++	/* Something is really wrong if we don't have any elements in _TSS */
++	if (method_package_count_min(fw, name, "_TSS", obj, 1) != FWTS_OK)
++		return;
++
++	tss_elements_ok = calloc(obj->Package.Count, sizeof(bool));
++	if (tss_elements_ok == NULL) {
++		fwts_log_error(fw, "Cannot allocate an array. Test aborted.");
++		return;
++	}
++
++	/* Could be one or more packages */
++	for (i = 0; i < obj->Package.Count; i++) {
++		ACPI_OBJECT *pkg;
++		uint32_t j;
++
++		tss_elements_ok[i] = true;
++
++		if (obj->Package.Elements[i].Type != ACPI_TYPE_PACKAGE) {
++			fwts_failed(fw, LOG_LEVEL_MEDIUM,
++				"Method_TSSElementType",
++				"%s package element %" PRIu32
++				" was not a package.", name, i);
++			tss_elements_ok[i] = false;
++			failed = true;
++			continue;	/* Skip processing sub-package */
++		}
++
++		pkg = &obj->Package.Elements[i];
++		/*
++		 *  We expect a package of 5 integers.
++		 */
++		if (pkg->Package.Count != 5) {
++			fwts_failed(fw, LOG_LEVEL_MEDIUM,
++				"Method_TSSSubPackageElementCount",
++				"%s sub-package %" PRIu32
++				" was expected to have 5 elements, "
++				"got %" PRIu32" elements instead.",
++				name, i, pkg->Package.Count);
++			tss_elements_ok[i] = false;
++			failed = true;
++			continue;	/* Skip processing sub-package */
++		}
++
++		for (j = 0; j < 5; j++) {
++			if (pkg->Package.Elements[j].Type != ACPI_TYPE_INTEGER) {
++				fwts_failed(fw, LOG_LEVEL_MEDIUM,
++					"Method_TSSSubPackageElementCount",
++					"%s sub-package %" PRIu32
++					" element %" PRIu32 " is not "
++					"an integer.", name, i, j);
++				tss_elements_ok[i] = false;
++			}
++		}
++		if (!tss_elements_ok[i]) {
++			failed = true;
++			continue;
++		}
++
++		/* At least one element is OK, so remember that */
++		an_element_ok = true;
++
++		/* Element 0 must be 1..100 */
++		if ((pkg->Package.Elements[0].Integer.Value < 1) ||
++		    (pkg->Package.Elements[0].Integer.Value > 100)) {
++			fwts_failed(fw, LOG_LEVEL_MEDIUM,
++				"Method_TSDSubPackageElement0",
++				"%s sub-package %" PRIu32 " element 0"
++				"was expected to have value 1..100, instead "
++				"was %" PRIu64 ".",
++				name, i,
++				(uint64_t)pkg->Package.Elements[0].Integer.Value);
++			failed = true;
++		}
++		/* Skip checking elements 1..4 */
++	}
++
++	/* Summary info */
++	if (an_element_ok) {
++		fwts_log_info_verbatim(fw, "%s values:", name);
++		fwts_log_info_verbatim(fw, "T-State  CPU     Power   Latency  Control  Status");
++		fwts_log_info_verbatim(fw, "         Freq    (mW)    (usecs)");
++		for (i = 0; i < obj->Package.Count; i++) {
++			if (tss_elements_ok[i]) {
++				ACPI_OBJECT *pkg = &obj->Package.Elements[i];
++
++				fwts_log_info_verbatim(fw,
++					"  %3d    %3" PRIu64 "%%  %7" PRIu64 "  %7" PRIu64
++					"      %2.2" PRIx64 "      %2.2" PRIx64, i,
++					(uint64_t)pkg->Package.Elements[0].Integer.Value,
++					(uint64_t)pkg->Package.Elements[1].Integer.Value,
++					(uint64_t)pkg->Package.Elements[2].Integer.Value,
++					(uint64_t)pkg->Package.Elements[3].Integer.Value,
++					(uint64_t)pkg->Package.Elements[4].Integer.Value);
++			} else {
++				fwts_log_info_verbatim(fw,
++					"  %3d    ----    -----    -----      --      -- (invalid)", i);
++			}
++		}
++	}
++	free(tss_elements_ok);
++
++	if (!failed)
++		method_passed_sane(fw, name, "package");
++}
++
++static int method_test_TSS(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_OPTIONAL,
++		"_TSS", NULL, 0, method_test_TSS_return, NULL);
++}
++
++/*
++ * Section 8.4.4 Lower Power Idle States
++*/
++
++static void method_test_LPI_return(
++	fwts_framework *fw,
++	char *name,
++	ACPI_BUFFER *buf,
++	ACPI_OBJECT *obj,
++	void *private)
++{
++	uint32_t i, j;
++	bool failed = false;
++
++	FWTS_UNUSED(private);
++
++	if (method_check_type(fw, name, buf, ACPI_TYPE_PACKAGE) != FWTS_OK)
++		return;
++
++	if (method_package_count_min(fw, name, "_LPI", obj, 3) != FWTS_OK)
++		return;
++
++	/* first 3 elements are integers, and rests are packages */
++	for (i = 0; i < obj->Package.Count; i++) {
++		if (i < 3) {
++			if (obj->Package.Elements[i].Type != ACPI_TYPE_INTEGER) {
++				fwts_failed(fw, LOG_LEVEL_HIGH,
++					"Method_LPIBadElementType",
++					"%s element %" PRIu32 " is not an integer.", name, i);
++				failed = true;
++				continue;
++			}
++
++			if (i == 0) {
++				if (obj->Package.Elements[i].Integer.Value != 0) {
++					fwts_failed(fw, LOG_LEVEL_HIGH,
++						"Method_LPIBadRevision",
++						"%s: Expected Revision to be 0, "
++						"got 0x%4.4" PRIx64 ".", name,
++						(uint64_t)obj->Package.Elements[i].Integer.Value);
++					failed = true;
++				}
++			} else if (i == 2) {
++				if (obj->Package.Elements[i].Integer.Value != obj->Package.Count - 3) {
++					fwts_failed(fw, LOG_LEVEL_HIGH,
++					"Method_LPIBadCount",
++					"%s Count reports %" PRIu32 ", but there are %" PRIu32 " sub-packages.",
++					name, (uint32_t) obj->Package.Elements[i].Integer.Value,
++					obj->Package.Count - 3);
++					failed = true;
++				}
++			}
++		} else {
++			ACPI_OBJECT *pkg;
++			if (obj->Package.Elements[i].Type != ACPI_TYPE_PACKAGE) {
++				fwts_failed(fw, LOG_LEVEL_HIGH,
++					"Method_LPIBadElementType",
++					"%s element %" PRIu32 " is not a package.", name, i);
++				failed = true;
++				continue;
++			}
++
++			pkg = &obj->Package.Elements[i];
++			for (j = 0; j < pkg->Package.Count; j++) {
++				switch (j) {
++				case 0 ... 5:
++					if (pkg->Package.Elements[j].Type != ACPI_TYPE_INTEGER) {
++						fwts_failed(fw, LOG_LEVEL_HIGH,
++							"Method_LPIBadESublementType",
++							"%s sub-package %" PRIu32 " element %" PRIu32 " is not "
++							"an integer.", name, i, j);
++						failed = true;
++					}
++					break;
++				case 6:
++					if (pkg->Package.Elements[j].Type != ACPI_TYPE_INTEGER &&
++					    pkg->Package.Elements[j].Type != ACPI_TYPE_BUFFER) {
++						fwts_failed(fw, LOG_LEVEL_HIGH,
++							"Method_LPIBadESublementType",
++							"%s sub-package %" PRIu32 " element %" PRIu32 " is not "
++							"a buffer or an integer.", name, i, j);
++						failed = true;
++					}
++					break;
++				case 7 ... 8:
++					if (pkg->Package.Elements[j].Type != ACPI_TYPE_BUFFER) {
++						fwts_failed(fw, LOG_LEVEL_HIGH,
++							"Method_LPIBadESublementType",
++							"%s sub-package %" PRIu32 " element %" PRIu32 " is not "
++							"a buffer.", name, i, j);
++						failed = true;
++					}
++					break;
++				case 9:
++					if (pkg->Package.Elements[j].Type != ACPI_TYPE_STRING) {
++						fwts_failed(fw, LOG_LEVEL_HIGH,
++							"Method_LPIBadESublementType",
++							"%s sub-package %" PRIu32 " element %" PRIu32 " is not "
++							"a string.", name, i, j);
++						failed = true;
++					}
++					break;
++				default:
++					fwts_failed(fw, LOG_LEVEL_HIGH,
++						"Method_LPIBadESublement",
++						"%s sub-package %" PRIu32 " element %" PRIu32 " should have "
++						"9 elements, got .", name, i, j+1);
++					failed = true;
++					break;
++				}
++			}
++		}
++	}
++
++	if (!failed)
++		method_passed_sane(fw, name, "package");
++}
++
++static int method_test_LPI(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_OPTIONAL,
++		"_LPI", NULL, 0, method_test_LPI_return, NULL);
++}
++
++static void method_test_RDI_return(
++	fwts_framework *fw,
++	char *name,
++	ACPI_BUFFER *buf,
++	ACPI_OBJECT *obj,
++	void *private)
++{
++	uint32_t i, j;
++	bool failed = false;
++
++	FWTS_UNUSED(private);
++
++	if (method_check_type(fw, name, buf, ACPI_TYPE_PACKAGE) != FWTS_OK)
++		return;
++
++	/* First element is Revision */
++	if (obj->Package.Elements[0].Integer.Value != 0) {
++		fwts_failed(fw, LOG_LEVEL_HIGH,
++			"Method_RDIBadID",
++			"%s: Expected Revision to be 0, "
++			"got 0x%4.4" PRIx64 ".", name,
++			(uint64_t)obj->Package.Elements[0].Integer.Value);
++		failed = true;
++	}
++
++	/* The rest of elements are packages with references */
++	for (i = 1; i < obj->Package.Count; i++) {
++		ACPI_OBJECT *pkg;
++		pkg = &obj->Package.Elements[i];
++
++		if (pkg->Type != ACPI_TYPE_PACKAGE) {
++			fwts_failed(fw, LOG_LEVEL_HIGH,
++				"Method_RDIBadElementType",
++				"%s element %" PRIu32 " is not a package.", name, i);
++			failed = true;
++			continue;
++		}
++
++		for (j = 0; j < pkg->Package.Count; j++) {
++			if (pkg->Package.Elements[j].Type != ACPI_TYPE_LOCAL_REFERENCE) {
++				fwts_failed(fw, LOG_LEVEL_HIGH,
++					"Method_RDIBadESublementType",
++					"%s sub-package %" PRIu32 " element %" PRIu32 " is not "
++					"a Reference.", name, i, j);
++				failed = true;
++			}
++		}
++	}
++
++	if (!failed)
++		method_passed_sane(fw, name, "package");
++}
++
++static int method_test_RDI(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_OPTIONAL,
++		"_RDI", NULL, 0, method_test_RDI_return, NULL);
++}
++
++/*
++ * Section 8.5 Processor Aggregator Device
++ */
++
++static void method_test_PUR_return(
++	fwts_framework *fw,
++	char *name,
++	ACPI_BUFFER *buf,
++	ACPI_OBJECT *obj,
++	void *private)
++{
++	static fwts_package_element elements[] = {
++		{ ACPI_TYPE_INTEGER,	"RevisionID" },
++		{ ACPI_TYPE_INTEGER,	"NumProcessors" },
++	};
++
++	FWTS_UNUSED(private);
++
++	if (method_check_type(fw, name, buf, ACPI_TYPE_PACKAGE) != FWTS_OK)
++		return;
++
++	if (method_package_count_equal(fw, name, "_PUR", obj, 2) != FWTS_OK)
++		return;
++
++	if (method_package_elements_type(fw, name, "_PUR", obj, elements, 2) != FWTS_OK)
++		return;
++
++	/* RevisionID */
++	if (obj->Package.Elements[0].Integer.Value != 1) {
++		fwts_failed(fw, LOG_LEVEL_MEDIUM,
++			"Method_PURBadID",
++			"%s: Expected RevisionID to be 1, "
++			"got 0x%8.8" PRIx64 ".", name,
++			(uint64_t)obj->Package.Elements[0].Integer.Value);
++		return;
++	}
++
++	method_passed_sane(fw, name, "package");
++}
++
++static int method_test_PUR(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_OPTIONAL,
++		"_PUR", NULL, 0, method_test_PUR_return, NULL);
++}
++
++/*
++ * Section 9.1 System Indicators
++ */
++
++static int method_test_SST(fwts_framework *fw)
++{
++	ACPI_OBJECT arg[1];
++	int ret, i;
++
++	arg[0].Type = ACPI_TYPE_INTEGER;
++	for (i = 0; i <= 4; i++) {
++		arg[0].Integer.Value = i;
++		ret = method_evaluate_method(fw, METHOD_OPTIONAL,
++			"_SST", arg, 1, method_test_NULL_return, NULL);
++
++		if (ret != FWTS_OK)
++			break;
++	}
++	return ret;
++}
++
++static int method_test_MSG(fwts_framework *fw)
++{
++	ACPI_OBJECT arg[1];
++
++	arg[0].Type = ACPI_TYPE_INTEGER;
++	arg[0].Integer.Value = 0;
++
++	return method_evaluate_method(fw, METHOD_OPTIONAL,
++		"_MSG", arg, 1, method_test_NULL_return, NULL);
++}
++
++/*
++ * Section 9.2 Ambient Light Sensor Device
++ */
++method_test_integer(_ALC, METHOD_OPTIONAL)
++method_test_integer(_ALI, METHOD_OPTIONAL)
++method_test_integer(_ALT, METHOD_OPTIONAL)
++
++static void method_test_ALR_return(
++	fwts_framework *fw,
++	char *name,
++	ACPI_BUFFER *buf,
++	ACPI_OBJECT *obj,
++	void *private)
++{
++	uint32_t i;
++	bool failed = false;
++	uint32_t adjustment = 0, illuminance = 0;
++
++	FWTS_UNUSED(private);
++
++	if (method_check_type(fw, name, buf, ACPI_TYPE_PACKAGE) != FWTS_OK)
++		return;
++
++	/* Could be one or more sub-packages */
++	for (i = 0; i < obj->Package.Count; i++) {
++		ACPI_OBJECT *pkg;
++
++		pkg = &obj->Package.Elements[i];
++		if (pkg->Package.Count != 2) {
++			fwts_failed(fw, LOG_LEVEL_MEDIUM,
++				"Method_ALRBadSubPackageElementCount",
++				"%s sub-package %" PRIu32 " was expected to "
++				"have 2 elements, got %" PRIu32 " elements instead.",
++				name, i, pkg->Package.Count);
++			failed = true;
++		} else {
++			/* elements should be listed in monotonically increasing order */
++			if (pkg->Package.Elements[0].Type != ACPI_TYPE_INTEGER ||
++			    adjustment > pkg->Package.Elements[0].Integer.Value) {
++				fwts_failed(fw, LOG_LEVEL_MEDIUM,
++					"Method_ALRBadSubPackageReturnType",
++					"%s sub-package %" PRIu32
++					" element 0 is an invalid integer.",
++					name, i);
++				failed = true;
++			}
++
++			if (pkg->Package.Elements[1].Type != ACPI_TYPE_INTEGER ||
++			    illuminance > pkg->Package.Elements[1].Integer.Value) {
++				fwts_failed(fw, LOG_LEVEL_MEDIUM,
++					"Method_ALRBadSubPackageReturnType",
++					"%s sub-package %" PRIu32
++					" element 1 is an invalid integer.",
++					name, i);
++				failed = true;
++			}
++			adjustment = pkg->Package.Elements[0].Integer.Value;
++			illuminance = pkg->Package.Elements[1].Integer.Value;
++		}
++	}
++
++	if (!failed)
++		method_passed_sane(fw, name, "package");
++}
++
++static int method_test_ALR(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_OPTIONAL,
++		"_ALR", NULL, 0, method_test_ALR_return, NULL);
++}
++
++static int method_test_ALP(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_OPTIONAL,
++		"_ALP", NULL, 0, method_test_polling_return, "_ALP");
++}
++
++
++/*
++ * Section 9.4 Lid control
++ */
++static void method_test_LID_return(
++	fwts_framework *fw,
++	char *name,
++	ACPI_BUFFER *buf,
++	ACPI_OBJECT *obj,
++	void *private)
++{
++	FWTS_UNUSED(private);
++
++	if (method_check_type(fw, name, buf, ACPI_TYPE_INTEGER) == FWTS_OK)
++		method_passed_sane_uint64(fw, name, obj->Integer.Value);
++}
++
++static int method_test_LID(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_MOBILE,
++		"_LID", NULL, 0, method_test_LID_return, NULL);
++}
++
++
++/*
++ * Section 9.8 ATA Controllers
++ */
++
++static void method_test_GTF_return(
++	fwts_framework *fw,
++	char *name,
++	ACPI_BUFFER *buf,
++	ACPI_OBJECT *obj,
++	void *private)
++{
++	FWTS_UNUSED(private);
++
++	if (method_check_type(fw, name, buf, ACPI_TYPE_BUFFER) != FWTS_OK)
++		return;
++
++	if (obj->Buffer.Length % 7)
++		fwts_failed(fw, LOG_LEVEL_MEDIUM, "Method_GTFBadBufferSize",
++			"%s should return a buffer with size of multiple of 7.",
++			name);
++	else
++		method_passed_sane(fw, name, "buffer");
++}
++
++static int method_test_GTF(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_OPTIONAL,
++		"_GTF", NULL, 0, method_test_GTF_return, NULL);
++}
++
++static void method_test_GTM_return(
++	fwts_framework *fw,
++	char *name,
++	ACPI_BUFFER *buf,
++	ACPI_OBJECT *obj,
++	void *private)
++{
++	FWTS_UNUSED(private);
++
++	if (method_check_type(fw, name, buf, ACPI_TYPE_BUFFER) != FWTS_OK)
++		return;
++
++	if (obj->Buffer.Length != (5 * sizeof(uint32_t)))
++		fwts_failed(fw, LOG_LEVEL_MEDIUM, "Method_GTMBadBufferSize",
++			"%s should return a buffer with size of 20.",
++			name);
++	else
++		method_passed_sane(fw, name, "buffer");
++}
++
++static int method_test_GTM(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_OPTIONAL,
++		"_GTM", NULL, 0, method_test_GTM_return, NULL);
++}
++
++/*
++ * Section 9.12 Memory Devices
++ */
++
++static void method_test_MBM_return(
++	fwts_framework *fw,
++	char *name,
++	ACPI_BUFFER *buf,
++	ACPI_OBJECT *obj,
++	void *private)
++{
++	static fwts_package_element elements[] = {
++		{ ACPI_TYPE_INTEGER,	"Revision" },
++		{ ACPI_TYPE_INTEGER,	"Window Size" },
++		{ ACPI_TYPE_INTEGER,	"Sampling Interval" },
++		{ ACPI_TYPE_INTEGER,	"Maximum Bandwidth" },
++		{ ACPI_TYPE_INTEGER,	"Average Bandwidth" },
++		{ ACPI_TYPE_INTEGER,	"Low Bandwidth" },
++		{ ACPI_TYPE_INTEGER,	"Low Notification Threshold" },
++		{ ACPI_TYPE_INTEGER,	"High Notification Threshold" },
++	};
++
++	FWTS_UNUSED(private);
++
++	if (method_check_type(fw, name, buf, ACPI_TYPE_PACKAGE) != FWTS_OK)
++		return;
++
++	if (method_package_count_equal(fw, name, "_MBM", obj, 8) != FWTS_OK)
++		return;
++
++	/* For now, just check types */
++	if (method_package_elements_type(fw, name, "_MBM", obj, elements, 8) != FWTS_OK)
++		return;
++
++	method_passed_sane(fw, name, "package");
++}
++
++static int method_test_MBM(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_OPTIONAL,
++		"_MBM", NULL, 0, method_test_MBM_return, NULL);
++}
++
++/*
++ * Section 9.13 USB Port Capabilities
++ */
++
++static void method_test_UPC_return(
++	fwts_framework *fw,
++	char *name,
++	ACPI_BUFFER *buf,
++	ACPI_OBJECT *obj,
++	void *private)
++{
++	uint32_t i, connector_type;
++
++	FWTS_UNUSED(private);
++
++	if (method_check_type(fw, name, buf, ACPI_TYPE_PACKAGE) != FWTS_OK)
++		return;
++
++	if (method_package_count_equal(fw, name, "_UPC", obj, 4) != FWTS_OK)
++		return;
++
++	if (method_package_elements_all_type(fw, name, "_UPC", obj, ACPI_TYPE_INTEGER) != FWTS_OK)
++		return;
++
++	connector_type = obj->Package.Elements[1].Integer.Value;
++	if (connector_type  > 0x0a && connector_type < 0xFF) {
++		fwts_failed(fw, LOG_LEVEL_MEDIUM, "Method_UPCBadReturnType",
++			"%s element 1 returned reserved value.", name);
++		return;
++	}
++
++	for (i = 2; i < 4; i++) {
++		if (obj->Package.Elements[i].Integer.Value != 0) {
++			fwts_failed(fw, LOG_LEVEL_MEDIUM,
++				"Method_UPCBadReturnType",
++				"%s element %" PRIu32 " is not zero.", name, i);
++			return;
++		}
++	}
++
++	method_passed_sane(fw, name, "package");
++}
++
++static int method_test_UPC(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_OPTIONAL,
++		"_UPC", NULL, 0, method_test_UPC_return, NULL);
++}
++
++/*
++ * Section 9.16 User Presence Detection Device
++ */
++
++static int method_test_UPD(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_OPTIONAL,
++		"_UPD", NULL, 0, method_test_integer_return, NULL);
++}
++
++static int method_test_UPP(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_OPTIONAL,
++		"_UPP", NULL, 0, method_test_integer_return, NULL);
++}
++
++/*
++ * Section 9.18 Wake Alarm Device
++ */
++static void method_test_GCP_return(
++	fwts_framework *fw,
++	char *name,
++	ACPI_BUFFER *buf,
++	ACPI_OBJECT *obj,
++	void *private)
++{
++	FWTS_UNUSED(private);
++
++	if (method_check_type(fw, name, buf, ACPI_TYPE_INTEGER) != FWTS_OK)
++		return;
++
++	if (obj->Integer.Value & ~0x1f)
++		fwts_failed(fw, LOG_LEVEL_MEDIUM,
++			"Method_GCPReturn",
++			"%s returned %" PRId64 ", should be between 0 and 31, "
++			"one or more of the reserved bits 5..31 seem "
++			"to be set.",
++			name, (uint64_t)obj->Integer.Value);
++	else
++		method_passed_sane_uint64(fw, name, obj->Integer.Value);
++}
++
++static int method_test_GCP(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_OPTIONAL,
++		"_GCP", NULL, 0, method_test_GCP_return, "_GCP");
++}
++
++static void method_test_GRT_return(
++	fwts_framework *fw,
++	char *name,
++	ACPI_BUFFER *buf,
++	ACPI_OBJECT *obj,
++	void *private)
++{
++	FWTS_UNUSED(private);
++
++	if (method_check_type(fw, name, buf, ACPI_TYPE_BUFFER) != FWTS_OK)
++		return;
++
++	if (obj->Buffer.Length != 16) {
++		fwts_failed(fw, LOG_LEVEL_MEDIUM,
++			"Method_GRTBadBufferSize",
++			"%s should return a buffer of 16 bytes, but "
++			"instead just returned %" PRIu32,
++			name, obj->Buffer.Length);
++		return;
++	}
++
++	/*
++	 * Should sanity check this, but we can't read the
++	 * the data in this emulated mode, so ignore
++	 */
++	method_passed_sane(fw, name, "buffer");
++}
++
++static int method_test_GRT(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_OPTIONAL,
++		"_GRT", NULL, 0, method_test_GRT_return, NULL);
++}
++
++static void method_test_GWS_return(
++	fwts_framework *fw,
++	char *name,
++	ACPI_BUFFER *buf,
++	ACPI_OBJECT *obj,
++	void *private)
++{
++	FWTS_UNUSED(private);
++
++	if (method_check_type(fw, name, buf, ACPI_TYPE_INTEGER) != FWTS_OK)
++		return;
++
++	if (obj->Integer.Value & ~0x3)
++		fwts_failed(fw, LOG_LEVEL_MEDIUM,
++			"Method_GWSReturn",
++			"%s returned %" PRIu64 ", should be between 0 and 3, "
++			"one or more of the reserved bits 2..31 seem "
++			"to be set.",
++			name, (uint64_t)obj->Integer.Value);
++	else
++		method_passed_sane_uint64(fw, name, obj->Integer.Value);
++}
++
++static int method_test_GWS(fwts_framework *fw)
++{
++	ACPI_OBJECT arg[1];
++
++	arg[0].Type = ACPI_TYPE_INTEGER;
++	arg[0].Integer.Value = 1;	/* DC timer */
++
++	return method_evaluate_method(fw, METHOD_OPTIONAL,
++		"_GWS", arg, 1, method_test_GWS_return, "_GWS");
++}
++
++static void method_test_CWS_return(
++	fwts_framework *fw,
++	char *name,
++	ACPI_BUFFER *buf,
++	ACPI_OBJECT *obj,
++	void *private)
++{
++	FWTS_UNUSED(private);
++
++	if (method_check_type(fw, name, buf, ACPI_TYPE_INTEGER) != FWTS_OK)
++		return;
++
++	if (obj->Integer.Value != 0 && obj->Integer.Value != 1)
++		fwts_failed(fw, LOG_LEVEL_MEDIUM,
++			"Method_CWSInvalidInteger",
++			"%s returned %" PRIu64 ", should be 0 or 1.",
++			name, (uint64_t)obj->Integer.Value);
++	else
++		method_passed_sane_uint64(fw, name, obj->Integer.Value);
++}
++
++static int method_test_CWS(fwts_framework *fw)
++{
++	ACPI_OBJECT arg[1];
++	int i, ret;
++	arg[0].Type = ACPI_TYPE_INTEGER;
++
++	for (i = 0; i < 2; i++) {
++		arg[0].Integer.Value = i;
++		ret = method_evaluate_method(fw, METHOD_OPTIONAL,
++			"_CWS", arg, 1, method_test_CWS_return, NULL);
++
++		if (ret != FWTS_OK)
++			break;
++	}
++	return ret;
++}
++
++static void method_test_SRT_return(
++	fwts_framework *fw,
++	char *name,
++	ACPI_BUFFER *buf,
++	ACPI_OBJECT *obj,
++	void *private)
++{
++	FWTS_UNUSED(private);
++
++	if (method_check_type(fw, name, buf, ACPI_TYPE_INTEGER) != FWTS_OK)
++		return;
++
++	if (obj->Integer.Value & ~0x1)
++		fwts_failed(fw, LOG_LEVEL_MEDIUM,
++			"Method_SRTReturn",
++			"%s returned %" PRId64 ", should be between 0 and 1, "
++			"one or more of the reserved bits 1..31 seem "
++			"to be set.",
++			name, (uint64_t)obj->Integer.Value);
++	else
++		method_passed_sane_uint64(fw, name, obj->Integer.Value);
++}
++
++static int method_test_SRT(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_OPTIONAL,
++		"_SRT", NULL, 0, method_test_SRT_return, NULL);
++}
++
++static int method_test_STP(fwts_framework *fw)
++{
++	ACPI_OBJECT arg[2];
++
++	arg[0].Type = ACPI_TYPE_INTEGER;
++	arg[0].Integer.Value = 1;	/* DC timer */
++	arg[1].Type = ACPI_TYPE_INTEGER;
++	arg[1].Integer.Value = 0;	/* wake up instantly */
++
++	return method_evaluate_method(fw, METHOD_OPTIONAL,
++		"_STP", arg, 2, method_test_passed_failed_return, "_STP");
++}
++
++static int method_test_STV(fwts_framework *fw)
++{
++	ACPI_OBJECT arg[2];
++
++	arg[0].Type = ACPI_TYPE_INTEGER;
++	arg[0].Integer.Value = 1;	/* DC timer */
++	arg[1].Type = ACPI_TYPE_INTEGER;
++	arg[1].Integer.Value = 100;	/* timer value */
++
++	return method_evaluate_method(fw, METHOD_OPTIONAL,
++		"_STV", arg, 2, method_test_passed_failed_return, "_STV");
++}
++
++static int method_test_TIP(fwts_framework *fw)
++{
++	ACPI_OBJECT arg[1];
++
++	arg[0].Type = ACPI_TYPE_INTEGER;
++	arg[0].Integer.Value = 1;	/* DC timer */
++
++	return method_evaluate_method(fw, METHOD_OPTIONAL,
++		"_TIP", arg, 1, method_test_integer_return, NULL);
++}
++
++static int method_test_TIV(fwts_framework *fw)
++{
++	ACPI_OBJECT arg[1];
++
++	arg[0].Type = ACPI_TYPE_INTEGER;
++	arg[0].Integer.Value = 1;	/* DC timer */
++
++	return method_evaluate_method(fw, METHOD_OPTIONAL,
++		"_TIV", arg, 1, method_test_integer_return, NULL);
++}
++
++
++/*
++ * Section 10.1 Smart Battery
++ */
++static void method_test_SBS_return(
++	fwts_framework *fw,
++	char *name,
++	ACPI_BUFFER *buf,
++	ACPI_OBJECT *obj,
++	void *private)
++{
++	static char *sbs_info[] = {
++		"Maximum 1 Smart Battery, system manager/selector not present",
++		"Maximum 1 Smart Battery, system manager/selector present",
++		"Maximum 2 Smart Batteries, system manager/selector present",
++		"Maximum 3 Smart Batteries, system manager/selector present",
++		"Maximum 4 Smart Batteries, system manager/selector present"
++	};
++
++	FWTS_UNUSED(private);
++
++	if (method_check_type(fw, name, buf, ACPI_TYPE_INTEGER) != FWTS_OK)
++		return;
++
++	switch (obj->Integer.Value) {
++	case 0 ... 4:
++		fwts_passed(fw, "%s correctly returned value %" PRIu64 " %s",
++			name, (uint64_t)obj->Integer.Value,
++			sbs_info[obj->Integer.Value]);
++		break;
++	default:
++		fwts_failed(fw, LOG_LEVEL_MEDIUM, "Method_SBSReturn",
++			"%s returned %" PRIu64 ", should be between 0 and 4.",
++			name, (uint64_t)obj->Integer.Value);
++		fwts_advice(fw,
++			"Smart Battery %s is incorrectly informing "
++			"the OS about the smart battery "
++			"configuration. This is a bug and needs to be "
++			"fixed.", name);
++		break;
++	}
++}
++
++static int method_test_SBS(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_MOBILE,
++		"_SBS", NULL, 0, method_test_SBS_return, NULL);
++}
++
++
++/*
++ * Section 10.2 Battery Control Methods
++ */
++static int method_test_BCT(fwts_framework *fw)
++{
++	ACPI_OBJECT arg[1];
++	arg[0].Type = ACPI_TYPE_INTEGER;
++	arg[0].Integer.Value = 50;	/* 50% */
++
++	/*
++	 * For now, just check that we get some integer back, values
++	 * can be 0x00000000, 0x00000001-0xfffffffe and 0xffffffff,
++	 * so anything is valid as long as it is an integer
++	 */
++	return method_evaluate_method(fw, METHOD_MOBILE,
++		"_BCT", arg, 1, method_test_integer_return, NULL);
++}
++
++static void method_test_BIF_return(
++	fwts_framework *fw,
++	char *name,
++	ACPI_BUFFER *buf,
++	ACPI_OBJECT *obj,
++	void *private)
++{
++	bool failed = false;
++
++	static fwts_package_element elements[] = {
++		{ ACPI_TYPE_INTEGER,	"Power Unit" },
++		{ ACPI_TYPE_INTEGER,	"Design Capacity" },
++		{ ACPI_TYPE_INTEGER,	"Last Full Charge Capacity" },
++		{ ACPI_TYPE_INTEGER,	"Battery Technology" },
++		{ ACPI_TYPE_INTEGER,	"Design Voltage" },
++		{ ACPI_TYPE_INTEGER,	"Design Capacity of Warning" },
++		{ ACPI_TYPE_INTEGER,	"Design Capactty of Low" },
++		{ ACPI_TYPE_INTEGER,	"Battery Capacity Granularity 1" },
++		{ ACPI_TYPE_INTEGER,	"Battery Capacity Granularity 2" },
++		{ ACPI_TYPE_STRING,	"Model Number" },
++		{ ACPI_TYPE_STRING,	"Serial Number" },
++		{ ACPI_TYPE_STRING,	"Battery Type" },
++		{ ACPI_TYPE_STRING,	"OEM Information" }
++	};
++
++	FWTS_UNUSED(private);
++
++	if (method_check_type(fw, name, buf, ACPI_TYPE_PACKAGE) != FWTS_OK)
++		return;
++
++	if (method_package_count_equal(fw, name, "_BIF", obj, 13) != FWTS_OK)
++		return;
++
++	if (method_package_elements_type(fw, name, "_BIF", obj, elements, 13) != FWTS_OK)
++		return;
++
++	/* Sanity check each field */
++	/* Power Unit */
++	if (obj->Package.Elements[0].Integer.Value > 0x00000002) {
++		fwts_failed(fw, LOG_LEVEL_MEDIUM,
++			"Method_BIFBadUnits",
++			"%s: Expected Power Unit (Element 0) to be "
++			"0 (mWh) or 1 (mAh), got 0x%8.8" PRIx64 ".",
++			name, (uint64_t)obj->Package.Elements[0].Integer.Value);
++		failed = true;
++	}
++#ifdef FWTS_METHOD_PEDANDTIC
++	/*
++	 * Since this information may be evaluated by communicating with
++	 * the EC we skip these checks as we can't do this from userspace
++	 */
++	/* Design Capacity */
++	if (obj->Package.Elements[1].Integer.Value > 0x7fffffff) {
++		fwts_failed(fw, LOG_LEVEL_LOW,
++			"Method_BIFBadCapacity",
++			"%s: Design Capacity (Element 1) is "
++			"unknown: 0x%8.8" PRIx64 ".",
++			name, obj->Package.Elements[1].Integer.Value);
++		failed = true;
++	}
++	/* Last Full Charge Capacity */
++	if (obj->Package.Elements[2].Integer.Value > 0x7fffffff) {
++		fwts_failed(fw, LOG_LEVEL_LOW,
++			"Method_BIFChargeCapacity",
++			"%s: Last Full Charge Capacity (Element 2) "
++			"is unknown: 0x%8.8" PRIx64 ".",
++			name, obj->Package.Elements[2].Integer.Value);
++		failed = true;
++	}
++#endif
++	/* Battery Technology */
++	if (obj->Package.Elements[3].Integer.Value > 0x00000002) {
++		fwts_failed(fw, LOG_LEVEL_MEDIUM,
++			"Method_BIFBatTechUnit",
++			"%s: Expected Battery Technology Unit "
++			"(Element 3) to be 0 (Primary) or 1 "
++			"(Secondary), got 0x%8.8" PRIx64 ".",
++			name, (uint64_t)obj->Package.Elements[3].Integer.Value);
++		failed = true;
++	}
++#ifdef FWTS_METHOD_PEDANDTIC
++	/*
++ 	 * Since this information may be evaluated by communicating with
++	 * the EC we skip these checks as we can't do this from userspace
++	 */
++	/* Design Voltage */
++	if (obj->Package.Elements[4].Integer.Value > 0x7fffffff) {
++		fwts_failed(fw, LOG_LEVEL_LOW,
++			"Method_BIFDesignVoltage",
++			"%s: Design Voltage (Element 4) is "
++			"unknown: 0x%8.8" PRIx64 ".",
++			name, obj->Package.Elements[4].Integer.Value);
++		failed = true;
++	}
++	/* Design capacity warning */
++	if (obj->Package.Elements[5].Integer.Value > 0x7fffffff) {
++		fwts_failed(fw, LOG_LEVEL_LOW,
++			"Method_BIFDesignCapacityE5",
++			"%s: Design Capacity Warning (Element 5) "
++			"is unknown: 0x%8.8" PRIx64 ".",
++			name, obj->Package.Elements[5].Integer.Value);
++		failed = true;
++	}
++	/* Design capacity low */
++	if (obj->Package.Elements[6].Integer.Value > 0x7fffffff) {
++		fwts_failed(fw, LOG_LEVEL_LOW,
++			"Method_BIFDesignCapacityE6",
++			"%s: Design Capacity Warning (Element 6) "
++			"is unknown: 0x%8.8" PRIx64 ".",
++			name, obj->Package.Elements[6].Integer.Value);
++		failed = true;
++	}
++#endif
++	if (failed)
++		fwts_advice(fw,
++			"Battery %s package contains errors. It is "
++			"worth running the firmware test suite "
++			"interactive 'battery' test to see if this "
++			"is problematic.  This is a bug an needs to "
++			"be fixed.", name);
++	else
++		method_passed_sane(fw, name, "package");
++}
++
++static int method_test_BIF(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_MOBILE,
++		"_BIF", NULL, 0, method_test_BIF_return, NULL);
++}
++
++static void method_test_BIX_return(
++	fwts_framework *fw,
++	char *name,
++	ACPI_BUFFER *buf,
++	ACPI_OBJECT *obj,
++	void *private)
++{
++	bool failed = false;
++
++	static fwts_package_element elements[] = {
++		{ ACPI_TYPE_INTEGER,	"Revision" },
++		{ ACPI_TYPE_INTEGER,	"Power Unit" },
++		{ ACPI_TYPE_INTEGER,	"Design Capacity" },
++		{ ACPI_TYPE_INTEGER,	"Last Full Charge Capacity" },
++		{ ACPI_TYPE_INTEGER,	"Battery Technology" },
++		{ ACPI_TYPE_INTEGER,	"Design Voltage" },
++		{ ACPI_TYPE_INTEGER,	"Design Capacity of Warning" },
++		{ ACPI_TYPE_INTEGER,	"Design Capactty of Low" },
++		{ ACPI_TYPE_INTEGER,	"Cycle Count" },
++		{ ACPI_TYPE_INTEGER,	"Measurement Accuracy" },
++		{ ACPI_TYPE_INTEGER,	"Max Sampling Time" },
++		{ ACPI_TYPE_INTEGER,	"Min Sampling Time" },
++		{ ACPI_TYPE_INTEGER,	"Max Averaging Interval" },
++		{ ACPI_TYPE_INTEGER,	"Min Averaging Interval" },
++		{ ACPI_TYPE_INTEGER,	"Battery Capacity Granularity 1" },
++		{ ACPI_TYPE_INTEGER,	"Battery Capacity Granularity 2" },
++		{ ACPI_TYPE_STRING,	"Model Number" },
++		{ ACPI_TYPE_STRING,	"Serial Number" },
++		{ ACPI_TYPE_STRING,	"Battery Type" },
++		{ ACPI_TYPE_STRING,	"OEM Information" }
++	};
++
++	FWTS_UNUSED(private);
++
++	if (method_check_type(fw, name, buf, ACPI_TYPE_PACKAGE) != FWTS_OK)
++		return;
++
++	if (method_package_count_equal(fw, name, "_BIX", obj, 20) != FWTS_OK)
++		return;
++
++	if (method_package_elements_type(fw, name, "_BIX", obj, elements, 20) != FWTS_OK)
++		return;
++
++	/* Sanity check each field */
++	/* Power Unit */
++	if (obj->Package.Elements[1].Integer.Value > 0x00000002) {
++		fwts_failed(fw, LOG_LEVEL_MEDIUM,
++			"Method_BIXPowerUnit",
++			"%s: Expected %s (Element 1) to be "
++			"0 (mWh) or 1 (mAh), got 0x%8.8" PRIx64 ".",
++			name, elements[1].name,
++			(uint64_t)obj->Package.Elements[1].Integer.Value);
++		failed = true;
++	}
++#ifdef FWTS_METHOD_PEDANDTIC
++	/*
++	 * Since this information may be evaluated by communicating with
++	 * the EC we skip these checks as we can't do this from userspace
++ 	 */
++	/* Design Capacity */
++	if (obj->Package.Elements[2].Integer.Value > 0x7fffffff) {
++		fwts_failed(fw, LOG_LEVEL_LOW,
++			"Method_BIXDesignCapacity",
++			"%s: %s (Element 2) is "
++			"unknown: 0x%8.8" PRIx64 ".",
++			name, elements[2].name,
++			obj->Package.Elements[2].Integer.Value);
++		failed = true;
++	}
++	/* Last Full Charge Capacity */
++	if (obj->Package.Elements[3].Integer.Value > 0x7fffffff) {
++		fwts_failed(fw, LOG_LEVEL_LOW,
++			"Method_BIXFullChargeCapacity",
++			"%s: %s (Element 3) "
++			"is unknown: 0x%8.8" PRIx64 ".",
++			name, elements[3].name,
++			obj->Package.Elements[3].Integer.Value);
++		failed = true;
++	}
++#endif
++	/* Battery Technology */
++	if (obj->Package.Elements[4].Integer.Value > 0x00000002) {
++		fwts_failed(fw, LOG_LEVEL_MEDIUM,
++			"Method_BIXBatteryTechUnit",
++			"%s: %s "
++			"(Element 4) to be 0 (Primary) or 1 "
++			"(Secondary), got 0x%8.8" PRIx64 ".",
++			name, elements[4].name,
++			(uint64_t)obj->Package.Elements[4].Integer.Value);
++		failed = true;
++	}
++#ifdef FWTS_METHOD_PEDANDTIC
++	/*
++	 * Since this information may be evaluated by communicating with
++	 * the EC we skip these checks as we can't do this from userspace
++ 	 */
++	/* Design Voltage */
++	if (obj->Package.Elements[5].Integer.Value > 0x7fffffff) {
++		fwts_failed(fw, LOG_LEVEL_LOW,
++			"Method_BIXDesignVoltage",
++			"%s: %s (Element 5) is unknown: "
++			"0x%8.8" PRIx64 ".",
++			name, elements[5].name,
++			obj->Package.Elements[5].Integer.Value);
++		failed = true;
++	}
++	/* Design capacity warning */
++	if (obj->Package.Elements[6].Integer.Value > 0x7fffffff) {
++		fwts_failed(fw, LOG_LEVEL_LOW,
++			"Method_BIXDesignCapacityE6",
++			"%s: %s (Element 6) "
++			"is unknown: 0x%8.8" PRIx64 ".",
++			name, elements[6].name,
++			obj->Package.Elements[6].Integer.Value);
++		failed = true;
++	}
++	/* Design capacity low */
++	if (obj->Package.Elements[7].Integer.Value > 0x7fffffff) {
++		fwts_failed(fw, LOG_LEVEL_LOW,
++			"Method_BIXDesignCapacityE7",
++			"%s: %s (Element 7) "
++			"is unknown: 0x%8.8" PRIx64 ".",
++			name, elements[7].name,
++			obj->Package.Elements[7].Integer.Value);
++		failed = true;
++	}
++	/* Cycle Count */
++	if (obj->Package.Elements[8].Integer.Value > 0x7fffffff) {
++		fwts_failed(fw, LOG_LEVEL_LOW, "Method_BIXCyleCount",
++			"%s: %s (Element 8) is unknown: "
++			"0x%8.8" PRIx64 ".", Elements[8].name,
++			name, obj->Package.Elements[8].Integer.Value);
++		failed = true;
++	}
++#endif
++	if (failed)
++		fwts_advice(fw,
++			"Battery %s package contains errors. It is "
++			"worth running the firmware test suite "
++			"interactive 'battery' test to see if this "
++			"is problematic.  This is a bug an needs to "
++			"be fixed.", name);
++	else
++		method_passed_sane(fw, name, "package");
++}
++
++static int method_test_BIX(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_MOBILE,
++		"_BIX", NULL, 0, method_test_BIX_return, NULL);
++}
++
++static int method_test_BMA(fwts_framework *fw)
++{
++	ACPI_OBJECT arg[1];
++	arg[0].Type = ACPI_TYPE_INTEGER;
++	arg[0].Integer.Value = 1;
++
++	return method_evaluate_method(fw, METHOD_MOBILE,
++		"_BMA", arg, 1, method_test_integer_return, NULL);
++}
++
++static int method_test_BMS(fwts_framework *fw)
++{
++	ACPI_OBJECT arg[1];
++	arg[0].Type = ACPI_TYPE_INTEGER;
++	arg[0].Integer.Value = 1;
++
++	return method_evaluate_method(fw, METHOD_MOBILE,
++		"_BMS", arg, 1, method_test_integer_return, NULL);
++}
++
++static void method_test_BST_return(
++	fwts_framework *fw,
++	char *name,
++	ACPI_BUFFER *buf,
++	ACPI_OBJECT *obj,
++	void *private)
++{
++	bool failed = false;
++
++	FWTS_UNUSED(private);
++
++	if (method_check_type(fw, name, buf, ACPI_TYPE_PACKAGE) != FWTS_OK)
++		return;
++
++	if (method_package_count_equal(fw, name, "_BST", obj, 4) != FWTS_OK)
++		return;
++
++	if (method_package_elements_all_type(fw, name, "_BST", obj, ACPI_TYPE_INTEGER) != FWTS_OK)
++		return;
++
++	/* Sanity check each field */
++	/* Battery State */
++	if ((obj->Package.Elements[0].Integer.Value) > 7) {
++		fwts_failed(fw, LOG_LEVEL_MEDIUM,
++			"Method_BSTBadState",
++			"%s: Expected Battery State (Element 0) to "
++			"be 0..7, got 0x%8.8" PRIx64 ".",
++			name, (uint64_t)obj->Package.Elements[0].Integer.Value);
++		failed = true;
++	}
++	/* Ensure bits 0 (discharging) and 1 (charging) are not both set, see 10.2.2.6 */
++	if (((obj->Package.Elements[0].Integer.Value) & 3) == 3) {
++		fwts_failed(fw, LOG_LEVEL_MEDIUM,
++			"Method_BSTBadState",
++			"%s: Battery State (Element 0) is "
++			"indicating both charging and discharginng "
++			"which is not allowed. Got value 0x%8.8" PRIx64 ".",
++			name, (uint64_t)obj->Package.Elements[0].Integer.Value);
++		failed = true;
++	}
++	/* Battery Present Rate - cannot check, pulled from EC */
++	/* Battery Remaining Capacity - cannot check, pulled from EC */
++	/* Battery Present Voltage - cannot check, pulled from EC */
++	if (failed)
++		fwts_advice(fw,
++			"Battery %s package contains errors. It is "
++			"worth running the firmware test suite "
++			"interactive 'battery' test to see if this "
++			"is problematic.  This is a bug an needs to "
++			"be fixed.", name);
++		else
++			method_passed_sane(fw, name, "package");
++}
++
++static int method_test_BST(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_MOBILE,
++		"_BST", NULL, 0, method_test_BST_return, NULL);
++}
++
++static int method_test_BTP(fwts_framework *fw)
++{
++	static int values[] = { 0, 1, 100, 200, 0x7fffffff };
++	int i;
++
++	for (i = 0; i < 5; i++) {
++		ACPI_OBJECT arg[1];
++		arg[0].Type = ACPI_TYPE_INTEGER;
++		arg[0].Integer.Value = values[i];
++		if (method_evaluate_method(fw, METHOD_MOBILE, "_BTP", arg, 1,
++			method_test_NULL_return, NULL) == FWTS_NOT_EXIST)
++			break;
++		fwts_log_nl(fw);
++	}
++	return FWTS_OK;
++}
++
++static void method_test_PCL_return(fwts_framework *fw,
++	char *name,
++	ACPI_BUFFER *buf,
++	ACPI_OBJECT *obj,
++	void *private)
++{
++	FWTS_UNUSED(fw);
++	FWTS_UNUSED(name);
++	FWTS_UNUSED(buf);
++	FWTS_UNUSED(obj);
++	FWTS_UNUSED(private);
++
++	if (method_check_type(fw, name, buf, ACPI_TYPE_PACKAGE) != FWTS_OK)
++		return;
++
++	if (method_package_elements_all_type(fw, name, "_PCL", obj, ACPI_TYPE_LOCAL_REFERENCE) != FWTS_OK)
++		return;
++
++	fwts_passed(fw,	"%s returned a sane package of %" PRIu32 " references.", name, obj->Package.Count);
++}
++
++static int method_test_PCL(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_MOBILE,
++		"_PCL", NULL, 0, method_test_PCL_return, "_PCL");
++}
++
++static int method_test_BTH(fwts_framework *fw)
++{
++	ACPI_OBJECT arg[1];
++	int i, ret;
++	arg[0].Type = ACPI_TYPE_INTEGER;
++
++	for (i = 0; i <= 100; i++) {
++		arg[0].Integer.Value = i;
++		ret = method_evaluate_method(fw, METHOD_OPTIONAL,
++			"_BTH", arg, 1, method_test_NULL_return, NULL);
++
++		if (ret != FWTS_OK)
++			break;
++	}
++	return ret;
++}
++
++static int method_test_BTM(fwts_framework *fw)
++{
++	static int values[] = { 0, 1, 100, 200, 0x7fffffff };
++	int i;
++
++	for (i = 0 ; i < 5; i++) {
++		ACPI_OBJECT arg[1];
++		arg[0].Type = ACPI_TYPE_INTEGER;
++		arg[0].Integer.Value = values[i];
++		if (method_evaluate_method(fw, METHOD_MOBILE, "_BTM", arg, 1,
++			method_test_NULL_return, NULL) == FWTS_NOT_EXIST)
++			break;
++		fwts_log_nl(fw);
++	}
++	return FWTS_OK;
++}
++
++static void method_test_BMD_return(
++	fwts_framework *fw,
++	char *name,
++	ACPI_BUFFER *buf,
++	ACPI_OBJECT *obj,
++	void *private)
++{
++	FWTS_UNUSED(private);
++
++	if (method_check_type(fw, name, buf, ACPI_TYPE_PACKAGE) != FWTS_OK)
++		return;
++
++	if (method_package_count_equal(fw, name, "_BMD", obj, 5) != FWTS_OK)
++		return;
++
++	if (method_package_elements_all_type(fw, name, "_BMD", obj, ACPI_TYPE_INTEGER) != FWTS_OK)
++		return;
++
++	fwts_acpi_object_dump(fw, obj);
++
++	method_passed_sane(fw, name, "package");
++}
++
++static int method_test_BMD(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_MOBILE,
++		"_BMD", NULL, 0, method_test_BMD_return, NULL);
++}
++
++static int method_test_BMC(fwts_framework *fw)
++{
++	static int values[] = { 0, 1, 2, 4 };
++	int i;
++
++	for (i = 0; i < 4; i++) {
++		ACPI_OBJECT arg[1];
++		arg[0].Type = ACPI_TYPE_INTEGER;
++		arg[0].Integer.Value = values[i];
++		if (method_evaluate_method(fw, METHOD_MOBILE, "_BMC", arg, 1,
++			method_test_NULL_return, NULL) == FWTS_NOT_EXIST)
++			break;
++		fwts_log_nl(fw);
++	}
++	return FWTS_OK;
++}
++
++
++/*
++ * Section 10.3 AC Adapters and Power Sources Objects
++ */
++static void method_test_PRL_return(
++	fwts_framework *fw,
++	char *name,
++	ACPI_BUFFER *buf,
++	ACPI_OBJECT *obj,
++	void *private)
++{
++	FWTS_UNUSED(private);
++
++	if (method_check_type(fw, name, buf, ACPI_TYPE_PACKAGE) != FWTS_OK)
++		return;
++
++	if (method_package_elements_all_type(fw, name, "_PRL", obj, ACPI_TYPE_LOCAL_REFERENCE) != FWTS_OK)
++		return;
++
++	method_passed_sane(fw, name, "package");
++}
++
++static int method_test_PRL(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_OPTIONAL,
++		"_PRL", NULL, 0, method_test_PRL_return, NULL);
++}
++
++static void method_test_PSR_return(
++	fwts_framework *fw,
++	char *name,
++	ACPI_BUFFER *buf,
++	ACPI_OBJECT *obj,
++	void *private)
++{
++	FWTS_UNUSED(private);
++
++	if (method_check_type(fw, name, buf, ACPI_TYPE_INTEGER) != FWTS_OK)
++		return;
++
++	if (obj->Integer.Value > 2) {
++		fwts_failed(fw, LOG_LEVEL_MEDIUM,
++			"Method_PSRZeroOrOne",
++			"%s returned 0x%8.8" PRIx64 ", expected 0 "
++			"(offline) or 1 (online)",
++			name, (uint64_t)obj->Integer.Value);
++	} else
++		method_passed_sane_uint64(fw, name, obj->Integer.Value);
++}
++
++static int method_test_PSR(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_OPTIONAL,
++		"_PSR", NULL, 0, method_test_PSR_return, NULL);
++}
++
++static void method_test_PIF_return(
++	fwts_framework *fw,
++	char *name,
++	ACPI_BUFFER *buf,
++	ACPI_OBJECT *obj,
++	void *private)
++{
++	static fwts_package_element elements[] = {
++		{ ACPI_TYPE_INTEGER,	"Power Source State" },
++		{ ACPI_TYPE_INTEGER,	"Maximum Output Power" },
++		{ ACPI_TYPE_INTEGER,	"Maximum Input Power" },
++		{ ACPI_TYPE_STRING,	"Model Number" },
++		{ ACPI_TYPE_STRING,	"Serial Number" },
++		{ ACPI_TYPE_STRING,	"OEM Information" }
++	};
++
++	FWTS_UNUSED(private);
++
++	if (method_check_type(fw, name, buf, ACPI_TYPE_PACKAGE) != FWTS_OK)
++		return;
++
++	if (method_package_count_equal(fw, name, "_PIF", obj, 6) != FWTS_OK)
++		return;
++
++	if (method_package_elements_type(fw, name, "_PIF", obj, elements, 6) != FWTS_OK)
++		return;
++
++	fwts_acpi_object_dump(fw, obj);
++
++	method_passed_sane(fw, name, "package");
++}
++
++static int method_test_PIF(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_OPTIONAL,
++		"_PIF", NULL, 0, method_test_PIF_return, NULL);
++}
++
++/*
++ * Section 10.4 Power Meters
++ */
++
++static int method_test_GAI(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_OPTIONAL,
++		"_GAI", NULL, 0, method_test_integer_return, NULL);
++}
++
++static int method_test_GHL(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_OPTIONAL,
++		"_GHL", NULL, 0, method_test_integer_return, NULL);
++}
++
++static void method_test_PMC_return(
++	fwts_framework *fw,
++	char *name,
++	ACPI_BUFFER *buf,
++	ACPI_OBJECT *obj,
++	void *private)
++{
++	uint32_t i;
++	bool failed = false;
++	ACPI_OBJECT *element;
++
++	FWTS_UNUSED(private);
++
++	if (method_check_type(fw, name, buf, ACPI_TYPE_PACKAGE) != FWTS_OK)
++		return;
++
++	if (method_package_count_equal(fw, name, "_PMC", obj, 14) != FWTS_OK)
++		return;
++
++	/* check element types */
++	for (i = 0; i < 14; i++) {
++		element = &obj->Package.Elements[i];
++		if (i > 10) {
++			if (element->Type != ACPI_TYPE_STRING) {
++				fwts_failed(fw, LOG_LEVEL_MEDIUM,
++					"Method_PMCBadElementType",
++					"%s element %" PRIu32 " is not a string.", name, i);
++				failed = true;
++			}
++		} else {
++				if (element->Type != ACPI_TYPE_INTEGER) {
++					fwts_failed(fw, LOG_LEVEL_MEDIUM,
++						"Method_PMCBadElementType",
++						"%s element %" PRIu32 " is not an integer.", name, i);
++					failed = true;
++				}
++		}
++	}
++
++	/* check element's constraints */
++	element = &obj->Package.Elements[0];
++	if (element->Integer.Value & 0xFFFFFEF0) {
++		fwts_failed(fw, LOG_LEVEL_MEDIUM,
++			"Method_PMCBadElement",
++			"%s element 0 has reserved bits that are non-zero, got "
++			"0x%" PRIx32 " and expected 0 for these field. ", name,
++			(uint32_t) element->Integer.Value);
++		failed = true;
++	}
++
++	element = &obj->Package.Elements[1];
++	if (element->Integer.Value != 0) {
++		fwts_failed(fw, LOG_LEVEL_MEDIUM,
++			"Method_PMCBadElement",
++			"%s element 1 is expected to be 0, got 0x%" PRIx32 ".",
++			name, (uint32_t) element->Integer.Value);
++		failed = true;
++	}
++
++	element = &obj->Package.Elements[2];
++	if (element->Integer.Value != 0 && element->Integer.Value != 1) {
++		fwts_failed(fw, LOG_LEVEL_MEDIUM,
++			"Method_PMCBadElement",
++			"%s element 2 is expected to be 0 or 1, got 0x%" PRIx32 ".",
++			name, (uint32_t) element->Integer.Value);
++		failed = true;
++	}
++
++	element = &obj->Package.Elements[3];
++	if (element->Integer.Value > 100000) {
++		fwts_failed(fw, LOG_LEVEL_MEDIUM,
++			"Method_PMCBadElement",
++			"%s element 3 exceeds 100000 (100 percent) = 0x%" PRIx32 ".",
++			name, (uint32_t) element->Integer.Value);
++		failed = true;
++	}
++
++	/* nothing to check for elements 4~7 */
++
++	element = &obj->Package.Elements[8];
++	if (element->Integer.Value != 0 && element->Integer.Value != 0xFFFFFFFF) {
++		fwts_failed(fw, LOG_LEVEL_MEDIUM,
++			"Method_PMCBadElement",
++			"%s element 8 is expected to be 0 or 1, got 0x%" PRIx32 ".",
++			name, (uint32_t) element->Integer.Value);
++		failed = true;
++	}
++
++	/* nothing to check for elements 9~13 */
++
++	if (!failed)
++		method_passed_sane(fw, name, "package");
++}
++
++static int method_test_PMC(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_OPTIONAL,
++		"_PMC", NULL, 0, method_test_PMC_return, NULL);
++}
++
++static void method_test_PMD_return(
++	fwts_framework *fw,
++	char *name,
++	ACPI_BUFFER *buf,
++	ACPI_OBJECT *obj,
++	void *private)
++{
++	FWTS_UNUSED(private);
++
++	if (method_check_type(fw, name, buf, ACPI_TYPE_PACKAGE) != FWTS_OK)
++		return;
++
++	if (method_package_elements_all_type(fw, name, "_PMD", obj, ACPI_TYPE_LOCAL_REFERENCE) != FWTS_OK)
++		return;
++
++	method_passed_sane(fw, name, "package");
++}
++
++static int method_test_PMD(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_OPTIONAL,
++		"_PMD", NULL, 0, method_test_PMD_return, NULL);
++}
++
++static int method_test_PMM(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_OPTIONAL,
++		"_PMM", NULL, 0, method_test_integer_return, NULL);
++}
++
++/*
++ * Section 10.5 Wireless Power Controllers
++ */
++static void method_test_WPC_return(
++	fwts_framework *fw,
++	char *name,
++	ACPI_BUFFER *buf,
++	ACPI_OBJECT *obj,
++	void *private)
++{
++	FWTS_UNUSED(private);
++
++	if (method_check_type(fw, name, buf, ACPI_TYPE_INTEGER) != FWTS_OK)
++		return;
++
++	if (obj->Integer.Value <= 0x02 || obj->Integer.Value == 0xff)
++		method_passed_sane(fw, name, "integer");
++	else
++		fwts_failed(fw, LOG_LEVEL_HIGH,
++			"Method_WPCInvalidInteger",
++			"%s returned an invalid integer 0x%8.8" PRIx64,
++			name, (uint64_t)obj->Integer.Value);
++}
++
++static int method_test_WPC(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_OPTIONAL,
++		"_WPC", NULL, 0, method_test_WPC_return, "_WPC");
++}
++
++static int method_test_WPP(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_OPTIONAL,
++		"_WPP", NULL, 0, method_test_integer_return, NULL);
++}
++
++/*
++ * Section 11.3 Fan Devices
++ */
++static void method_test_FIF_return(
++	fwts_framework *fw,
++	char *name,
++	ACPI_BUFFER *buf,
++	ACPI_OBJECT *obj,
++	void *private)
++{
++	FWTS_UNUSED(private);
++
++	if (method_check_type(fw, name, buf, ACPI_TYPE_PACKAGE) != FWTS_OK)
++		return;
++
++	if (method_package_count_equal(fw, name, "_FIF", obj, 4) != FWTS_OK)
++		return;
++
++	if (method_package_elements_all_type(fw, name, "_FIF",
++		obj, ACPI_TYPE_INTEGER) != FWTS_OK) {
++		fwts_advice(fw,
++			"%s is not returning the correct "
++			"fan information. It may be worth "
++			"running the firmware test suite "
++			"interactive 'fan' test to see if "
++			"this affects the control and "
++			"operation of the fan.", name);
++		return;
++	}
++
++	fwts_acpi_object_dump(fw, obj);
++
++	method_passed_sane(fw, name, "package");
++}
++
++static int method_test_FIF(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_OPTIONAL,
++		"_FIF", NULL, 0, method_test_FIF_return, NULL);
++}
++
++static void method_test_FPS_return(
++	fwts_framework *fw,
++	char *name,
++	ACPI_BUFFER *buf,
++	ACPI_OBJECT *obj,
++	void *private)
++{
++	uint32_t i;
++	bool failed = false;
++
++	FWTS_UNUSED(private);
++
++	if (method_check_type(fw, name, buf, ACPI_TYPE_PACKAGE) != FWTS_OK)
++		return;
++
++	if (obj->Package.Elements[0].Type == ACPI_TYPE_INTEGER) {
++		if (obj->Package.Elements[0].Integer.Value != 0) {
++			fwts_failed(fw, LOG_LEVEL_MEDIUM,
++				"Method_FPSBadRevision",
++				"%s element 0 is not revision 0.", name);
++			failed = true;
++		}
++	} else {
++		fwts_failed(fw, LOG_LEVEL_MEDIUM,
++			"Method_FPSBadReturnType",
++			"%s element 0 is not an integer.", name);
++		failed = true;
++	}
++
++	/* Could be one or more sub-packages */
++	for (i = 1; i < obj->Package.Count; i++) {
++		ACPI_OBJECT *pkg;
++		uint32_t j;
++		bool elements_ok = true;
++
++		if (obj->Package.Elements[i].Type != ACPI_TYPE_PACKAGE) {
++			fwts_failed(fw, LOG_LEVEL_MEDIUM,
++				"Method_FPSBadReturnType",
++				"%s element %" PRIu32 " is not a package.",
++				name, i);
++			failed = true;
++			continue;
++		}
++
++		pkg = &obj->Package.Elements[i];
++		if (pkg->Package.Count != 5) {
++			fwts_failed(fw, LOG_LEVEL_MEDIUM,
++				"Method_FPSBadSubPackageElementCount",
++				"%s sub-package %" PRIu32 " was expected to "
++				"have 5 elements, got %" PRIu32 " elements instead.",
++				name, i, pkg->Package.Count);
++			failed = true;
++			continue;
++		}
++
++		for (j = 0; j < 5; j++) {
++			/* TODO - field 0 and 1 can be related to other control method */
++			if (pkg->Package.Elements[j].Type != ACPI_TYPE_INTEGER) {
++				fwts_failed(fw, LOG_LEVEL_MEDIUM,
++					"Method_FPSBadSubPackageReturnType",
++					"%s sub-package %" PRIu32
++					" element %" PRIu32 " is not "
++					"an integer.",
++					name, i, j);
++				elements_ok = false;
++			}
++		}
++
++		if (!elements_ok) {
++			failed = true;
++			continue;
++		}
++	}
++
++	if (!failed)
++		method_passed_sane(fw, name, "package");
++
++	method_passed_sane(fw, name, "package");
++}
++
++static int method_test_FPS(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_OPTIONAL,
++		"_FPS", NULL, 0, method_test_FPS_return, NULL);
++}
++
++static int method_test_FSL(fwts_framework *fw)
++{
++	ACPI_OBJECT arg[1];
++	arg[0].Type = ACPI_TYPE_INTEGER;
++	arg[0].Integer.Value = 50;
++
++	return method_evaluate_method(fw, METHOD_OPTIONAL,
++		"_FSL", arg, 1, method_test_NULL_return, NULL);
++}
++
++static void method_test_FST_return(
++	fwts_framework *fw,
++	char *name,
++	ACPI_BUFFER *buf,
++	ACPI_OBJECT *obj,
++	void *private)
++{
++	FWTS_UNUSED(private);
++
++	if (method_check_type(fw, name, buf, ACPI_TYPE_PACKAGE) != FWTS_OK)
++		return;
++
++	if (method_package_count_equal(fw, name, "_FST", obj, 3) != FWTS_OK)
++		return;
++
++	if (method_package_elements_all_type(fw, name, "_FST",
++		obj, ACPI_TYPE_INTEGER) != FWTS_OK) {
++		fwts_advice(fw,
++			"%s is not returning the correct "
++			"fan status information. It may be "
++			"worth running the firmware test "
++			"suite interactive 'fan' test to see "
++			"if this affects the control and "
++			"operation of the fan.", name);
++		return;
++	}
++
++	fwts_acpi_object_dump(fw, obj);
++
++	method_passed_sane(fw, name, "package");
++}
++
++static int method_test_FST(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_OPTIONAL,
++		"_FST", NULL, 0, method_test_FST_return, NULL);
++}
++
++
++/*
++ * Section 11.4 Thermal
++ */
++static void method_test_THERM_return(
++	fwts_framework *fw,
++	char *name,
++	ACPI_BUFFER *buf,
++	ACPI_OBJECT *obj,
++	void *private)
++{
++	char *method = (char*)private;
++
++	if (method_check_type(fw, name, buf, ACPI_TYPE_INTEGER) != FWTS_OK)
++		return;
++
++	if (fwts_acpi_region_handler_called_get()) {
++		/*
++		 *  We accessed some memory or I/O region during the
++		 *  evaluation which returns spoofed values, so we
++		 *  should not test the value being returned. In this
++		 *  case, just pass this as a valid return type.
++		 */
++		method_passed_sane(fw, name, "return type");
++	} else {
++		/*
++		 *  The evaluation probably was a hard-coded value,
++		 *  so sanity check it
++		 */
++		if (obj->Integer.Value >= 2732) {
++			fwts_passed(fw,
++				"%s correctly returned sane looking "
++				"value 0x%8.8" PRIx64 " (%5.1f degrees K)",
++				method,
++				(uint64_t)obj->Integer.Value,
++				(float)((uint64_t)obj->Integer.Value) / 10.0);
++		} else {
++			fwts_failed(fw, LOG_LEVEL_MEDIUM,
++				"MethodBadTemp",
++				"%s returned a dubious value below "
++				"0 degrees C: 0x%8.8" PRIx64 " (%5.1f "
++				"degrees K)",
++				method,
++				(uint64_t)obj->Integer.Value,
++				(float)((uint64_t)obj->Integer.Value) / 10.0);
++			fwts_advice(fw,
++				"The value returned was probably a "
++				"hard-coded thermal value which is "
++				"out of range because fwts did not "
++				"detect any ACPI region handler "
++				"accesses of I/O or system memeory "
++				"to evaluate the thermal value. "
++				"It is worth sanity checking these "
++				"values in "
++				"/sys/class/thermal/thermal_zone*.");
++		}
++	}
++}
++
++#define method_test_THERM(name, type)			\
++static int method_test ## name(fwts_framework *fw)	\
++{							\
++	fwts_acpi_region_handler_called_set(false);	\
++	return method_evaluate_method(fw, type, # name, \
++		NULL, 0, method_test_THERM_return, # name);	\
++}
++
++method_test_THERM(_CRT, METHOD_OPTIONAL)
++method_test_THERM(_CR3, METHOD_OPTIONAL)
++method_test_THERM(_HOT, METHOD_OPTIONAL)
++method_test_THERM(_TMP, METHOD_OPTIONAL)
++method_test_THERM(_NTT, METHOD_OPTIONAL)
++method_test_THERM(_PSV, METHOD_OPTIONAL)
++method_test_THERM(_TST, METHOD_OPTIONAL)
++
++static void method_test_MTL_return(
++	fwts_framework *fw,
++	char *name,
++	ACPI_BUFFER *buf,
++	ACPI_OBJECT *obj,
++	void *private)
++{
++	uint64_t val;
++	bool failed = false;
++
++	FWTS_UNUSED(private);
++
++	if (method_check_type(fw, name, buf, ACPI_TYPE_INTEGER) != FWTS_OK)
++		return;
++
++	val = (uint64_t) obj->Integer.Value;
++	if (val > 100) {
++		failed = true;
++		fwts_failed(fw, LOG_LEVEL_MEDIUM,
++			"Method_MTLBadReturnType",
++			"%s should return a percentage, got %" PRIu64 " instead", name, val);
++	}
++
++	if (!failed)
++		method_passed_sane_uint64(fw, name, obj->Integer.Value);
++
++	return;
++}
++
++static int method_test_MTL(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_OPTIONAL,
++		"_MTL", NULL, 0, method_test_MTL_return, NULL);
++}
++
++static void method_test_ART_return(
++	fwts_framework *fw,
++	char *name,
++	ACPI_BUFFER *buf,
++	ACPI_OBJECT *obj,
++	void *private)
++{
++	uint32_t i;
++	bool failed = false;
++
++	FWTS_UNUSED(private);
++
++	if (method_check_type(fw, name, buf, ACPI_TYPE_PACKAGE) != FWTS_OK)
++		return;
++
++	if (obj->Package.Elements[0].Type == ACPI_TYPE_INTEGER) {
++		if (obj->Package.Elements[0].Integer.Value != 0) {
++			fwts_failed(fw, LOG_LEVEL_MEDIUM,
++				"Method_ARTBadRevision",
++				"%s element 0 is not revision 0.", name);
++			failed = true;
++		}
++	} else {
++		fwts_failed(fw, LOG_LEVEL_MEDIUM,
++			"Method_ARTBadReturnType",
++			"%s element 0 is not an integer.", name);
++		failed = true;
++	}
++
++	/* Could be one or more sub-packages */
++	for (i = 1; i < obj->Package.Count; i++) {
++		ACPI_OBJECT *pkg;
++		uint32_t j;
++		bool elements_ok = true;
++
++		if (obj->Package.Elements[i].Type != ACPI_TYPE_PACKAGE) {
++			fwts_failed(fw, LOG_LEVEL_MEDIUM,
++				"Method_ARTBadReturnType",
++				"%s element %" PRIu32 " is not a package.",
++				name, i);
++			failed = true;
++			continue;
++		}
++
++		pkg = &obj->Package.Elements[i];
++		if (pkg->Package.Count != 13) {
++			fwts_failed(fw, LOG_LEVEL_MEDIUM,
++				"Method_ARTBadSubPackageElementCount",
++				"%s sub-package %" PRIu32 " was expected to "
++				"have 13 elements, got %" PRIu32 " elements instead.",
++				name, i, pkg->Package.Count);
++			failed = true;
++			continue;
++		}
++
++		/* First two elements are references, and rests are integers */
++		for (j = 0; j < 2; j++) {
++			if (pkg->Package.Elements[j].Type != ACPI_TYPE_LOCAL_REFERENCE) {
++				fwts_failed(fw, LOG_LEVEL_MEDIUM,
++					"Method_ARTBadSubPackageReturnType",
++					"%s sub-package %" PRIu32
++					" element %" PRIu32 " is not "
++					"a reference.",
++					name, i, j);
++				elements_ok = false;
++			}
++		}
++
++		for (j = 2; j < 13; j++) {
++			if (pkg->Package.Elements[j].Type != ACPI_TYPE_INTEGER) {
++				fwts_failed(fw, LOG_LEVEL_MEDIUM,
++					"Method_ARTBadSubPackageReturnType",
++					"%s sub-package %" PRIu32
++					" element %" PRIu32 " is not "
++					"an integer.",
++					name, i, j);
++				elements_ok = false;
++			}
++		}
++
++		if (!elements_ok) {
++			failed = true;
++			continue;
++		}
++	}
++
++	if (!failed)
++		method_passed_sane(fw, name, "package");
++}
++
++static int method_test_ART(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_OPTIONAL,
++		"_ART", NULL, 0, method_test_ART_return, "_ART");
++}
++
++static void method_test_PSL_return(
++	fwts_framework *fw,
++	char *name,
++	ACPI_BUFFER *buf,
++	ACPI_OBJECT *obj,
++	void *private)
++{
++	FWTS_UNUSED(private);
++
++	if (method_check_type(fw, name, buf, ACPI_TYPE_PACKAGE) != FWTS_OK)
++		return;
++
++	if (method_package_elements_all_type(fw, name, "_PSL", obj, ACPI_TYPE_LOCAL_REFERENCE) != FWTS_OK)
++		return;
++
++	method_passed_sane(fw, name, "package");
++}
++
++static int method_test_PSL(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_OPTIONAL,
++		"_PSL", NULL, 0, method_test_PSL_return, "_PSL");
++}
++
++static void method_test_TRT_return(
++	fwts_framework *fw,
++	char *name,
++	ACPI_BUFFER *buf,
++	ACPI_OBJECT *obj,
++	void *private)
++{
++	uint32_t i;
++	bool failed = false;
++
++	FWTS_UNUSED(private);
++
++	if (method_check_type(fw, name, buf, ACPI_TYPE_PACKAGE) != FWTS_OK)
++		return;
++
++	if (method_package_elements_all_type(fw, name, "_TRT", obj, ACPI_TYPE_PACKAGE) != FWTS_OK)
++		return;
++
++	/* Could be one or more packages */
++	for (i = 0; i < obj->Package.Count; i++) {
++		ACPI_OBJECT *pkg;
++		uint32_t j;
++		bool elements_ok = true;
++
++		pkg = &obj->Package.Elements[i];
++		if (pkg->Package.Count != 8) {
++			fwts_failed(fw, LOG_LEVEL_MEDIUM,
++				"Method_TRTSubPackageElementCount",
++				"%s sub-package %" PRIu32 " was expected to "
++				"have 8 elements, got %" PRIu32 " elements instead.",
++				name, i, pkg->Package.Count);
++			failed = true;
++			continue;
++		}
++
++		/* First two elements are references, and rests are integers */
++		for (j = 0; j < 2; j++) {
++			if (pkg->Package.Elements[j].Type != ACPI_TYPE_LOCAL_REFERENCE) {
++				fwts_failed(fw, LOG_LEVEL_MEDIUM,
++					"Method_TRTBadSubPackageReturnType",
++					"%s sub-package %" PRIu32
++					" element %" PRIu32 " is not "
++					"a reference.",
++					name, i, j);
++				elements_ok = false;
++			}
++		}
++
++		for (j = 2; j < 8; j++) {
++			if (pkg->Package.Elements[j].Type != ACPI_TYPE_INTEGER) {
++				fwts_failed(fw, LOG_LEVEL_MEDIUM,
++					"Method_TRTBadSubPackageReturnType",
++					"%s sub-package %" PRIu32
++					" element %" PRIu32 " is not "
++					"an integer.",
++					name, i, j);
++				elements_ok = false;
++			}
++		}
++
++		if (!elements_ok) {
++			failed = true;
++			continue;
++		}
++	}
++
++	if (!failed)
++		method_passed_sane(fw, name, "package");
++}
++
++static int method_test_TRT(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_OPTIONAL,
++		"_TRT", NULL, 0, method_test_TRT_return, "_TRT");
++}
++
++static int method_test_TSN(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_OPTIONAL,
++		"_TSN", NULL, 0, method_test_reference_return, "_TSN");
++}
++
++static int method_test_TSP(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_OPTIONAL,
++		"_TSP", NULL, 0, method_test_polling_return, "_TSP");
++}
++
++static void method_test_TCx_return(
++	fwts_framework *fw,
++	char *name,
++	ACPI_BUFFER *buf,
++	ACPI_OBJECT *obj,
++	void *private)
++{
++	if (method_check_type(fw, name, buf, ACPI_TYPE_INTEGER) == FWTS_OK)
++		method_passed_sane_uint64(fw, (char*)private, obj->Integer.Value);
++}
++
++static int method_test_TC1(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_OPTIONAL,
++		"_TC1", NULL, 0, method_test_TCx_return, "_TC1");
++}
++
++static int method_test_TC2(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_OPTIONAL,
++		"_TC2", NULL, 0, method_test_TCx_return, "_TC1");
++}
++
++static int method_test_TFP(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_OPTIONAL,
++		"_TFP", NULL, 0, method_test_integer_return, NULL);
++}
++
++static int method_test_ACx(fwts_framework *fw)
++{
++	int i;
++
++	for (i = 0; i < 10; i++) {
++		char buffer[5];
++
++		snprintf(buffer, sizeof(buffer), "_AC%d", i);
++		method_evaluate_method(fw, METHOD_OPTIONAL,
++			buffer, NULL, 0, method_test_THERM_return, buffer);
++		fwts_log_nl(fw);
++	}
++	return FWTS_OK;
++}
++
++static int method_test_DTI(fwts_framework *fw)
++{
++	ACPI_OBJECT arg[1];
++	arg[0].Type = ACPI_TYPE_INTEGER;
++	arg[0].Integer.Value = 2732 + 800; /* 80 degrees C */
++
++	return method_evaluate_method(fw, METHOD_OPTIONAL,
++		"_DTI", arg, 1, method_test_NULL_return, NULL);
++}
++
++static int method_test_SCP(fwts_framework *fw)
++{
++	int i;
++
++	for (i = 0; i < 2; i++) {
++		ACPI_OBJECT arg[3];
++
++		arg[0].Type = ACPI_TYPE_INTEGER;
++		arg[0].Integer.Value = i;		/* Mode */
++		arg[1].Type = ACPI_TYPE_INTEGER;
++		arg[1].Integer.Value = 5;		/* Acoustic limit */
++		arg[2].Type = ACPI_TYPE_INTEGER;
++		arg[2].Integer.Value = 5;		/* Power limit */
++
++		if (method_evaluate_method(fw, METHOD_OPTIONAL,
++			"_DTI", arg, 1, method_test_NULL_return,
++			NULL) == FWTS_NOT_EXIST)
++			break;
++		fwts_log_nl(fw);
++
++		arg[0].Type = ACPI_TYPE_INTEGER;
++		arg[0].Integer.Value = i;		/* Mode */
++		arg[1].Type = ACPI_TYPE_INTEGER;
++		arg[1].Integer.Value = 1;		/* Acoustic limit */
++		arg[2].Type = ACPI_TYPE_INTEGER;
++		arg[2].Integer.Value = 1;		/* Power limit */
++
++		if (method_evaluate_method(fw, METHOD_OPTIONAL,
++			"_DTI", arg, 1, method_test_NULL_return,
++			NULL) == FWTS_NOT_EXIST)
++			break;
++	}
++	return FWTS_OK;
++}
++
++static void method_test_RTV_return(
++	fwts_framework *fw,
++	char *name,
++	ACPI_BUFFER *buf,
++	ACPI_OBJECT *obj,
++	void *private)
++{
++	FWTS_UNUSED(private);
++
++	if (method_check_type(fw, name, buf, ACPI_TYPE_INTEGER) == FWTS_OK)
++		method_passed_sane_uint64(fw, name, obj->Integer.Value);
++}
++
++static int method_test_RTV(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_OPTIONAL,
++		"_RTV", NULL, 0, method_test_RTV_return, "_RTV");
++}
++
++static int method_test_TPT(fwts_framework *fw)
++{
++	ACPI_OBJECT arg[1];
++	arg[0].Type = ACPI_TYPE_INTEGER;
++	arg[0].Integer.Value = 2732 + 900; /* 90 degrees C */
++
++	return method_evaluate_method(fw, METHOD_OPTIONAL,
++		"_TPT", arg, 1, method_test_NULL_return, NULL);
++}
++
++static void method_test_TZD_return(
++	fwts_framework *fw,
++	char *name,
++	ACPI_BUFFER *buf,
++	ACPI_OBJECT *obj,
++	void *private)
++{
++	FWTS_UNUSED(private);
++
++	if (method_check_type(fw, name, buf, ACPI_TYPE_PACKAGE) != FWTS_OK)
++		return;
++
++	if (method_package_elements_all_type(fw, name, "_TZD", obj, ACPI_TYPE_LOCAL_REFERENCE) != FWTS_OK)
++		return;
++
++	fwts_passed(fw,	"%s returned a sane package of %" PRIu32 " references.", name, obj->Package.Count);
++}
++
++static int method_test_TZD(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_OPTIONAL,
++		"_TZD", NULL, 0, method_test_TZD_return, "_TZD");
++}
++
++static int method_test_TZM(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_OPTIONAL,
++		"_TZM", NULL, 0, method_test_reference_return, "_TZM");
++}
++
++static int method_test_TZP(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_OPTIONAL,
++		"_TZP", NULL, 0, method_test_polling_return, "_TZP");
++}
++
++/*
++ * Section 12 Embedded Controller
++ */
++
++static void method_test_GPE_return(
++	fwts_framework *fw,
++	char *name,
++	ACPI_BUFFER *buf,
++	ACPI_OBJECT *obj,
++	void *private)
++{
++	FWTS_UNUSED(private);
++	FWTS_UNUSED(buf);
++	bool failed = false;
++
++	switch (obj->Type) {
++	case ACPI_TYPE_INTEGER:
++		if (obj->Integer.Value <= 255)
++			fwts_passed(fw, "%s returned an integer 0x%8.8" PRIx64,
++				name, (uint64_t)obj->Integer.Value);
++		else
++			fwts_failed(fw, LOG_LEVEL_HIGH,
++				"MethodGPEInvalidInteger",
++				"%s returned an invalid integer 0x%8.8" PRIx64,
++				name, (uint64_t)obj->Integer.Value);
++		break;
++	case ACPI_TYPE_PACKAGE:
++		if (obj->Package.Elements[0].Type != ACPI_TYPE_LOCAL_REFERENCE) {
++			failed = true;
++			fwts_failed(fw, LOG_LEVEL_HIGH, "Method_GPEBadSubPackageReturnType",
++			"%s sub-package element 0 is not a reference.",	name);
++		}
++
++		if (obj->Package.Elements[1].Type != ACPI_TYPE_INTEGER) {
++			failed = true;
++			fwts_failed(fw, LOG_LEVEL_HIGH, "Method_GPEBadSubPackageReturnType",
++			"%s sub-package element 1 is not an integer.", name);
++		}
++
++		if (!failed)
++			method_passed_sane(fw, name, "package");
++
++		break;
++	default:
++		fwts_failed(fw, LOG_LEVEL_HIGH, "Method_GPEBadSubReturnType",
++			"%s did not return an integer or a package.", name);
++		break;
++	}
++}
++
++static int method_test_GPE(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_OPTIONAL,
++		"_GPE", NULL, 0, method_test_GPE_return, "_GPE");
++}
++
++static int method_test_EC_(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_OPTIONAL,
++		"_EC_", NULL, 0, method_test_integer_return, NULL);
++}
++
++/*
++ * Section 16 Waking and Sleeping
++ */
++static int method_test_PTS(fwts_framework *fw)
++{
++	int i;
++
++	for (i = 1; i < 6; i++) {
++		ACPI_OBJECT arg[1];
++
++		arg[0].Type = ACPI_TYPE_INTEGER;
++		arg[0].Integer.Value = i;
++
++		fwts_log_info(fw, "Test _PTS(%d).", i);
++
++		if (method_evaluate_method(fw, METHOD_MANDATORY, "_PTS", arg, 1,
++			method_test_NULL_return, NULL) == FWTS_NOT_EXIST) {
++			fwts_advice(fw,
++				"Could not find _PTS. This method provides a "
++				"mechanism to do housekeeping functions, such "
++				"as write sleep state to the embedded "
++				"controller before entering a sleep state. If "
++				"the machine cannot suspend (S3), "
++				"hibernate (S4) or shutdown (S5) then it "
++				"could be because _PTS is missing.  Note that "
++				"ACPI 1.0 wants _PTS to be executed before "
++				"suspending devices.");
++			break;
++		}
++		fwts_log_nl(fw);
++	}
++	return FWTS_OK;
++}
++
++static int method_test_TTS(fwts_framework *fw)
++{
++	if (fwts_acpi_object_exists("_TTS") != NULL) {
++		int i;
++
++		for (i = 1; i < 6; i++) {
++			ACPI_OBJECT arg[1];
++
++			arg[0].Type = ACPI_TYPE_INTEGER;
++			arg[0].Integer.Value = i;
++
++			fwts_log_info(fw,
++				"Test _TTS(%d) Transition To State S%d.", i, i);
++
++			if (method_evaluate_method(fw, METHOD_MANDATORY,
++				"_TTS", arg, 1, method_test_NULL_return,
++				NULL) == FWTS_NOT_EXIST) {
++				fwts_advice(fw,
++					"Could not find _TTS. This method is invoked "
++					"at the beginning of the the sleep transition "
++					"for S1, S2, S3, S4 and S5 shutdown. The Linux "
++					"kernel caters for firmware that does not implement "
++					"_TTS, however, it will issue a warning that this "
++					"control method is missing.");
++				break;
++			}
++			fwts_log_nl(fw);
++		}
++	}
++	else {
++		fwts_skipped(fw,
++			"Optional control method _TTS does not exist.");
++	}
++	return FWTS_OK;
++}
++
++static void method_test_WAK_return(
++	fwts_framework *fw,
++	char *name,
++	ACPI_BUFFER *buf,
++	ACPI_OBJECT *obj,
++	void *private)
++{
++	FWTS_UNUSED(private);
++
++	if (method_check_type(fw, name, buf, ACPI_TYPE_PACKAGE) != FWTS_OK)
++		return;
++
++	if (method_package_count_equal(fw, name, "_WAK", obj, 2) != FWTS_OK)
++		return;
++
++	if (method_package_elements_all_type(fw, name, "_WAK", obj, ACPI_TYPE_INTEGER) != FWTS_OK)
++		return;
++
++	method_passed_sane(fw, name, "package");
++}
++
++static int method_test_WAK(fwts_framework *fw)
++{
++	uint32_t i;
++
++	for (i = 1; i < 6; i++) {
++		ACPI_OBJECT arg[1];
++		arg[0].Type = ACPI_TYPE_INTEGER;
++		arg[0].Integer.Value = i;
++		fwts_log_info(fw, "Test _WAK(%d) System Wake, State S%d.", i, i);
++		if (method_evaluate_method(fw, METHOD_MANDATORY, "_WAK", arg, 1,
++			method_test_WAK_return, &i) == FWTS_NOT_EXIST) {
++			fwts_advice(fw,
++				"Section 7.3.7 states that a system that wakes "
++				"from a sleeping state will invoke the _WAK "
++				"control to issue device, thermal and other "
++				"notifications to ensure that the operating system "
++				"checks the states of various devices, thermal "
++				"zones, etc.  The Linux kernel will report an "
++				"ACPI exception if _WAK is does not exist when "
++				"it returns from a sleep state.");
++			break;
++		}
++		fwts_log_nl(fw);
++	}
++	return FWTS_OK;
++}
++
++
++/*
++ * Appendix B ACPI Extensions for Display Adapters
++ */
++static int method_test_DOS(fwts_framework *fw)
++{
++	ACPI_OBJECT arg[1];
++
++	arg[0].Type = ACPI_TYPE_INTEGER;
++	arg[0].Integer.Value = 0 << 2 | 1;
++
++	/*
++	 * BIOS should toggle active display, BIOS controls brightness of
++	 * LCD on AC/DC power changes
++ 	 */
++	return method_evaluate_method(fw, METHOD_OPTIONAL,
++		"_DOS", arg, 1, method_test_NULL_return, NULL);
++}
++
++static void method_test_DOD_return(
++	fwts_framework *fw,
++	char *name,
++	ACPI_BUFFER *buf,
++	ACPI_OBJECT *obj,
++	void *private)
++{
++	uint32_t i;
++	bool failed = false;
++
++	static char *dod_type[] = {
++		"Other",
++		"VGA, CRT or VESA Compatible Analog Monitor",
++		"TV/HDTV or other Analog-Video Monitor",
++		"External Digital Monitor",
++
++		"Internal/Integrated Digital Flat Panel",
++		"Reserved",
++		"Reserved",
++		"Reserved",
++
++		"Reserved",
++		"Reserved",
++		"Reserved",
++		"Reserved",
++
++		"Reserved",
++		"Reserved",
++		"Reserved",
++		"Reserved"
++	};
++
++	FWTS_UNUSED(private);
++
++	if (method_check_type(fw, name, buf, ACPI_TYPE_PACKAGE) != FWTS_OK)
++		return;
++
++	for (i = 0; i < obj->Package.Count; i++) {
++		if (obj->Package.Elements[i].Type != ACPI_TYPE_INTEGER)
++			failed = true;
++		else {
++			uint32_t val = obj->Package.Elements[i].Integer.Value;
++			fwts_log_info_verbatim(fw, "Device %" PRIu32 ":", i);
++			if ((val & 0x80000000)) {
++				fwts_log_info_verbatim(fw, "  Video Chip Vendor Scheme %" PRIu32, val);
++			} else {
++				fwts_log_info_verbatim(fw, "  Instance:                %" PRIu32, val & 0xf);
++				fwts_log_info_verbatim(fw, "  Display port attachment: %" PRIu32, (val >> 4) & 0xf);
++				fwts_log_info_verbatim(fw, "  Type of display:         %" PRIu32 " (%s)",
++					(val >> 8) & 0xf, dod_type[(val >> 8) & 0xf]);
++				fwts_log_info_verbatim(fw, "  BIOS can detect device:  %" PRIu32, (val >> 16) & 1);
++				fwts_log_info_verbatim(fw, "  Non-VGA device:          %" PRIu32, (val >> 17) & 1);
++				fwts_log_info_verbatim(fw, "  Head or pipe ID:         %" PRIu32, (val >> 18) & 0x7);
++			}
++		}
++	}
++
++	if (failed)
++		fwts_failed(fw, LOG_LEVEL_MEDIUM,
++			"Method_DODNoPackage",
++			"Method _DOD did not return a package of "
++			"%" PRIu32 " integers.", obj->Package.Count);
++	else
++		method_passed_sane(fw, name, "package");
++}
++
++static int method_test_DOD(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_OPTIONAL,
++		"_DOD", NULL, 0, method_test_DOD_return, NULL);
++}
++
++static void method_test_ROM_return(
++	fwts_framework *fw,
++	char *name,
++	ACPI_BUFFER *buf,
++	ACPI_OBJECT *obj,
++	void *private)
++{
++	FWTS_UNUSED(obj);
++	FWTS_UNUSED(private);
++
++	if (method_check_type(fw, name, buf, ACPI_TYPE_BUFFER) == FWTS_OK)
++		method_passed_sane(fw, name, "package");
++}
++
++static int method_test_ROM(fwts_framework *fw)
++{
++	ACPI_OBJECT arg[2];
++
++	arg[0].Type = ACPI_TYPE_INTEGER;
++	arg[0].Integer.Value = 0;
++	arg[1].Type = ACPI_TYPE_INTEGER;
++	arg[1].Integer.Value = 4096;
++
++	return method_evaluate_method(fw, METHOD_OPTIONAL,
++		"_ROM", arg, 2, method_test_ROM_return, NULL);
++}
++
++static int method_test_GPD(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_OPTIONAL,
++		"_GPD", NULL, 0, method_test_integer_return, NULL);
++}
++
++static int method_test_SPD(fwts_framework *fw)
++{
++	ACPI_OBJECT arg[2];
++	int i;
++
++	for (i = 0; i < 4; i++) {
++		arg[0].Type = ACPI_TYPE_INTEGER;
++		arg[0].Integer.Value = i;	/* bits 00..11, post device */
++
++		if (method_evaluate_method(fw, METHOD_OPTIONAL,
++			"_SPD", arg, 1, method_test_passed_failed_return, NULL) == FWTS_NOT_EXIST)
++			break;
++	}
++	return FWTS_OK;
++}
++
++static int method_test_VPO(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_OPTIONAL,
++		"_VPO", NULL, 0, method_test_integer_return, NULL);
++}
++
++static int method_test_ADR(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_OPTIONAL,
++		"_ADR", NULL, 0, method_test_integer_return, NULL);
++}
++
++static void method_test_BCL_return(
++	fwts_framework *fw,
++	char *name,
++	ACPI_BUFFER *buf,
++	ACPI_OBJECT *obj,
++	void *private)
++{
++	uint32_t i;
++	bool failed = false;
++	bool ascending_levels = false;
++	char *str = NULL;
++
++	FWTS_UNUSED(private);
++
++	if (method_check_type(fw, name, buf, ACPI_TYPE_PACKAGE) != FWTS_OK)
++		return;
++
++	if (method_package_count_min(fw, name, "_BCL", obj, 3) != FWTS_OK)
++		return;
++
++	if (method_package_elements_all_type(fw, name, "_BCL", obj, ACPI_TYPE_INTEGER) != FWTS_OK)
++		return;
++
++	if (obj->Package.Elements[0].Integer.Value <
++	    obj->Package.Elements[1].Integer.Value) {
++		fwts_failed(fw, LOG_LEVEL_MEDIUM,
++			"Method_BCLMaxLevel",
++			"Brightness level when on full "
++			" power (%" PRIu64 ") is less than "
++				"brightness level when on "
++			"battery power (%" PRIu64 ").",
++			(uint64_t)obj->Package.Elements[0].Integer.Value,
++			(uint64_t)obj->Package.Elements[1].Integer.Value);
++		failed = true;
++	}
++
++	for (i = 2; i < obj->Package.Count - 1; i++) {
++		if (obj->Package.Elements[i].Integer.Value >
++		    obj->Package.Elements[i+1].Integer.Value) {
++			fwts_log_info(fw,
++				"Brightness level %" PRIu64
++				" (index %" PRIu32 ") is greater "
++				"than brightness level %" PRIu64
++				" (index %d" PRIu32 "), should "
++				"be in ascending order.",
++				(uint64_t)obj->Package.Elements[i].Integer.Value, i,
++				(uint64_t)obj->Package.Elements[i+1].Integer.Value, i+1);
++			ascending_levels = true;
++			failed = true;
++		}
++	}
++	if (ascending_levels) {
++		fwts_failed(fw, LOG_LEVEL_MEDIUM,
++			"Method_BCLAscendingOrder",
++			"Some or all of the brightness "
++			"level are not in ascending "
++			"order which should be fixed "
++			"in the firmware.");
++		failed = true;
++	}
++
++	fwts_log_info(fw, "Brightness levels for %s:" ,name);
++	fwts_log_info_verbatim(fw, "  Level on full power   : %" PRIu64,
++		(uint64_t)obj->Package.Elements[0].Integer.Value);
++	fwts_log_info_verbatim(fw, "  Level on battery power: %" PRIu64,
++		(uint64_t)obj->Package.Elements[1].Integer.Value);
++	for (i = 2; i < obj->Package.Count; i++) {
++		char tmp[12];
++
++		snprintf(tmp, sizeof(tmp), "%s%" PRIu64,
++			i == 2 ? "" : ", ",
++			(uint64_t)obj->Package.Elements[i].Integer.Value);
++		str = fwts_realloc_strcat(str, tmp);
++		if (!str)
++			break;
++	}
++	if (str) {
++		fwts_log_info_verbatim(fw, "  Brightness Levels     : %s", str);
++		free(str);
++	}
++
++	if (failed)
++		fwts_advice(fw,
++			"%s seems to be "
++			"misconfigured and is "
++			"returning incorrect "
++			"brightness levels."
++			"It is worth sanity checking "
++			"this with the firmware test "
++			"suite interactive test "
++			"'brightness' to see how "
++			"broken this is. As it is, "
++			"_BCL is broken and needs to "
++			"be fixed.", name);
++	else
++		fwts_passed(fw,
++			"%s returned a sane "
++			"package of %" PRIu32 " integers.",
++			name, obj->Package.Count);
++}
++
++static int method_test_BCL(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_OPTIONAL,
++		"_BCL", NULL, 0, method_test_BCL_return, NULL);
++}
++
++static int method_test_BCM(fwts_framework *fw)
++{
++	ACPI_OBJECT arg[1];
++
++	arg[0].Type = ACPI_TYPE_INTEGER;
++	arg[0].Integer.Value = 0;
++
++	return method_evaluate_method(fw, METHOD_OPTIONAL,
++		"_BCM", arg, 1, method_test_NULL_return, NULL);
++}
++
++static int method_test_BQC(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_OPTIONAL,
++		"_BQC", NULL, 0, method_test_integer_return, NULL);
++}
++
++static void method_test_DDC_return(
++	fwts_framework *fw,
++	char *name,
++	ACPI_BUFFER *buf,
++	ACPI_OBJECT *obj,
++	void *private)
++{
++	uint32_t requested = *(uint32_t*)private;
++
++	FWTS_UNUSED(buf);
++
++	if (obj == NULL) {
++		method_failed_null_object(fw, name, "a buffer or integer");
++		return;
++	}
++
++	switch (obj->Type) {
++	case ACPI_TYPE_BUFFER:
++		if (requested != obj->Buffer.Length)
++			fwts_failed(fw, LOG_LEVEL_MEDIUM,
++				"Method_DDCElementCount",
++				"%s returned a buffer of %" PRIu32 " items, "
++				"expected %" PRIu32 ".",
++				name, obj->Buffer.Length, requested);
++		else
++			fwts_passed(fw,
++				"Method %s returned a buffer of %d items "
++				"as expected.",
++				name, obj->Buffer.Length);
++		break;
++	case ACPI_TYPE_INTEGER:
++			fwts_passed(fw,
++				"%s could not return a buffer of %d "
++					"items and instead returned an error "
++					"status.",
++				name, obj->Buffer.Length);
++		break;
++	default:
++		fwts_failed(fw, LOG_LEVEL_MEDIUM, "Method_DDCBadReturnType",
++			"%s did not return a buffer or an integer.", name);
++		break;
++	}
++}
++
++static int method_test_DDC(fwts_framework *fw)
++{
++	ACPI_OBJECT arg[1];
++	uint32_t i;
++
++	for (i = 128; i <= 256; i <<= 1) {
++		arg[0].Type = ACPI_TYPE_INTEGER;
++		arg[0].Integer.Value = 128;
++
++		if (method_evaluate_method(fw, METHOD_OPTIONAL,
++			"_DDC", arg, 1, method_test_DDC_return,
++			&i) == FWTS_NOT_EXIST)
++			break;
++	}
++	return FWTS_OK;
++}
++
++static int method_test_DCS(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_OPTIONAL,
++		"_DCS", NULL, 0, method_test_integer_return, NULL);
++}
++
++static int method_test_DGS(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_OPTIONAL,
++		"_DGS", NULL, 0, method_test_integer_return, NULL);
++}
++
++static int method_test_DSS(fwts_framework *fw)
++{
++	ACPI_OBJECT arg[1];
++
++	arg[0].Type = ACPI_TYPE_INTEGER;
++	arg[0].Integer.Value = 0;
++
++	return method_evaluate_method(fw, METHOD_OPTIONAL,
++		"_DSS", arg, 1, method_test_NULL_return, NULL);
++}
++
++static int method_test_CBA(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_OPTIONAL,
++		"_CBA", NULL, 0, method_test_integer_return, NULL);
++}
++
++static int method_test_CDM(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_OPTIONAL,
++		"_CDM", NULL, 0, method_test_integer_return, NULL);
++}
++
++/*
++ * Intelligent Platform Management Interface (IPMI) Specification
++ */
++static int method_test_IFT(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_OPTIONAL,
++		"_IFT", NULL, 0, method_test_integer_return, NULL);
++}
++
++static int method_test_SRV(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_OPTIONAL,
++		"_SRV", NULL, 0, method_test_integer_return, NULL);
++}
++
++/* ARM SBBR Test Definitions */
++static int sbbr_method_test_ADR(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_MANDATORY,
++		"_ADR", NULL, 0, method_test_integer_return, NULL);
++}
++
++static int sbbr_method_test_AEI(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_MANDATORY,
++		"_AEI", NULL, 0, method_test_AEI_return, NULL);
++}
++
++static int sbbr_method_test_CCA(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_MANDATORY,
++		"_CCA", NULL, 0, method_test_integer_return, NULL);
++}
++
++static int sbbr_method_test_EVT(fwts_framework *fw)
++{
++	int ret;
++
++	/* Only test the _EVT method with pins defined in AEI. */
++	ret = method_evaluate_method(fw, METHOD_MANDATORY,
++		"_AEI", NULL, 0, method_test_EVT_return, NULL);
++
++	if (ret == FWTS_NOT_EXIST)
++		fwts_failed(fw, LOG_LEVEL_HIGH, "SbbrAcpiEvtDoesNotExist", "Method _EVT does not exist.");
++
++	return ret;
++}
++
++static int sbbr_method_test_HID(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_MANDATORY,
++		"_HID", NULL, 0, method_test_HID_return, NULL);
++}
++
++static int sbbr_method_test_SST(fwts_framework *fw)
++{
++	ACPI_OBJECT arg[1];
++	int ret, i;
++
++	arg[0].Type = ACPI_TYPE_INTEGER;
++	for (i = 0; i <= 4; i++) {
++		arg[0].Integer.Value = i;
++		ret = method_evaluate_method(fw, METHOD_MANDATORY,
++			"_SST", arg, 1, method_test_NULL_return, NULL);
++
++		if (ret != FWTS_OK)
++			break;
++	}
++	return ret;
++}
++
++static int sbbr_method_test_STA(fwts_framework *fw)
++{
++	return method_evaluate_method(fw, METHOD_MANDATORY,
++		"_STA", NULL, 0, method_test_STA_return, "_STA");
++}
++
++static int sbbr_method_test_UID(fwts_framework *fw)
++{
++     return method_evaluate_method(fw, METHOD_MANDATORY,
++             "_UID", NULL, 0, method_test_UID_return, NULL);
++}
++
++
++/*
++ * Tests
++ */
++static fwts_framework_minor_test sbbr_method_tests[] = {
++	{ method_name_check, "Test Method Names." },
++
++	/* Section 5.3 */
++	/* { method_test_PR , "Test _PR  (Processor)." }, */
++
++	/* Section 5.6 ACPI Event Programming Model */
++	/* { method_test_Wxx, "Test _Wxx (Wake Event)." }, */
++
++	{ method_test_AEI, "Test _AEI." },
++	{ method_test_EVT, "Test _EVT (Event Method)." },
++
++	/* Section 5.7 Predefined Objects */
++	{ method_test_DLM, "Test _DLM (Device Lock Mutex)." },
++	/* { method_test_GL , "Test _GL  (Global Lock)." }, */
++	/* { method_test_OS , "Test _OS  (Operating System)." }, */
++	/* { method_test_REV, "Test _REV (Revision)." }, */
++
++	/* Section 5.8 System Configuration Objects */
++	{ method_test_PIC, "Test _PIC (Inform AML of Interrupt Model)." },
++
++	/* Section 6.1 Device Identification Objects  */
++
++	{ method_test_CID, "Test _CID (Compatible ID)." },
++	/* { method_test_CLS, "Test _CLS (Class Code)." }, */
++	{ method_test_DDN, "Test _DDN (DOS Device Name)." },
++	{ method_test_HID, "Test _HID (Hardware ID)." },
++	{ method_test_HRV, "Test _HRV (Hardware Revision Number)." },
++	{ method_test_MLS, "Test _MLS (Multiple Language String)." },
++	{ method_test_PLD, "Test _PLD (Physical Device Location)." },
++	{ method_test_SUB, "Test _SUB (Subsystem ID)." },
++	{ method_test_SUN, "Test _SUN (Slot User Number)." },
++	{ method_test_STR, "Test _STR (String)." },
++	{ method_test_UID, "Test _UID (Unique ID)." },
++
++	/* Section 6.2 Device Configurations Objects */
++
++	{ method_test_CDM, "Test _CDM (Clock Domain)." },
++	{ method_test_CRS, "Test _CRS (Current Resource Settings)." },
++	{ method_test_DSD, "Test _DSD (Device Specific Data)." },
++	{ method_test_DIS, "Test _DIS (Disable)." },
++	{ method_test_DMA, "Test _DMA (Direct Memory Access)." },
++	{ method_test_FIX, "Test _FIX (Fixed Register Resource Provider)." },
++	{ method_test_GSB, "Test _GSB (Global System Interrupt Base)." },
++	{ method_test_HPP, "Test _HPP (Hot Plug Parameters)." },
++	/* { method_test_HPX, "Test _HPX (Hot Plug Extensions)." }, */
++	/* { method_test_MAT, "Test _MAT (Multiple APIC Table Entry)." }, */
++	{ method_test_PRS, "Test _PRS (Possible Resource Settings)." },
++	{ method_test_PRT, "Test _PRT (PCI Routing Table)." },
++	{ method_test_PXM, "Test _PXM (Proximity)." },
++	/* { method_test_SLI, "Test _SLI (System Locality Information)." }, */
++	/* { method_test_SRS, "Test _SRS (Set Resource Settings)." }, */
++	{ method_test_CCA, "Test _CCA (Cache Coherency Attribute)." },
++
++	/* Section 6.3 Device Insertion, Removal and Status Objects */
++
++	{ method_test_EDL, "Test _EDL (Eject Device List)." },
++	{ method_test_EJD, "Test _EJD (Ejection Dependent Device)." },
++	{ method_test_EJ0, "Test _EJ0 (Eject)." },
++	{ method_test_EJ1, "Test _EJ1 (Eject)." },
++	{ method_test_EJ2, "Test _EJ2 (Eject)." },
++	{ method_test_EJ3, "Test _EJ3 (Eject)." },
++	{ method_test_EJ4, "Test _EJ4 (Eject)." },
++	{ method_test_LCK, "Test _LCK (Lock)." },
++	/* { method_test_OST, "Test _OST (OSPM Status Indication)." }, */
++	{ method_test_RMV, "Test _RMV (Remove)." },
++	{ method_test_STA, "Test _STA (Status)." },
++
++	/* Section 6.4 Resource Data Types for ACPI */
++
++	/* Section 6.5 Other Objects and Controls */
++
++	{ method_test_DEP, "Test _DEP (Operational Region Dependencies)." },
++	{ method_test_FIT, "Test _FIT (Firmware Interface Table)." },
++	{ method_test_BDN, "Test _BDN (BIOS Dock Name)." },
++	{ method_test_BBN, "Test _BBN (Base Bus Number)." },
++	{ method_test_DCK, "Test _DCK (Dock)." },
++	{ method_test_INI, "Test _INI (Initialize)." },
++	{ method_test_GLK, "Test _GLK (Global Lock)." },
++	/* { method_test_REG, "Test _REG (Region)." }, */
++	{ method_test_SEG, "Test _SEG (Segment)." },
++
++	/* Section 7.1 Declaring a Power Resource Object */
++
++	{ method_test_OFF, "Test _OFF (Set resource off)." },
++	{ method_test_ON_,  "Test _ON_ (Set resource on)." },
++
++	/* Section 7.2 Device Power Management Objects */
++
++	{ method_test_DSW, "Test _DSW (Device Sleep Wake)." },
++	{ method_test_IRC, "Test _IRC (In Rush Current)." },
++	{ method_test_PRE, "Test _PRE (Power Resources for Enumeration)." },
++	{ method_test_PR0, "Test _PR0 (Power Resources for D0)." },
++	{ method_test_PR1, "Test _PR1 (Power Resources for D1)." },
++	{ method_test_PR2, "Test _PR2 (Power Resources for D2)." },
++	{ method_test_PR3, "Test _PR3 (Power Resources for D3)." },
++	{ method_test_PRW, "Test _PRW (Power Resources for Wake)." },
++	{ method_test_PS0, "Test _PS0 (Power State 0)." },
++	{ method_test_PS1, "Test _PS1 (Power State 1)." },
++	{ method_test_PS2, "Test _PS2 (Power State 2)." },
++	{ method_test_PS3, "Test _PS3 (Power State 3)." },
++	{ method_test_PSC, "Test _PSC (Power State Current)." },
++	{ method_test_PSE, "Test _PSE (Power State for Enumeration)." },
++	{ method_test_PSW, "Test _PSW (Power State Wake)." },
++	{ method_test_S1D, "Test _S1D (S1 Device State)." },
++	{ method_test_S2D, "Test _S2D (S2 Device State)." },
++	{ method_test_S3D, "Test _S3D (S3 Device State)." },
++	{ method_test_S4D, "Test _S4D (S4 Device State)." },
++	{ method_test_S0W, "Test _S0W (S0 Device Wake State)." },
++	{ method_test_S1W, "Test _S1W (S1 Device Wake State)." },
++	{ method_test_S2W, "Test _S2W (S2 Device Wake State)." },
++	{ method_test_S3W, "Test _S3W (S3 Device Wake State)." },
++	{ method_test_S4W, "Test _S4W (S4 Device Wake State)." },
++	{ method_test_RST, "Test _RST (Device Reset)." },
++	{ method_test_PRR, "Test _PRR (Power Resource for Reset)." },
++
++	/* Section 7.3 OEM-Supplied System-Level Control Methods */
++	{ method_test_S0_, "Test _S0_ (S0 System State)." },
++	{ method_test_S1_, "Test _S1_ (S1 System State)." },
++	{ method_test_S2_, "Test _S2_ (S2 System State)." },
++	{ method_test_S3_, "Test _S3_ (S3 System State)." },
++	{ method_test_S4_, "Test _S4_ (S4 System State)." },
++	{ method_test_S5_, "Test _S5_ (S5 System State)." },
++	{ method_test_SWS, "Test _SWS (System Wake Source)." },
++
++	/* Section 8.4 Declaring Processors */
++
++	{ method_test_PSS, "Test _PSS (Performance Supported States)." },
++	{ method_test_CPC, "Test _CPC (Continuous Performance Control)." },
++	{ method_test_CSD, "Test _CSD (C State Dependencies)." },
++	{ method_test_CST, "Test _CST (C States)." },
++	{ method_test_PCT, "Test _PCT (Performance Control)." },
++	/* { method_test_PDC, "Test _PDC (Processor Driver Capabilities)." }, */
++	{ method_test_PDL, "Test _PDL (P-State Depth Limit)." },
++	{ method_test_PPC, "Test _PPC (Performance Present Capabilities)." },
++	{ method_test_PPE, "Test _PPE (Polling for Platform Error)." },
++	{ method_test_PSD, "Test _PSD (Power State Dependencies)." },
++	{ method_test_PTC, "Test _PTC (Processor Throttling Control)." },
++	{ method_test_TDL, "Test _TDL (T-State Depth Limit)." },
++	{ method_test_TPC, "Test _TPC (Throttling Present Capabilities)." },
++	{ method_test_TSD, "Test _TSD (Throttling State Dependencies)." },
++	{ method_test_TSS, "Test _TSS (Throttling Supported States)." },
++
++	/* Section 8.4.4 Lower Power Idle States */
++	{ method_test_LPI, "Test _LPI (Low Power Idle States)." },
++	{ method_test_RDI, "Test _RDI (Resource Dependencies for Idle)." },
++
++	/* Section 8.5 Processor Aggregator Device */
++	{ method_test_PUR, "Test _PUR (Processor Utilization Request)." },
++
++	/* Section 9.1 System Indicators */
++	{ method_test_MSG, "Test _MSG (Message)." },
++	{ method_test_SST, "Test _SST (System Status)." },
++
++	/* Section 9.2 Ambient Light Sensor Device */
++
++	{ method_test_ALC, "Test _ALC (Ambient Light Colour Chromaticity)." },
++	{ method_test_ALI, "Test _ALI (Ambient Light Illuminance)." },
++	{ method_test_ALT, "Test _ALT (Ambient Light Temperature)." },
++	{ method_test_ALP, "Test _ALP (Ambient Light Polling)."},
++	{ method_test_ALR, "Test _ALR (Ambient Light Response)."},
++
++	/* Section 9.3 Battery Device */
++
++	/* Section 9.4 Lid Device */
++
++	{ method_test_LID, "Test _LID (Lid Status)." },
++
++	/* Section 9.8 ATA Controllers */
++	{ method_test_GTF, "Test _GTF (Get Task File)." },
++	{ method_test_GTM, "Test _GTM (Get Timing Mode)." },
++	/* { method_test_SDD, "Test _SDD (Set Device Data)." }, */
++	/* { method_test_STM, "Test _STM (Set Timing Mode)." }, */
++
++	/* Section 9.9 Floppy Controllers */
++	/* { method_test_FDE, "Test _FDE (Floppy Disk Enumerate)." }, */
++	/* { method_test_FDI, "Test _FDI (Floppy Drive Information)." }, */
++	/* { method_test_FDM, "Test _FDM (Floppy Drive Mode)." }, */
++
++	/* Section 9.12 Memory Devices */
++	{ method_test_MBM, "Test _MBM (Memory Bandwidth Monitoring Data)." },
++	/* { method_test_MSM, "Test _MSM (Memory Set Monitoring)." }, */
++
++	/* Section 9.13 USB Port Capabilities */
++	{ method_test_UPC, "Test _UPC (USB Port Capabilities)." },
++
++	/* Section 9.14 Device Object Name Collision */
++	/* { method_test_DSM, "Test _DSM (Device Specific Method)." }, */
++
++	/* Section 9.16 User Presence Detection Device */
++	{ method_test_UPD, "Test _UPD (User Presence Detect)." },
++	{ method_test_UPP, "Test _UPP (User Presence Polling)." },
++
++	/* Section 9.18 Wake Alarm Device */
++
++	{ method_test_GCP, "Test _GCP (Get Capabilities)." },
++	{ method_test_GRT, "Test _GRT (Get Real Time)." },
++	{ method_test_GWS, "Test _GWS (Get Wake Status)." },
++	{ method_test_CWS, "Test _CWS (Clear Wake Status)." },
++	{ method_test_SRT, "Test _SRT (Set Real Time)." },
++	{ method_test_STP, "Test _STP (Set Expired Timer Wake Policy)." },
++	{ method_test_STV, "Test _STV (Set Timer Value)." },
++	{ method_test_TIP, "Test _TIP (Expired Timer Wake Policy)." },
++	{ method_test_TIV, "Test _TIV (Timer Values)." },
++
++	/* Section 10.1 Smart Battery */
++
++	{ method_test_SBS, "Test _SBS (Smart Battery Subsystem)." },
++
++	/* Section 10.2 Battery Controls */
++
++	{ method_test_BCT, "Test _BCT (Battery Charge Time)." },
++	{ method_test_BIF, "Test _BIF (Battery Information)." },
++	{ method_test_BIX, "Test _BIX (Battery Information Extended)." },
++	{ method_test_BMA, "Test _BMA (Battery Measurement Averaging)." },
++	{ method_test_BMC, "Test _BMC (Battery Maintenance Control)." },
++	{ method_test_BMD, "Test _BMD (Battery Maintenance Data)." },
++	{ method_test_BMS, "Test _BMS (Battery Measurement Sampling Time)." },
++	{ method_test_BST, "Test _BST (Battery Status)." },
++	{ method_test_BTP, "Test _BTP (Battery Trip Point)." },
++	{ method_test_BTH, "Test _BTH (Battery Throttle Limit)." },
++	{ method_test_BTM, "Test _BTM (Battery Time)." },
++	/* { method_test_BLT, "Test _BLT (Battery Level Threshold)." }, */
++
++	/* Section 10.3 AC Adapters and Power Source Objects */
++
++	{ method_test_PCL, "Test _PCL (Power Consumer List)." },
++	{ method_test_PIF, "Test _PIF (Power Source Information)." },
++	{ method_test_PRL, "Test _PRL (Power Source Redundancy List)." },
++	{ method_test_PSR, "Test _PSR (Power Source)." },
++
++	/* Section 10.4 Power Meters */
++	{ method_test_GAI, "Test _GAI (Get Averaging Level)." },
++	{ method_test_GHL, "Test _GHL (Get Harware Limit)." },
++	/* { method_test_PAI, "Test _PAI (Power Averaging Interval)." }, */
++	{ method_test_PMC, "Test _PMC (Power Meter Capabilities)." },
++	{ method_test_PMD, "Test _PMD (Power Meter Devices)." },
++	{ method_test_PMM, "Test _PMM (Power Meter Measurement)." },
++	/* { method_test_PTP, "Test _PTP (Power Trip Points)." }, */
++	/* { method_test_SHL, "Test _SHL (Set Hardware Limit)." }, */
++
++	/* Section 10.5 Wireless Power Controllers */
++	{ method_test_WPC, "Test _WPC (Wireless Power Calibration)." },
++	{ method_test_WPP, "Test _WPP (Wireless Power Polling)." },
++
++	/* Section 11.3 Fan Devices */
++
++	{ method_test_FIF, "Test _FIF (Fan Information)." },
++	{ method_test_FPS, "Test _FPS (Fan Performance States)." },
++	{ method_test_FSL, "Test _FSL (Fan Set Level)." },
++	{ method_test_FST, "Test _FST (Fan Status)." },
++
++	/* Section 11.4 Thermal Objects */
++
++	{ method_test_ACx, "Test _ACx (Active Cooling)." },
++	{ method_test_ART, "Test _ART (Active Cooling Relationship Table)." },
++	/* { method_test_ALx, "Test _ALx (Active List)". }, */
++	{ method_test_CRT, "Test _CRT (Critical Trip Point)." },
++	{ method_test_CR3, "Test _CR3 (Warm/Standby Temperature)." },
++	{ method_test_DTI, "Test _DTI (Device Temperature Indication)." },
++	{ method_test_HOT, "Test _HOT (Hot Temperature)." },
++	{ method_test_MTL, "Test _MTL (Minimum Throttle Limit)." },
++	{ method_test_NTT, "Test _NTT (Notification Temp Threshold)." },
++	{ method_test_PSL, "Test _PSL (Passive List)." },
++	{ method_test_PSV, "Test _PSV (Passive Temp)." },
++	{ method_test_RTV, "Test _RTV (Relative Temp Values)." },
++	{ method_test_SCP, "Test _SCP (Set Cooling Policy)." },
++	{ method_test_TC1, "Test _TC1 (Thermal Constant 1)." },
++	{ method_test_TC2, "Test _TC2 (Thermal Constant 2)." },
++	{ method_test_TFP, "Test _TFP (Thermal fast Sampling Period)." },
++	{ method_test_TMP, "Test _TMP (Thermal Zone Current Temp)." },
++	{ method_test_TPT, "Test _TPT (Trip Point Temperature)." },
++	{ method_test_TRT, "Test _TRT (Thermal Relationship Table)." },
++	{ method_test_TSN, "Test _TSN (Thermal Sensor Device)." },
++	{ method_test_TSP, "Test _TSP (Thermal Sampling Period)." },
++	{ method_test_TST, "Test _TST (Temperature Sensor Threshold)." },
++	{ method_test_TZD, "Test _TZD (Thermal Zone Devices)." },
++	{ method_test_TZM, "Test _TZM (Thermal Zone member)." },
++	{ method_test_TZP, "Test _TZP (Thermal Zone Polling)." },
++
++	/* Section 12 Embedded Controller Interface */
++	{ method_test_GPE, "Test _GPE (General Purpose Events)." },
++	{ method_test_EC_,  "Test _EC_ (EC Offset Query)." },
++
++	/* Section 16 Waking and Sleeping */
++
++	{ method_test_PTS, "Test _PTS (Prepare to Sleep)." },
++	{ method_test_TTS, "Test _TTS (Transition to State)." },
++	{ method_test_WAK, "Test _WAK (System Wake)." },
++
++	/* Appendix B, ACPI Extensions for Display Adapters */
++
++	{ method_test_ADR, "Test _ADR (Return Unique ID for Device)." },
++	{ method_test_BCL, "Test _BCL (Query List of Brightness Control Levels Supported)." },
++	{ method_test_BCM, "Test _BCM (Set Brightness Level)." },
++	{ method_test_BQC, "Test _BQC (Brightness Query Current Level)." },
++	{ method_test_DCS, "Test _DCS (Return the Status of Output Device)." },
++	{ method_test_DDC, "Test _DDC (Return the EDID for this Device)." },
++	{ method_test_DSS, "Test _DSS (Device Set State)." },
++	{ method_test_DGS, "Test _DGS (Query Graphics State)." },
++	{ method_test_DOD, "Test _DOD (Enumerate All Devices Attached to Display Adapter)." },
++	{ method_test_DOS, "Test _DOS (Enable/Disable Output Switching)." },
++	{ method_test_GPD, "Test _GPD (Get POST Device)." },
++	{ method_test_ROM, "Test _ROM (Get ROM Data)." },
++	{ method_test_SPD, "Test _SPD (Set POST Device)." },
++	{ method_test_VPO, "Test _VPO (Video POST Options)." },
++
++	/* From PCI Specification */
++	{ method_test_CBA, "Test _CBA (Configuration Base Address)." },
++
++	/* From IPMI Specification 2.0 */
++	{ method_test_IFT, "Test _IFT (IPMI Interface Type)." },
++	{ method_test_SRV, "Test _SRV (IPMI Interface Revision)." },
++
++	/* From ARM SBBR */
++	{ sbbr_method_test_ADR, "SBBR Test _ADR (Return Unique ID for Device)." },
++	{ sbbr_method_test_AEI, "SBBR Test _AEI (Event Information)." },
++	{ sbbr_method_test_CCA, "SBBR Test _CCA (Cache Coherency Attribute)." },
++	{ sbbr_method_test_EVT, "SBBR Test _EVT (Event Method)." },
++	{ sbbr_method_test_HID, "SBBR Test _HID (Hardware ID)." },
++	{ sbbr_method_test_SST, "SBBR Test _SST (System Status)." },
++	{ sbbr_method_test_STA, "SBBR Test _STA (Status)." },
++	{ sbbr_method_test_UID, "SBBR Test _UID (Unique ID)." },
++
++	/* End! */
++
++	{ NULL, NULL }
++};
++
++static fwts_framework_ops sbbr_method_ops = {
++	.description = "ACPI DSDT Method Semantic tests.",
++	.init        = sbbr_method_init,
++	.deinit      = sbbr_method_deinit,
++	.minor_tests = sbbr_method_tests
++};
++
++FWTS_REGISTER("sbbr_method", &sbbr_method_ops, FWTS_TEST_ANYTIME, FWTS_FLAG_TEST_SBBR)
++
++#endif
+diff --git a/src/sbbr/rsdp/rsdp.c b/src/sbbr/rsdp/rsdp.c
+new file mode 100644
+index 0000000..0a11f91
+--- /dev/null
++++ b/src/sbbr/rsdp/rsdp.c
+@@ -0,0 +1,134 @@
++/*
++ * Copyright (C) 2015-2017 Canonical
++ * Copyright (C) 2017 ARM Ltd
++ *
++ * Portions of this code original from the Linux-ready Firmware Developer Kit
++ *
++ * This program is free software; you can redistribute it and/or
++ * modify it under the terms of the GNU General Public License
++ * as published by the Free Software Foundation; either version 2
++ * of the License, or (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ */
++#include "fwts.h"
++
++#if defined(FWTS_HAS_SBBR)
++
++#include <stdlib.h>
++#include <stdio.h>
++#include <unistd.h>
++#include <inttypes.h>
++#include <string.h>
++#include <ctype.h>
++
++static fwts_acpi_table_info *table;
++
++static int sbbr_rsdp_init(fwts_framework *fw)
++{
++	if (fwts_acpi_find_table(fw, "RSDP", 0, &table) != FWTS_OK) {
++		fwts_log_error(fw, "Cannot read ACPI tables.");
++		return FWTS_ERROR;
++	}
++	if (!table) {
++
++			fwts_log_error(fw,
++				       "ACPI RSDP is required for the "
++				       "%s target architecture.",
++				       fwts_arch_get_name(fw->target_arch));
++			return FWTS_ERROR;
++	}
++
++	/* We know there is an RSDP now, so do a quick sanity check */
++	if (table->length == 0) {
++		fwts_log_error(fw,
++			       "ACPI RSDP table has zero length");
++		return FWTS_ERROR;
++	}
++	return FWTS_OK;
++}
++
++/*
++ *  RSDP Root System Description Pointer
++ */
++static int sbbr_rsdp_test1(fwts_framework *fw)
++{
++	fwts_acpi_table_rsdp *rsdp = (fwts_acpi_table_rsdp *)table->data;
++	uint8_t checksum;
++
++	/*This includes only the first 20 bytes of this table, bytes
++	0 to 19, including the checksum field. These bytes must sum to
++	zero. */
++	const char RSDP_SIGNATURE[]  = {'R', 'S', 'D', ' ', 'P', 'T', 'R', ' '};
++	bool signature_pass             = false;
++	const int CHECKSUM_BYTES        = 20;
++	bool  checksum_pass             = false;
++	const int SBBR_RSDP_REVISION    = 2;
++	bool  rsdp_revision_pass        = false;
++	const uint32_t SBBR_RSDP_LENGTH = 36;
++	bool  rsdp_length_pass          = false;
++	const int EXT_CHECKSUM_BYTES    = 36;
++	bool  ext_checksum_pass         = false;
++	bool xsdt_address_pass          = false;
++
++	fwts_log_info(fw, "RSDP Signature = %.8s", rsdp->signature);
++	signature_pass = strncmp(rsdp->signature, RSDP_SIGNATURE, sizeof(rsdp->signature))? false : true;
++
++	/* verify first checksum */
++	checksum = fwts_checksum(table->data, CHECKSUM_BYTES);
++	fwts_log_info(fw, "RSDP Checksum = 0x%x", checksum);
++	checksum_pass = (checksum == 0)? true : false;
++
++	fwts_log_info(fw, "RSDP Revision = 0x%x", rsdp->revision);
++	rsdp_revision_pass = (rsdp->revision >= SBBR_RSDP_REVISION)? true : false;
++
++	fwts_log_info(fw, "RSDP Length = 0x%x", rsdp->length);
++	rsdp_length_pass = (rsdp->length == SBBR_RSDP_LENGTH)? true : false;
++
++	checksum = fwts_checksum(table->data, EXT_CHECKSUM_BYTES);
++	fwts_log_info(fw, "RSDP Extended Checksum = 0x%x", checksum);
++	ext_checksum_pass = (checksum == 0)? true : false;
++
++	if ( (rsdp->xsdt_address != 0) &&
++	     (rsdp->rsdt_address == 0)    )
++	{
++		xsdt_address_pass = true;
++	}
++
++    if ( (signature_pass     == true) &&
++		 (checksum_pass      == true) &&
++		 (rsdp_revision_pass == true) &&
++		 (rsdp_length_pass   == true) &&
++		 (ext_checksum_pass  == true) &&
++		 (xsdt_address_pass  == true)    )
++    {
++    	fwts_passed(fw, "SBBR: Structure of RSDP Table is consistent with ACPI 6.0 or later and uses 64 bit xsdt addresses.");
++    }
++    else
++    {
++    	fwts_failed(fw, LOG_LEVEL_CRITICAL,
++    				"SBBR RSDP:",
++    				"Structure of RSDP Table is not consistent with ACPI 6.0 or later and/or does not use 64 bit xsdt addresses.");
++    }
++
++	return FWTS_OK;
++}
++
++static fwts_framework_minor_test sbbr_rsdp_tests[] = {
++	{ sbbr_rsdp_test1, "RSDP Root System Description Pointer test." },
++	{ NULL, NULL }
++};
++
++static fwts_framework_ops sbbr_rsdp_ops = {
++	.description = "SBBR RSDP Root System Description Pointer tests.",
++	.init        = sbbr_rsdp_init,
++	.minor_tests = sbbr_rsdp_tests
++};
++
++FWTS_REGISTER("sbbr_rsdp", &sbbr_rsdp_ops, FWTS_TEST_ANYTIME, FWTS_FLAG_TEST_SBBR)
++
++#endif
+diff --git a/src/sbbr/spcr/spcr.c b/src/sbbr/spcr/spcr.c
+new file mode 100644
+index 0000000..86973fa
+--- /dev/null
++++ b/src/sbbr/spcr/spcr.c
+@@ -0,0 +1,343 @@
++/*
++ * Copyright (C) 2015-2017 Canonical
++ * Copyright (C) 2017 ARM Ltd
++ *
++ * Portions of this code original from the Linux-ready Firmware Developer Kit
++ *
++ * This program is free software; you can redistribute it and/or
++ * modify it under the terms of the GNU General Public License
++ * as published by the Free Software Foundation; either version 2
++ * of the License, or (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
++ *
++ */
++#include "fwts.h"
++
++#if defined(FWTS_HAS_SBBR)
++
++#include <stdlib.h>
++#include <stdio.h>
++#include <unistd.h>
++#include <inttypes.h>
++#include <string.h>
++
++static const fwts_acpi_table_spcr *spcr;
++
++static int sbbr_spcr_init(fwts_framework *fw)
++{
++	fwts_acpi_table_info *table;
++
++	if (fwts_acpi_find_table(fw, "SPCR", 0, &table) != FWTS_OK) {
++		fwts_log_error(fw, "Cannot read ACPI tables.");
++		return FWTS_ERROR;
++	}
++	if (table == NULL || (table && table->length == 0)) {
++		fwts_log_error(fw, "ACPI SPCR table does not exist");
++		return FWTS_ERROR;
++	}
++	spcr = (const fwts_acpi_table_spcr*)table->data;
++
++	return FWTS_OK;
++}
++
++/*
++ *  For SPCR and serial port types refer to:
++ *	https://msdn.microsoft.com/en-gb/library/windows/hardware/dn639132%28v=vs.85%29.aspx
++ *	https://msdn.microsoft.com/en-us/library/windows/hardware/dn639131%28v=vs.85%29.aspx
++ */
++static int sbbr_spcr_revision_test(fwts_framework *fw)
++{
++	const uint8_t SBBR_LATEST_REVISION = 2;
++
++	if (spcr->header.revision >= SBBR_LATEST_REVISION)
++		fwts_passed(fw, "SPCR revision is up to date.");
++	else
++		fwts_failed(fw, LOG_LEVEL_CRITICAL, "spcr_revision:", "SPCR revision is outdated: %d",
++				spcr->header.revision);
++
++	return FWTS_OK;
++}
++
++static int sbbr_spcr_gsiv_test(fwts_framework *fw)
++{
++	const uint8_t ARMH_GIC_INTR_MASK = 0x08;
++
++	if ( (spcr->interrupt_type == ARMH_GIC_INTR_MASK) &&
++	     (spcr->gsi            != 0x0000000000000000)    )
++		fwts_passed(fw, "SPCR appears to be populated with correct GSIV interrupt"
++				        "routing information for ARM PL011 UART Device");
++
++	else
++		fwts_failed(fw, LOG_LEVEL_CRITICAL, "sbbr_gsiv:", "SPCR GSIV Information is set incorrectly.");
++
++	return FWTS_OK;
++
++}
++
++
++static int sbbr_spcr_generic_test(fwts_framework *fw)
++{
++	char *str;
++	bool reserved = false;
++	bool pci = true;
++	bool passed = true;
++
++	/*
++	 * Assuming revision 2, full list from
++	 * http://go.microsoft.com/fwlink/p/?LinkId=234837)
++	 */
++	switch (spcr->interface_type) {
++	case 0x00:
++		str = "16550 compatible";
++		break;
++	case 0x01:
++		str = "16450 compatible";
++		break;
++	case 0x03:
++		str = "ARM PL011 UART";
++		break;
++	case 0x02:
++	case 0x04 ... 0x09:
++		str = "Reserved (Do not Use)";
++		reserved = true;
++		break;
++	case 0x0d:
++		str = "(deprecated) ARM SBSA";
++		break;
++	case 0x0e:
++		str = "ARM SBSA Generic UART";
++		break;
++	case 0x0f:
++		str = "ARM DCC";
++		break;
++	case 0x10:
++		str = "BCM2835";
++		break;
++	default:
++		str = "Reserved";
++		reserved = true;
++		break;
++	}
++
++	fwts_log_info_verbatim(fw, "Serial Interface: %s", str);
++	if (reserved) {
++		passed = false;
++		fwts_failed(fw, LOG_LEVEL_HIGH,
++			"SPCRInterfaceReserved",
++			"SPCR Serial interface type 0x%2.2" PRIx8
++			" is a reserved interface", spcr->interface_type);
++	}
++
++	if ((spcr->reserved1[0] |
++	     spcr->reserved1[1] |
++	     spcr->reserved1[2])) {
++		passed = false;
++		fwts_failed(fw, LOG_LEVEL_LOW,
++			"SPCRReservedNonZero",
++			"SPCR reserved field must be zero, got "
++			"0x%2.2" PRIx8 "%2.2" PRIx8 "%2.2" PRIx8 " instead",
++				spcr->reserved1[0],
++				spcr->reserved1[1],
++				spcr->reserved1[2]);
++	}
++
++	if (spcr->interrupt_type == 0) {
++		passed = false;
++		fwts_failed(fw, LOG_LEVEL_HIGH,
++			"SPCRUnknownInterruptType",
++			"SPCR interrupt type field is zero, expecting support bits to be set");
++	}
++	if (spcr->interrupt_type & 0xf0) {
++		passed = false;
++		fwts_failed(fw, LOG_LEVEL_HIGH,
++			"SPCRIllegalReservedInterruptType",
++			"SPCR interrupt type reserved bits are non-zero zero, got 0x%" PRIx8,
++				spcr->interrupt_type);
++	}
++
++	/* Check PC-AT compatible UART IRQs */
++	if (spcr->interrupt_type & 1) {
++		switch (spcr->irq) {
++		case  2 ...  7:
++		case  9 ... 12:
++		case 14 ... 15:
++			break;
++		default:
++			passed = false;
++			fwts_failed(fw, LOG_LEVEL_HIGH,
++				"SPCRIllegalIRQ",
++				"SPCR PC-AT compatible IRQ 0x%" PRIx8 " is invalid", spcr->irq);
++			break;
++		}
++	}
++
++	reserved = false;
++	switch (spcr->baud_rate) {
++	case 0x03:
++		str = "9600";
++		break;
++	case 0x04:
++		str = "19200";
++		break;
++	case 0x06:
++		str = "57600";
++		break;
++	case 0x07:
++		str = "115200";
++		break;
++	default:
++		str = "Reserved";
++		reserved = true;
++	}
++	fwts_log_info_verbatim(fw, "Baud Rate:        %s", str);
++	if (reserved) {
++		passed = false;
++		fwts_failed(fw, LOG_LEVEL_HIGH,
++			"SPCRBaudRateReserved",
++			"SPCR Serial baud rate type 0x%2.2" PRIx8
++			" is a reserved baud rate", spcr->baud_rate);
++	}
++
++	if (spcr->parity & ~1) {
++		passed = false;
++		fwts_failed(fw, LOG_LEVEL_HIGH,
++			"SPCRParityReserved",
++			"SPCR parity reserved bits 1..7 are non-zero, value is 0x%2.2" PRIx8,
++			spcr->parity);
++	}
++
++	/* Stop bit *really* is bit 1 according to the spec */
++	if (spcr->parity & ~2) {
++		passed = false;
++		fwts_failed(fw, LOG_LEVEL_HIGH,
++			"SPCRStopBitReserved",
++			"SPCR stop bit reserved bits 0,2..7 are non-zero, value is 0x%2.2" PRIx8,
++			spcr->parity);
++	}
++
++	if (spcr->flow_control & ~7) {
++		passed = false;
++		fwts_failed(fw, LOG_LEVEL_HIGH,
++			"SPCRFlowControlReserved",
++			"SPCR flow control reserved bits 3..7 are non-zero, value is 0x%2.2" PRIx8,
++			spcr->flow_control);
++	}
++
++	reserved = false;
++	switch (spcr->terminal_type) {
++	case 0x00:
++		str = "VT100";
++		break;
++	case 0x01:
++		str = "VT100+";
++		break;
++	case 0x02:
++		str = "VT-UTF8";
++		break;
++	case 0x03:
++		str = "ANSI";
++		break;
++	default:
++		str = "Reserved";
++		reserved = true;
++	}
++	fwts_log_info_verbatim(fw, "Terminal Type:    %s", str);
++	if (reserved) {
++		passed = false;
++		fwts_failed(fw, LOG_LEVEL_HIGH,
++			"SPCRTerminalTypeReserved",
++			"SPCR terminal type type 0x%2.2" PRIx8
++			" is a reserved terminal type", spcr->terminal_type);
++	}
++
++	if (spcr->reserved2) {
++		passed = false;
++		fwts_failed(fw, LOG_LEVEL_LOW,
++			"SPCRReservedNonZero",
++			"SPCR reserved field must be zero, got "
++			"0x%2.2" PRIx8 " instead", spcr->reserved2);
++	}
++
++	/* According to the spec, these values indicate NOT a PCI device */
++	if ((spcr->pci_device_id == 0xffff) &&
++	    (spcr->pci_vendor_id == 0xffff) &&
++	    (spcr->pci_bus_number == 0) &&
++	    (spcr->pci_device_number == 0) &&
++	    (spcr->pci_function_number == 0))
++		pci = false;
++
++	/* Now validate all pci specific fields if not-PCI enabled */
++	if (pci) {
++		if (spcr->pci_device_id == 0xffff) {
++			passed = false;
++			fwts_failed(fw, LOG_LEVEL_HIGH,
++				"SPCRPciDeviceID",
++				"SPCR PCI device ID is 0x%4.4" PRIx16
++				", expecting non-0xffff for PCI device",
++				spcr->pci_device_id);
++		}
++		if (spcr->pci_vendor_id == 0xffff) {
++			passed = false;
++			fwts_failed(fw, LOG_LEVEL_HIGH,
++				"SPCRPciVendorID",
++				"SPCR PCI vendor ID is 0x%4.4" PRIx16
++				", expecting non-0xffff for non-PCI device",
++				spcr->pci_vendor_id);
++		}
++		if ((spcr->pci_flags & 1) == 0) {
++			passed = false;
++			fwts_failed(fw, LOG_LEVEL_HIGH,
++				"SPCRPciFlagsBit0",
++				"SPCR PCI flags compatibility bit 0 is %" PRIx32
++				", expecting 1 for PCI device",
++				spcr->pci_flags & 1);
++		}
++	}
++
++	if (spcr->pci_flags & 0xfffe) {
++		passed = false;
++		fwts_failed(fw, LOG_LEVEL_HIGH,
++			"SPCRPciFlags",
++			"SPCR PCI flags reserved bits 1-31 are %" PRIx32
++			", expecting 0",
++			spcr->pci_flags);
++	}
++
++	if (spcr->reserved3) {
++		passed = false;
++		fwts_failed(fw, LOG_LEVEL_LOW,
++			"SPCRReservedNonZero",
++			"SPCR reserved field must be zero, got "
++			"0x%2.2" PRIx8 " instead", spcr->reserved3);
++	}
++
++	if (passed)
++		fwts_passed(fw, "No issues found in SPCR table.");
++
++	return FWTS_OK;
++}
++
++static fwts_framework_minor_test sbbr_spcr_tests[] = {
++	{ sbbr_spcr_revision_test, "SPCR Revision Test." },
++	{ sbbr_spcr_gsiv_test, "SPCR GSIV Interrupt Test." },
++	{ sbbr_spcr_generic_test, "SPCR Serial Port Console Redirection Table test." },
++	{ NULL, NULL }
++};
++
++static fwts_framework_ops sbbr_spcr_ops = {
++	.description = "SPCR Serial Port Console Redirection Table test.",
++	.init        = sbbr_spcr_init,
++	.minor_tests = sbbr_spcr_tests
++};
++
++FWTS_REGISTER("sbbr_spcr", &sbbr_spcr_ops, FWTS_TEST_ANYTIME, FWTS_FLAG_TEST_SBBR)
++
++#endif
+diff --git a/src/sbbr/xsdt/xsdt.c b/src/sbbr/xsdt/xsdt.c
+new file mode 100644
+index 0000000..7d4aaec
+--- /dev/null
++++ b/src/sbbr/xsdt/xsdt.c
+@@ -0,0 +1,90 @@
++/*
++ * Copyright (C) 2015-2017 Canonical
++ * Copyright (C) 2017 ARM Ltd
++ *
++ * Portions of this code original from the Linux-ready Firmware Developer Kit
++ *
++ * This program is free software; you can redistribute it and/or
++ * modify it under the terms of the GNU General Public License
++ * as published by the Free Software Foundation; either version 2
++ * of the License, or (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
++ *
++ */
++#include "fwts.h"
++
++#if defined(FWTS_HAS_SBBR)
++
++#include <stdlib.h>
++#include <stdio.h>
++#include <unistd.h>
++#include <inttypes.h>
++#include <string.h>
++
++static fwts_acpi_table_info *table;
++
++static int sbbr_xsdt_init(fwts_framework *fw)
++{
++	if (fwts_acpi_find_table(fw, "XSDT", 0, &table) != FWTS_OK) {
++		fwts_log_error(fw, "Cannot read ACPI tables.");
++		return FWTS_ERROR;
++	}
++	if (table == NULL || (table && table->length == 0)) {
++		fwts_log_error(fw, "ACPI XSDT table does not exist.");
++		return FWTS_ERROR;
++	}
++	return FWTS_OK;
++}
++
++/*
++ *  XSDT Extended System Description Table
++ */
++static int sbbr_xsdt_test1(fwts_framework *fw)
++{
++	fwts_acpi_table_xsdt *xsdt = (fwts_acpi_table_xsdt*)table->data;
++	size_t i, n;
++	bool passed = true;
++
++	n = (table->length - sizeof(fwts_acpi_table_header)) / sizeof(uint64_t);
++	for (i = 0; i < n; i++) {
++		if (xsdt->entries[i] == 0) {
++			passed = false;
++			fwts_failed(fw, LOG_LEVEL_CRITICAL,
++				"XSDTEntryNull",
++				"XSDT Entry %zd is null, should not be non-zero.", i);
++			fwts_advice(fw,
++				"A XSDT pointer is null and therefore erroneously "
++				"points to an invalid 64 bit ACPI table header. "
++				"At worse this will cause the kernel to oops, at "
++				"best the kernel may ignore this.  However, it "
++				"should be fixed where possible.");
++		}
++	}
++	if (passed)
++		fwts_passed(fw, "XSDT is present, pointed at by XsdrAddress=0x%lx and contain valid pointers to %d other ACPI tables mandated by SBBR", xsdt->entries[0], (int)n);
++
++	return FWTS_OK;
++}
++
++static fwts_framework_minor_test sbbr_xsdt_tests[] = {
++	{ sbbr_xsdt_test1, "XSDT Extended System Description Table test." },
++	{ NULL, NULL }
++};
++
++static fwts_framework_ops sbbr_xsdt_ops = {
++	.description = "XSDT Extended System Description Table test.",
++	.init        = sbbr_xsdt_init,
++	.minor_tests = sbbr_xsdt_tests
++};
++
++FWTS_REGISTER("sbbr_xsdt", &sbbr_xsdt_ops, FWTS_TEST_ANYTIME, FWTS_FLAG_TEST_SBBR)
++
++#endif
diff --git a/meta-luv/recipes-core/fwts/fwts_git.bb b/meta-luv/recipes-core/fwts/fwts_git.bb
index fd8a8f8..62113f5 100644
--- a/meta-luv/recipes-core/fwts/fwts_git.bb
+++ b/meta-luv/recipes-core/fwts/fwts_git.bb
@@ -9,6 +9,7 @@ PV = "V17.03.00+git${SRCPV}"
 SRCREV = "e3e9d1442b4cc70f5b30199f584cec8e25aeaad4"
 SRC_URI = "git://kernel.ubuntu.com/hwe/fwts.git \
            file://luv-parser-fwts \
+           file://sbbr.patch \
           "
 
 S = "${WORKDIR}/git"
@@ -50,8 +51,7 @@ do_install_append() {
 }
 
 LUV_TEST_LOG_PARSER="luv-parser-fwts"
-LUV_TEST_ARGS="-r stdout -q --uefitests --log-format='%owner;%field ' \
-	      --batch"
+LUV_TEST_ARGS="-r stdout -q --log-format='%owner;%field ' --sbbr"
 
 FILES_${PN} += "${libdir}/fwts/lib*${SOLIBS}"
 FILES_${PN} += "/lib/modules/${KERNEL_VERSION}/extra/efi_runtime.ko"
diff --git a/meta-luv/recipes-core/images/core-image-efi-initramfs.bb b/meta-luv/recipes-core/images/core-image-efi-initramfs.bb
index 82a9cb8..b7e6a8d 100644
--- a/meta-luv/recipes-core/images/core-image-efi-initramfs.bb
+++ b/meta-luv/recipes-core/images/core-image-efi-initramfs.bb
@@ -9,6 +9,7 @@ IMAGE_INSTALL = "\
     util-linux-mount util-linux-umount kmod sed tar net-tools \
     shadow util-linux procps efivarfs-test \
     plymouth plymouth-set-default-theme kernel-efi-warnings linux-firmware kexec \
+    sbsa-acs-drv sbsa-acs-app \
     "
 
 X86_ADDITIONS = "chipsec python-codecs python-subprocess vmcore-dmesg bits \
diff --git a/meta-luv/recipes-core/images/luv-live-image.bb b/meta-luv/recipes-core/images/luv-live-image.bb
index 50cad08..8c5b75c 100644
--- a/meta-luv/recipes-core/images/luv-live-image.bb
+++ b/meta-luv/recipes-core/images/luv-live-image.bb
@@ -26,7 +26,7 @@ COMMON_CMDLINE_x86 += "splash nomodeset crash_kexec_post_notifiers"
 
 # Unlike the += operand, _append's do not insert a space between the current value
 # and the appended string. Thus, we add them.
-CMDLINE_append_aarch64 = " acpi=on"
+CMDLINE_append_aarch64 = " acpi=on crashkernel=256M earlycon uefi_debug ${ACS_CMDLINE_APPEND}"
 CMDLINE_append_x86 = "${COMMON_CMDLINE_x86}"
 CMDLINE_append_x86-64 = "${COMMON_CMDLINE_x86}"
 
@@ -42,7 +42,7 @@ python() {
 
 SPLASH_IMAGE = "blue-luv.jpg"
 
-GRUB_TIMEOUT = "2"
+GRUB_TIMEOUT = "1"
 
 inherit image-live
 
@@ -66,8 +66,8 @@ build_img() {
     BYTES_PER_SECTOR=512
     MiB=$(expr 1024 \* 1024)
     VFAT_RESULTS=${DEPLOY_DIR_IMAGE}/${PN}-results.hddimg
-    # 16MB of space to store test results
-    VFAT_RESULTS_SPACE_MiB=16
+    # 128 MB of space for test results and SCT installation
+    VFAT_RESULTS_SPACE_MiB=128
     VFAT_RESULTS_SPACE=$(expr $VFAT_RESULTS_SPACE_MiB \* $MiB)
     VFAT_RESULTS_BLOCKS=$(expr $VFAT_RESULTS_SPACE / 1024)
     # TODO: do we need to dynamically generate the UUID?
diff --git a/meta-luv/recipes-core/images/luv-netboot-image.bb b/meta-luv/recipes-core/images/luv-netboot-image.bb
index d8205ee..d3811fa 100644
--- a/meta-luv/recipes-core/images/luv-netboot-image.bb
+++ b/meta-luv/recipes-core/images/luv-netboot-image.bb
@@ -1,7 +1,7 @@
 LICENSE = "MIT"
 LIC_FILES_CHKSUM = "file://${COREBASE}/LICENSE;md5=4d92cd373abda3937c2bc47fbc49d690"
 
-DEPENDS_${PN} = "bits"
+DEPENDS_${PN} = "bits sbbr"
 
 INITRD_IMAGE_LIVE = "core-image-efi-initramfs"
 IMGDEPLOYDIR = "${DEPLOY_DIR_IMAGE}"
@@ -28,7 +28,7 @@ COMMON_CMDLINE_x86 += "splash nomodeset crash_kexec_post_notifiers"
 
 # Unlike the += operand, _append's do not insert a space between the current value
 # and the appended string. Thus, we add them.
-CMDLINE_append_aarch64 = " acpi=on"
+CMDLINE_append_aarch64 = " acpi=on crashkernel=256M earlycon uefi_debug luv.netboot"
 CMDLINE_append_x86 = "${COMMON_CMDLINE_x86}"
 CMDLINE_append_x86-64 = "${COMMON_CMDLINE_x86}"
 
@@ -59,7 +59,8 @@ do_mkimage[depends] += "dosfstools-native:do_populate_sysroot \
                         mtools-native:do_populate_sysroot \
                         cdrtools-native:do_populate_sysroot \
                         virtual/kernel:do_deploy \
-			${_BITSDEPENDS}"
+                        ${_BITSDEPENDS} \
+                        ${_SBBRDEPENDS}"
 
 do_bootimg[noexec] = "1"
 
@@ -68,7 +69,8 @@ do_populate_image() {
 	if [ "${TARGET_ARCH}" != "aarch64" ]; then
 		efi_populate_bits ${HDDDIR}
 	else
-		echo "bootaa64.efi" > ${HDDDIR}${EFIDIR}/startup.nsh
+		efi_populate_sbbr ${HDDDIR}
+		efi_populate_sbsa ${HDDDIR}
 		install -m 0644 ${DEPLOY_DIR_IMAGE}/bootaa64.efi ${HDDDIR}${EFIDIR}
 	fi
 	install -m 0644 ${GRUBCFG} ${HDDDIR}${EFIDIR}
diff --git a/meta-luv/recipes-core/kernel_efi_warnings/kernel-efi-warnings_0.1.bb b/meta-luv/recipes-core/kernel_efi_warnings/kernel-efi-warnings_0.1.bb
index a0fde3c..85eec50 100644
--- a/meta-luv/recipes-core/kernel_efi_warnings/kernel-efi-warnings_0.1.bb
+++ b/meta-luv/recipes-core/kernel_efi_warnings/kernel-efi-warnings_0.1.bb
@@ -20,5 +20,3 @@ do_install() {
 }
 
 LUV_TEST_LOG_PARSER="luv-parser-kernel-efi-warnings"
-LUV_TEST="kernel-efi-warnings"
-LUV_TEST_ARGS=""
diff --git a/meta-luv/recipes-core/luv-test/luv-test.bb b/meta-luv/recipes-core/luv-test/luv-test.bb
index 7a94cc3..a35e2b9 100644
--- a/meta-luv/recipes-core/luv-test/luv-test.bb
+++ b/meta-luv/recipes-core/luv-test/luv-test.bb
@@ -32,6 +32,8 @@ SRC_URI += "file://luv-test-manager file://luv-test-parser \
             file://luv-test-manager.service \
             file://luv-crash-handler.service \
             file://luv-netconsole.service \
+            file://luv-collect-results \
+            file://luv-sbsa-test \
           "
 
 RDEPENDS_${PN}-netconsole+= "kernel-modules curl iputils iproute2 bash init-ifupdown dhcp-client"
@@ -67,6 +69,10 @@ do_install_append() {
        install -m 0644 ${WORKDIR}/luv-scripts ${D}${datadir}/luv/html
        install -m 0644 ${WORKDIR}/luv-css-styles ${D}${datadir}/luv/html
 
+       # Install luv-collect-results script
+       install -m 755 ${WORKDIR}/luv-collect-results ${D}${sysconfdir}/
+       install -m 755 ${WORKDIR}/luv-sbsa-test ${D}${sysconfdir}/
+
        install -d ${D}${systemd_unitdir}/system
 
        install -m 0644 ${WORKDIR}/luv-test-manager.service ${D}${systemd_unitdir}/system
diff --git a/meta-luv/recipes-core/luv-test/luv-test/luv-collect-results b/meta-luv/recipes-core/luv-test/luv-test/luv-collect-results
new file mode 100644
index 0000000..e6542e4
--- /dev/null
+++ b/meta-luv/recipes-core/luv-test/luv-test/luv-collect-results
@@ -0,0 +1,209 @@
+#!/usr/bin/env python
+
+import sys
+import os
+import re
+import codecs
+
+def log_fwts(d):
+    testCategory = ""
+    testName = ""
+    testPasses = 0
+    testFails = 0
+    testSkips = 0
+    totalPasses = 0
+    totalFails = 0
+    totalSkips = 0
+
+    # Finding latest FWTS results directory.
+    directory = os.listdir(d)
+    fwtsDir = ""
+    for folder in directory:
+        if "luv-results-" in folder and folder > fwtsDir:
+            fwtsDir = folder
+
+    # Opening FWTS raw output file.
+    fwtsRawPath = os.path.join(d, fwtsDir, "raw", "fwts")
+    try:
+        fwtsRaw = open(fwtsRawPath, "r")
+    except IOError:
+        print "FWTS raw results file \"%s\" could not be opened, skipping." % fwtsRawPath
+        return -1
+
+    # Printing .MD file header for FWTS results.
+    outFile.write("# FWTS Test Results\n")
+    outFile.write("| Category | Test Case | Passes | Skips | Failures |\n")
+    outFile.write("| :--- | :--- | ---: | ---: | ---: |\n")
+
+    # Scraping FWTS output.
+    while True:
+        # Getting a line from file.
+        line = fwtsRaw.readline()
+        if line == "":
+            if testCategory != "":
+                outFile.write ("| %s | %s | %d | %d | %d |\n" % (testCategory, testName, testPasses, testSkips, testFails))
+                outFile.write ("| Total |  | %d | %d | %d |\n" % (totalPasses, totalSkips, totalFails))
+            return 0
+        line = line.rstrip()
+
+        # Checking if line is the beginning of a new test results block.
+        matchString = re.search(r"INF Test \d", line, re.M|re.I)
+        if matchString:
+            # Printing information for previous test before we move to next one.
+            if testName != "":
+                outFile.write ("| %s | %s | %d | %d | %d |\n" % (testCategory, testName, testPasses, testSkips, testFails))
+                testCategory = ""
+            currentTest = line.split()[2] + " " + line.split()[3]
+            testCategory = line.split()[0]
+            testName = line[(line.index(":") + 2):]
+            testPasses = 0
+            testFails = 0
+            testSkips = 0
+            testInfos = 0
+            while testName[len(testName) - 1] != ".":
+                line = fwtsRaw.readline().rstrip()
+                if ";INF" not in line:
+                    break
+                testName = testName + " " + line[20:]
+
+        # Checking if line is a pass/fail/skip for currentTest.
+        if "PASSED" in line and currentTest in line:
+            testPasses = testPasses + 1
+            totalPasses = totalPasses + 1
+        if "SKIPPED" in line and currentTest in line:
+            testSkips = testSkips + 1
+            totalSkips = totalSkips + 1
+        if "FAILED" in line and currentTest in line:
+            testFails = testFails + 1
+            totalFails = totalFails + 1
+
+def log_sbbr(d):
+    testCategory = ""
+    testName = ""
+    testCase = ""
+    testDescription = ""
+    testPasses = 0
+    testWarnings = 0
+    testErrors = 0
+    totalPasses = 0
+    totalWarnings = 0
+    totalErrors = 0
+
+    # Finding SCT test results.
+    sbbrDir = os.path.join(d, "SCT", "Log")
+    if os.path.isdir(sbbrDir) == False:
+        print "SBBR SCT results directory \"%s\" not found.  Skipping." % sbbrDir
+        return -1
+
+    # Printing .MD file header for SCT results.
+    outFile.write("# UEFI SBBR SCT Test Results\n")
+    outFile.write("| Category | Test File | Test Case | Description | Passes | Warnings | Errors |\n")
+    outFile.write("| :--- | :--- | :--- | :--- | ---: | ---: | ---: |\n")
+
+    # Recursively walking through SBBR results folders.
+    for dirpath, dirnames, filenames in os.walk(sbbrDir):
+        for entry in filenames:
+            if ".log" in entry:
+                path, testName = os.path.split(dirpath)
+                testName = testName.split("0")[0]
+                path, testCategory = os.path.split(path)
+                with codecs.open(os.path.join(dirpath, entry), mode="r", encoding="utf-16") as logfile:
+                    i = 1
+                    while True:
+                        line = logfile.readline()
+                        if line == "":
+                            break
+                        if i == 2:
+                            testCase = line.rstrip()
+                        if i == 11:
+                            testDescription = line.rstrip()
+                        if "Passes..........." in line:
+                            testPasses = int(line.split()[1])
+                        if "Warnings........." in line:
+                            testWarnings = int(line.split()[1])
+                        if "Errors..........." in line:
+                            testErrors = int(line.split()[1])
+                        i = i + 1
+                    outFile.write("| %s | %s | %s | %s | %d | %d | %d |\n" % (testCategory, testName, testCase, testDescription, testPasses, testWarnings, testErrors))
+                    totalPasses = totalPasses + testPasses
+                    totalWarnings = totalWarnings + testWarnings
+                    totalErrors = totalErrors + testErrors
+
+    # Print totals.
+    outFile.write("| Total | | | | %d | %d | %d |" % (totalPasses, totalWarnings, totalErrors))
+
+def log_sbsa(d):
+    sbsaDir = os.path.join(d, "sbsa_results")
+    if os.path.isdir(sbsaDir) == False:
+        print "SBSA results results directory \"%s\" not found.  Skipping." % sbsaDir
+        return -1
+
+    uefi = "not found";
+    linux = "not found";
+    for entry in os.listdir(sbsaDir):
+        if(entry == "uefi"):
+            sbsaUefiLogs = os.path.join(sbsaDir, "uefi", "SbsaResults.log")
+	    try:
+		f = open(sbsaUefiLogs, "r")
+	    except IOError:
+		print "SBSA UEFI results file \"%s\" could not be opened, skipping." % sbsaUefiLogs
+                continue
+            logs = f.read()
+            outFile.write("\n\nSBSA UEFI Test Results\n\n")
+            outFile.write(logs)
+	    uefi = "collected"
+	if(entry=="linux"):
+	    sbsaLinuxLogs = os.path.join(sbsaDir, "linux", "SbsaResults.log")
+	    try:
+		f = open(sbsaLinuxLogs, "r")
+	    except IOError:
+		print "SBSA Linux results file \"%s\" could not be opened, skipping." % sbsaLinuxLogs
+		continue
+            logs = f.read()
+            outFile.write("\n\nSBSA Linux Test Results\n\n")
+            outFile.write(logs)
+	    linux = "collected"
+    print "SBSA Results for linux %s\n" % linux
+    print "SBSA Results for UEFI %s\n" % uefi
+
+# Script entry point.
+
+# This script needs to be run on a stripped out yocto distribution so we can't use argparse.
+if "-h" in sys.argv or "--help" in sys.argv:
+    print "Usage:"
+    print " python %s [-h] LUV_RESULTS OUTPUT_FILE" % sys.argv[0]
+    print "Options:"
+    print " -h, --help              Display this help and exit."
+    print " LUV_RESULTS             Path to luv-results directory/drive."
+    print " OUTPUT_FILE             File for script output, must have .md file extension."
+    exit()
+
+arg_directory = sys.argv[1]
+arg_output = sys.argv[2]
+
+# Validating parameter and opening output file.
+filename, fileext = os.path.splitext(arg_output)
+if fileext != ".md" and fileext != ".MD":
+    print "Output file must have .md file extension. Exiting."
+    exit()
+try:
+    outFile = open(arg_output, "w")
+except IOError:
+    print "Could not open \"%s\" for writing. Exiting." % arg_output
+    exit()
+
+# Scanning FWTS.
+print "Gathering FWTS test results..."
+log_fwts(arg_directory)
+
+# Scanning SBBR.
+print "Gathering UEFI SBBR SCT test results..."
+log_sbbr(arg_directory)
+
+# Scanning SBSA.
+print "Gathering SBSA test results..."
+log_sbsa(arg_directory)
+
+outFile.close()
+
+print "Done, test results can be found in \"%s\"" % arg_output
diff --git a/meta-luv/recipes-core/luv-test/luv-test/luv-sbsa-test b/meta-luv/recipes-core/luv-test/luv-test/luv-sbsa-test
new file mode 100755
index 0000000..756bc02
--- /dev/null
+++ b/meta-luv/recipes-core/luv-test/luv-test/luv-sbsa-test
@@ -0,0 +1,5 @@
+#!/bin/bash
+
+insmod /lib/modules/4.10.0-yocto-standard/extra/sbsa_acs.ko
+mkdir -p $1/sbsa_results/linux
+sbsa > $1/sbsa_results/linux/SbsaResults.log
diff --git a/meta-luv/recipes-core/luv-test/luv-test/luv-test-manager b/meta-luv/recipes-core/luv-test/luv-test/luv-test-manager
index 38aa116..0197db9 100644
--- a/meta-luv/recipes-core/luv-test/luv-test/luv-test-manager
+++ b/meta-luv/recipes-core/luv-test/luv-test/luv-test-manager
@@ -256,6 +256,11 @@ done | awk '/\[\+/  { units += 1 }
 cat /tmp/testsuites | html_inline ${LUV_HTML_REPORT} | tee -a /dev/kmsg /tmp/luv.results \
          ${LUV_SAVE_RESULTS_DIR}/luv.results
 
+# test SBSA compliance on luv
+sh /etc/luv-sbsa-test ${LUV_STORAGE}
+# collecting test results
+python /etc/luv-collect-results ${LUV_STORAGE} ${LUV_STORAGE}/results.md
+
 result=$(cat /tmp/testsuites)
 plymouth_write "$result"
 sleep 2
diff --git a/meta-luv/recipes-kernel/linux/linux-yocto-efi-test_4.10.bb b/meta-luv/recipes-kernel/linux/linux-yocto-efi-test_4.10.bb
index 916cc71..cc504a3 100644
--- a/meta-luv/recipes-kernel/linux/linux-yocto-efi-test_4.10.bb
+++ b/meta-luv/recipes-kernel/linux/linux-yocto-efi-test_4.10.bb
@@ -78,6 +78,9 @@ SRC_URI += "file://0001-x86-efi-Move-efi_bgrt_init-to-early-stage.patch \
 SRC_URI += "file://0001-serial-SPCR-check-bit-width-for-the-16550-UART.patch  \
            "
 
+SRC_URI += "file://0001-SBSA-ACS-linux-4.10.patch \
+           "
+
 COMMON_CFG_x86 = " file://${MACHINE}/defconfig \
                    file://qemux86/modules.cfg \
                    file://qemux86/display.cfg \
diff --git a/meta/conf/bitbake.conf b/meta/conf/bitbake.conf
index 54a587f..b05fe94 100644
--- a/meta/conf/bitbake.conf
+++ b/meta/conf/bitbake.conf
@@ -728,7 +728,7 @@ INITRAMFS_FSTYPES ?= "cpio.gz"
 # The maximum size in Kbytes for the generated initramfs image size.
 # Usually, it should be less than 1/2 of ram size, or you may fail to
 # boot it.
-INITRAMFS_MAXSIZE ??= "131072"
+INITRAMFS_MAXSIZE ??= "196608"
 
 DEFAULT_TASK_PROVIDER ?= "packagegroup-base"
 MACHINE_TASK_PROVIDER ?= "${DEFAULT_TASK_PROVIDER}"
diff --git a/sbsa_setup.sh b/sbsa_setup.sh
new file mode 100755
index 0000000..45899fd
--- /dev/null
+++ b/sbsa_setup.sh
@@ -0,0 +1,28 @@
+#!/bin/bash
+
+#create tmp directory
+TMPDIR=$PWD/tmp
+LUVDIR=$PWD
+rm -rf $TMPDIR
+mkdir $TMPDIR
+cd $TMPDIR
+#clone linux-acs repo
+git clone git://linux-arm.org/linux-acs.git
+cd linux-acs
+#copy .bb and source files to relevant places
+rm -rf $LUVDIR/meta-luv/recipes-core/sbsa-acs-drv
+mv -f sbsa-acs-drv $LUVDIR/meta-luv/recipes-core/
+mv -f kernel/src/0001-SBSA-ACS-linux-4.10.patch $LUVDIR/meta-luv/recipes-kernel/linux/linux-yocto-efi-test/
+
+cd $TMPDIR
+git clone https://github.com/ARM-software/sbsa-acs.git
+cd sbsa-acs
+mv -f val $LUVDIR/meta-luv/recipes-core/sbsa-acs-drv/files/
+mv -f test_pool $LUVDIR/meta-luv/recipes-core/sbsa-acs-drv/files/
+
+rm -rf $LUVDIR/meta-luv/recipes-utils/sbsa-acs-app
+mkdir -p $LUVDIR/meta-luv/recipes-utils/sbsa-acs-app
+mv -f linux_app/* $LUVDIR/meta-luv/recipes-utils/sbsa-acs-app/
+
+cd $TMPDIR/..
+rm -rf $TMPDIR
-- 
2.7.4

